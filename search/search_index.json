{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QA Automation Starter for Python","text":"<p>Modular Python packages for maintainable, BDD-style automated tests with <code>pytest</code>, <code>Hamcrest</code>, <code>Allure</code> reporting, and configurable logging.</p> <p>Technology-agnostic; example REST, Selenium and RabbitMQ implementations included.</p> <p></p> <p>see live Example Allure Report</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.13</li> <li>PDM (Python package manager)</li> </ul>"},{"location":"#optional","title":"Optional","text":"<ul> <li>Google Chrome for local Selenium testing</li> <li>RabbitMQ for running local tests</li> <li>Allure for generating a nice test dashboard like above</li> </ul>"},{"location":"architecture/","title":"Architecture","text":"<p>Support for additional technologies, e.g. ElasticSearch, can be added by sub-classing these classes and adding specific steps, setup/teardown, and configuration. This allows reusing the basic configuration, reporting, logging, and retrying mechanisms. Further, application tests, steps, and configurations reuse by subclassing from technologies.</p> <pre><code>flowchart TD\n    A[Tests: Define BDD scenarios as series of steps, also define specific setup and teardown] --&gt; |contains| B[Steps: encapsulate UI or API operations and verifications, and may be composed of other steps]\n    B --&gt; |contains| C[Configurations: can be per environment, such as dev, qa, staging, and contain URLs, users, authentication schemes, encryption, etc.]\n    B --&gt; |uses| D[Matchers: Hamcrest matchers for single objects or for iterables]\n    A --&gt; |contains| C\n    B --&gt; |uses| E[Models: domain objects]\n\n    subgraph Inheritance\n        A1[GenericTests] -.-&gt; |inherits| A2[Tests]\n        B1[GenericSteps] -.-&gt; |inherits| B2[Steps]\n        C1[AbstractConfiguration] -.-&gt; |inherits| C2[Configuration]\n    end\n</code></pre>"},{"location":"architecture/#extending-the-framework","title":"Extending the Framework","text":"<p>To add support for a new technology (e.g., messaging, database), create: - <code>MyTechConfiguration(BaseConfiguration)</code> - <code>MyTechSteps(GenericSteps[MyTechConfiguration])</code> - <code>MyTechTests(AbstractTestsBase[MyTechSteps, MyTechConfiguration])</code> This pattern ensures you reuse the core BDD, configuration, and reporting mechanisms.</p> <pre><code>classDiagram\n    %% Core Abstractions\n    class AbstractTestsBase {\n        &lt;&gt;\n        +steps\n        +_configuration\n        +setup_method()\n        +teardown_method()\n    }\n    class GenericSteps {\n        &lt;&gt;\n        +given\n        +when\n        +then\n        +and_\n        +with_\n        +retrying()\n        +eventually_assert_that()\n    }\n    class BaseConfiguration {\n        &lt;&gt;\n        +parser\n    }\n\n    %% Technology-Specific Extensions\n    class RestTests\n    class RestSteps\n    class RestConfiguration\n\n    class SeleniumTests\n    class SeleniumSteps\n    class SeleniumConfiguration\n\n    %% Example: Custom Extension\n    class TerminalXTests\n    class TerminalXSteps\n    class TerminalXConfiguration\n\n    %% Relationships\n    AbstractTestsBase &lt;|-- RestTests\n    AbstractTestsBase &lt;|-- SeleniumTests\n    SeleniumTests &lt;|-- TerminalXTests\n\n    GenericSteps &lt;|-- RestSteps\n    GenericSteps &lt;|-- SeleniumSteps\n    SeleniumSteps &lt;|-- TerminalXSteps\n\n    BaseConfiguration &lt;|-- RestConfiguration\n    BaseConfiguration &lt;|-- SeleniumConfiguration\n    SeleniumConfiguration &lt;|-- TerminalXConfiguration\n\n    RestTests o-- RestSteps : uses\n    RestTests o-- RestConfiguration : configures\n\n    SeleniumTests o-- SeleniumSteps : uses\n    SeleniumTests o-- SeleniumConfiguration : configures\n\n    TerminalXTests o-- TerminalXSteps : uses\n    TerminalXTests o-- TerminalXConfiguration : configures\n\n    %% Example extension note\n    %% You can add new technologies by subclassing the three core abstractions:\n    %% AbstractTestsBase, GenericSteps, and BaseConfiguration."},{"location":"architecture/#key-classes","title":"Key Classes","text":"Class\nDescription\n\n\n\n\n<code>AbstractTestsBase</code>\nBase for all test scenarios; holds steps and config\n\n\n<code>GenericSteps</code>\nBase for all step implementations; provides BDD keywords\n\n\n<code>BaseConfiguration</code>\nBase for all configuration objects\n\n\n<code>RestTests</code>\nREST-specific test base\n\n\n<code>RestSteps</code>\nREST-specific steps\n\n\n<code>RestConfiguration</code>\nREST-specific configuration\n\n\n<code>SeleniumTests</code>\nSelenium-specific test base\n\n\n<code>SeleniumSteps</code>\nSelenium-specific steps\n\n\n<code>SeleniumConfiguration</code>\nSelenium-specific configuration\n\n\n<code>TerminalXTests</code>\nExample: custom UI test base\n\n\n<code>TerminalXSteps</code>\nExample: custom UI steps\n\n\n<code>TerminalXConfiguration</code>\nExample: custom UI configuration\n\n\n---"},{"location":"example-tests/","title":"Example Tests","text":"<p>Below are example test cases demonstrating BDD-style usage with this framework:</p>"},{"location":"example-tests/#ui-search-test","title":"UI search test","text":"<pre><code>def should_find(self):\n    (self.login_section(self.configuration.random_user)\n        .when.clicking_search())\n\n    for word in [\"hello\", \"kitty\"]:\n        (self.steps\n            .when.searching_for(word)\n            .then.the_search_hints(yields_item(traced(\n                contains_string_ignoring_case(word)))))\n</code></pre>"},{"location":"example-tests/#swagger-api-add-pet-test","title":"Swagger API add pet test","text":"<pre><code>def should_add(self):\n    random_pet = SwaggerPetstorePet.random()\n    (self.steps\n        .given.swagger_petstore(self.rest_session)\n        .when.adding(random_pet)\n        .then.the_available_pets(yields_item(traced(is_(random_pet)))))\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Open in Codespace or Dev Container and everything will get installed and configured, otherwise:</p> <ol> <li> <p>Install Python 3.13 on your system</p> </li> <li> <p>Install PDM:    <pre><code>pipx install pdm[all]\n</code></pre></p> </li> <li> <p>Fork/Clone demo project, e.g.:    <pre><code>git clone https://github.com/QA-Automation-Starter/qa-automation-python-demo.git\n</code></pre></p> </li> <li> <p>Install dependencies:    <pre><code>pdm run install-deps\n</code></pre></p> </li> <li> <p>Run all tests from the root:    <pre><code>pdm run pytest\n</code></pre>    pytest html report is in <code>report.html</code></p> <p>NOTE: Selenium tests require Google Chrome installed.</p> </li> <li> <p>Optional: Generate Allure reports     <pre><code>pdm run allure-generate\n</code></pre>     then open, <code>docs/reports/index.html</code> in a browser.     &gt; NOTE: requires installation of Allure server</p> </li> </ol> <p>Customize for your needs :)</p>"},{"location":"api/qa-pytest-commons/","title":"Commons","text":""},{"location":"api/qa-pytest-commons/#qa_pytest_commons","title":"<code>qa_pytest_commons</code>","text":""},{"location":"api/qa-pytest-commons/#qa_pytest_commons.__all__","title":"<code>__all__ = ['AbstractTestsBase', 'BaseConfiguration', 'BddKeywords', 'Configuration', 'GenericSteps']</code>  <code>module-attribute</code>","text":""},{"location":"api/qa-pytest-commons/#qa_pytest_commons.__version__","title":"<code>__version__ = '0.0.11.dev7+g9b1fb9b.d20250619'</code>  <code>module-attribute</code>","text":""},{"location":"api/qa-pytest-commons/#qa_pytest_commons.AbstractTestsBase","title":"<code>AbstractTestsBase</code>","text":"<p>               Bases: <code>ABC</code>, <code>LoggerMixin</code>, <code>ImmutableMixin</code></p> <p>Basic test scenario implementation, holding some type of steps and a logger facility.</p> <p>Subtypes must set <code>_steps_type</code> to the actual type of steps implementation::</p> <pre><code>                    +---------------+\n                    |  BddKeyWords  |\n                    +---------------+\n                                    ^\n                                    |\n                                implements\n                                    |\n+-------------------+               +--------------+\n| AbstractTestsBase |---contains---&gt;| GenericSteps |\n|                   |               +--------------+\n|                   |                       +---------------+\n|                   |---contains-----------&gt;| Configuration |\n+-------------------+                       +---------------+\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>TSteps</code> <code>TSteps</code> <p>GenericSteps): The actual steps implementation, or partial implementation.</p> required Source code in <code>qa-pytest-commons/src/qa_pytest_commons/abstract_tests_base.py</code> <pre><code>class AbstractTestsBase[\n        TSteps: GenericSteps[Any],\n        TConfiguration: Configuration](ABC, LoggerMixin, ImmutableMixin):\n    \"\"\"\n    Basic test scenario implementation, holding some type of steps and a logger\n    facility.\n\n    Subtypes must set `_steps_type` to the actual type of steps implementation::\n\n                            +---------------+\n                            |  BddKeyWords  |\n                            +---------------+\n                                            ^\n                                            |\n                                        implements\n                                            |\n        +-------------------+               +--------------+\n        | AbstractTestsBase |---contains---&gt;| GenericSteps |\n        |                   |               +--------------+\n        |                   |                       +---------------+\n        |                   |---contains-----------&gt;| Configuration |\n        +-------------------+                       +---------------+\n\n    Args:\n        TSteps (TSteps:GenericSteps): The actual steps implementation, or partial implementation.\n    \"\"\"\n    _steps_type: Type[TSteps]  # IMPORTANT: pytest classes must not __init__\n    _configuration: TConfiguration\n\n    @property\n    def configuration(self) -&gt; TConfiguration:\n        '''\n        Returns the configuration instance.\n\n        Returns:\n            TConfiguration: The configuration instance.\n        '''\n        return self._configuration\n\n    @final\n    @cached_property\n    def steps(self) -&gt; TSteps:\n        '''\n        Lazily initializes and returns an instance of steps implementation.\n\n        Returns:\n            TSteps: The instance of steps implementation.\n        '''\n        self.log.debug(f\"initiating {self._steps_type}\")\n        return self._steps_type(self._configuration)\n\n    def setup_method(self):\n        \"\"\"\n        Override in subtypes with specific setup, if any.\n        \"\"\"\n        self.log.debug(\"setup\")\n\n    def teardown_method(self):\n        \"\"\"\n        Override in subtypes with specific teardown, if any.\n        \"\"\"\n        self.log.debug(\"teardown\")\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.AbstractTestsBase.configuration","title":"<code>configuration</code>  <code>property</code>","text":"<p>Returns the configuration instance.</p> <p>Returns:</p> Name Type Description <code>TConfiguration</code> <code>TConfiguration</code> <p>The configuration instance.</p>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.AbstractTestsBase.steps","title":"<code>steps</code>  <code>cached</code> <code>property</code>","text":"<p>Lazily initializes and returns an instance of steps implementation.</p> <p>Returns:</p> Name Type Description <code>TSteps</code> <code>TSteps</code> <p>The instance of steps implementation.</p>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.AbstractTestsBase.setup_method","title":"<code>setup_method()</code>","text":"<p>Override in subtypes with specific setup, if any.</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/abstract_tests_base.py</code> <pre><code>def setup_method(self):\n    \"\"\"\n    Override in subtypes with specific setup, if any.\n    \"\"\"\n    self.log.debug(\"setup\")\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.AbstractTestsBase.teardown_method","title":"<code>teardown_method()</code>","text":"<p>Override in subtypes with specific teardown, if any.</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/abstract_tests_base.py</code> <pre><code>def teardown_method(self):\n    \"\"\"\n    Override in subtypes with specific teardown, if any.\n    \"\"\"\n    self.log.debug(\"teardown\")\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.BaseConfiguration","title":"<code>BaseConfiguration</code>","text":"<p>               Bases: <code>Configuration</code>, <code>LoggerMixin</code>, <code>ImmutableMixin</code></p> <p>Base class for all types of configurations, providing a parser for a pre-specified configuration file.</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/base_configuration.py</code> <pre><code>class BaseConfiguration(Configuration, LoggerMixin, ImmutableMixin):\n    \"\"\"\n    Base class for all types of configurations, providing a parser for a\n    pre-specified configuration file.\n    \"\"\"\n    _path: Path\n\n    def __init__(self, path: Path | None = None):\n        \"\"\"\n        Initializes the configuration by loading the associated `.ini` file.\n\n        If `path` is not provided, the file is inferred based on the module name\n        of the subclass and loaded from a structured configuration directory.\n\n        The default lookup path follows this structure:\n            &lt;module_dir&gt;/configurations/${TEST_ENVIRONMENT}/&lt;module_name&gt;.ini\n\n        Where:\n            - &lt;module_dir&gt; is the directory where the subclass's module is located\n            - ${TEST_ENVIRONMENT} is an optional environment variable that specifies\n            the subdirectory (e.g., \"dev\", \"ci\", \"prod\"). If unset, it defaults\n            to an empty string (i.e., no subdirectory)\n            - &lt;module_name&gt; is the name of the `.py` file defining the subclass\n\n        Args:\n            path (Path, optional): Explicit path to the configuration file. If provided,\n                                overrides automatic inference.\n\n        Raises:\n            FileNotFoundError: If the resolved configuration file does not exist.\n        \"\"\"\n        if path is None:\n            module_file = Path(inspect.getfile(self.__class__))\n            module_stem = module_file.stem\n            resources_dir = module_file.parent / \"configurations\" / \\\n                os.environ.get(\"TEST_ENVIRONMENT\", EMPTY_STRING)\n            ini_file = resources_dir / f\"{module_stem}.ini\"\n            self._path = ini_file\n        else:\n            self._path = path\n\n        if not self._path.exists():\n            raise FileNotFoundError(\n                f\"configuration file not found: {self._path.resolve()}\")\n\n        self.log.debug(f\"using configuration from {self._path}\")\n\n    # NOTE if properties cannot be cached, this is a red-flag\n    # configuration properties should be immutable.\n    @final\n    @cached_property\n    def parser(self) -&gt; configparser.ConfigParser:\n        \"\"\"\n        Parser that reads this configuration.\n        \"\"\"\n        self.log.debug(f\"reading configuration from {self._path}\")\n        parser = configparser.ConfigParser()\n        config_files = parser.read(self._path)\n        self.log.debug(f\"successfully read {config_files}\")\n        return parser\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.BaseConfiguration.parser","title":"<code>parser</code>  <code>cached</code> <code>property</code>","text":"<p>Parser that reads this configuration.</p>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.BaseConfiguration.__init__","title":"<code>__init__(path=None)</code>","text":"<p>Initializes the configuration by loading the associated <code>.ini</code> file.</p> <p>If <code>path</code> is not provided, the file is inferred based on the module name of the subclass and loaded from a structured configuration directory.</p> The default lookup path follows this structure <p>/configurations/${TEST_ENVIRONMENT}/.ini Where <ul> <li> is the directory where the subclass's module is located <li>${TEST_ENVIRONMENT} is an optional environment variable that specifies the subdirectory (e.g., \"dev\", \"ci\", \"prod\"). If unset, it defaults to an empty string (i.e., no subdirectory)</li> <li> is the name of the <code>.py</code> file defining the subclass <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Explicit path to the configuration file. If provided,                 overrides automatic inference.</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the resolved configuration file does not exist.</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/base_configuration.py</code> <pre><code>def __init__(self, path: Path | None = None):\n    \"\"\"\n    Initializes the configuration by loading the associated `.ini` file.\n\n    If `path` is not provided, the file is inferred based on the module name\n    of the subclass and loaded from a structured configuration directory.\n\n    The default lookup path follows this structure:\n        &lt;module_dir&gt;/configurations/${TEST_ENVIRONMENT}/&lt;module_name&gt;.ini\n\n    Where:\n        - &lt;module_dir&gt; is the directory where the subclass's module is located\n        - ${TEST_ENVIRONMENT} is an optional environment variable that specifies\n        the subdirectory (e.g., \"dev\", \"ci\", \"prod\"). If unset, it defaults\n        to an empty string (i.e., no subdirectory)\n        - &lt;module_name&gt; is the name of the `.py` file defining the subclass\n\n    Args:\n        path (Path, optional): Explicit path to the configuration file. If provided,\n                            overrides automatic inference.\n\n    Raises:\n        FileNotFoundError: If the resolved configuration file does not exist.\n    \"\"\"\n    if path is None:\n        module_file = Path(inspect.getfile(self.__class__))\n        module_stem = module_file.stem\n        resources_dir = module_file.parent / \"configurations\" / \\\n            os.environ.get(\"TEST_ENVIRONMENT\", EMPTY_STRING)\n        ini_file = resources_dir / f\"{module_stem}.ini\"\n        self._path = ini_file\n    else:\n        self._path = path\n\n    if not self._path.exists():\n        raise FileNotFoundError(\n            f\"configuration file not found: {self._path.resolve()}\")\n\n    self.log.debug(f\"using configuration from {self._path}\")\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.BddKeywords","title":"<code>BddKeywords</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for defining Behavior-Driven Development (BDD) keywords.</p> <p>This class provides a set of properties that represent the common BDD keywords such as <code>given</code>, <code>when</code>, <code>then</code>, <code>and_</code>, <code>with_</code>. Implementations might be of two types: step implementations (GenericSteps) or scenario implementations (AbstractTestsBase). In both cases, these properties must return an object that provides same step implementation, allowing a fluent-style coding::</p> <pre><code>given.something(...) \n    .with.another_thing(...) \n    .when.doing_this(...) \n    .and.doing_that(...) \n    ... and so on, and so on ...\n    ... eventually, expecting something ...\n    .then.the_other_thing(is like that and like...)\n</code></pre> <p>For more information on BDD, see the <code>Behavior-Driven Development &lt;https://en.wikipedia.org/wiki/Behavior-driven_development&gt;</code>_ Wikipedia article.</p> <p>This BDD implementation is an internal DSL, meaning it relies on the Python language, hence does not require a parser to read the scenarios from text files, nor additional tools to support IDE features for debugging, completion, refactoring, etc.</p> <p>Generic scenarios are available in BddScenarioTests, and basic PAM scenarios are available in FileScenarioTests.</p> <p>For more information on DSL, see the <code>Domain Specific Language &lt;https://en.wikipedia.org/wiki/Domain-specific_language&gt;</code>_ Wikipedia article.</p> <p>Parameters:</p> Name Type Description Default <code>TSteps</code> <code>TSteps</code> <p>BddKeywords): The actual steps implementation, or partial implementation.</p> required Source code in <code>qa-pytest-commons/src/qa_pytest_commons/bdd_keywords.py</code> <pre><code>class BddKeywords[TSteps:BddKeywords](ABC):\n    \"\"\"\n    Base class for defining Behavior-Driven Development (BDD) keywords.\n\n    This class provides a set of properties that represent the common BDD keywords\n    such as `given`, `when`, `then`, `and_`, `with_`. Implementations might be\n    of two types: step implementations (GenericSteps) or scenario implementations\n    (AbstractTestsBase). In both cases, these properties must return an object\n    that provides same step implementation, allowing a fluent-style coding::\n\n        given.something(...) \\\n\n            .with.another_thing(...) \\\n\n            .when.doing_this(...) \\\n\n            .and.doing_that(...) \\\n\n            ... and so on, and so on ...\n            ... eventually, expecting something ...\n            .then.the_other_thing(is like that and like...)\n\n    For more information on BDD, see the `Behavior-Driven Development\n    &lt;https://en.wikipedia.org/wiki/Behavior-driven_development&gt;`_ Wikipedia article.\n\n    This BDD implementation is an internal DSL, meaning it relies on the Python\n    language, hence does not require a parser to read the scenarios from text\n    files, nor additional tools to support IDE features for debugging, completion,\n    refactoring, etc.\n\n    Generic scenarios are available in BddScenarioTests, and basic PAM scenarios\n    are available in FileScenarioTests.\n\n    For more information on DSL, see the `Domain Specific Language\n    &lt;https://en.wikipedia.org/wiki/Domain-specific_language&gt;`_ Wikipedia article.\n\n\n    Args:\n        TSteps (TSteps:BddKeywords): The actual steps implementation, or partial implementation.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def given(self) -&gt; TSteps:\n        \"\"\"\n        Use to start definition of given stage.\n\n        The given stage is the start-up point of a test.\n\n        This might be a network connection, a file, a database, anything that\n        is required for executing any further operations and verifications::\n\n            given.a_connection(...connection details...)\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def when(self) -&gt; TSteps:\n        \"\"\"\n        Use to start definition of operations stage.\n\n        The operations stage is the part that triggers some behavior on the SUT.\n\n        This might be sending a command via a network connection, writing\n        something to a file, or anything that will cause the SUT to output\n        something verifiable::\n\n            when.doing_something(...parameters...)\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def then(self) -&gt; TSteps:\n        \"\"\"\n        Use to start definition of verifications stage.\n\n        The verifications stage is the part that samples actual output of the\n        SUT and compares it against a predefined condition (a.k.a. rule).\n\n        This might be sampling a file, a network response, or anything that\n        can be asserted upon. For example, this might be a network response\n        containing information about some file, like its size, which we might\n        expected to be greater than 0 and lesser than something else::\n\n            then.the_file(...rule to assert upon...)\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def and_(self) -&gt; TSteps:\n        \"\"\"\n        Use to continue definition of previous stage::\n\n            given.a_connection(...whatever...) \\\n\n            .and_.an_umbrella(...) \\\n\n            .and_.some_thing_else....\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def with_(self) -&gt; TSteps:\n        \"\"\"\n        Same as `and_`, sometimes it just sounds better::\n\n            given.a_connection(...whatever...) \\\n\n            .with_.authentication(...method details...)\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.BddKeywords.and_","title":"<code>and_</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Use to continue definition of previous stage::</p> <pre><code>given.a_connection(...whatever...) \n.and_.an_umbrella(...) \n.and_.some_thing_else....\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.BddKeywords.given","title":"<code>given</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Use to start definition of given stage.</p> <p>The given stage is the start-up point of a test.</p> <p>This might be a network connection, a file, a database, anything that is required for executing any further operations and verifications::</p> <pre><code>given.a_connection(...connection details...)\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.BddKeywords.then","title":"<code>then</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Use to start definition of verifications stage.</p> <p>The verifications stage is the part that samples actual output of the SUT and compares it against a predefined condition (a.k.a. rule).</p> <p>This might be sampling a file, a network response, or anything that can be asserted upon. For example, this might be a network response containing information about some file, like its size, which we might expected to be greater than 0 and lesser than something else::</p> <pre><code>then.the_file(...rule to assert upon...)\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.BddKeywords.when","title":"<code>when</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Use to start definition of operations stage.</p> <p>The operations stage is the part that triggers some behavior on the SUT.</p> <p>This might be sending a command via a network connection, writing something to a file, or anything that will cause the SUT to output something verifiable::</p> <pre><code>when.doing_something(...parameters...)\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.BddKeywords.with_","title":"<code>with_</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Same as <code>and_</code>, sometimes it just sounds better::</p> <pre><code>given.a_connection(...whatever...) \n.with_.authentication(...method details...)\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.Configuration","title":"<code>Configuration</code>","text":"<p>Just to allow for empty configurations</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/base_configuration.py</code> <pre><code>class Configuration():\n    \"\"\"Just to allow for empty configurations\"\"\"\n    pass\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps","title":"<code>GenericSteps</code>","text":"<p>               Bases: <code>BddKeywords['GenericSteps']</code>, <code>LoggerMixin</code>, <code>ImmutableMixin</code></p> <p>Generic steps beyond the BDD-keywords and diagnostics methods, most important: - retrying, for attempting a step that sporadically fails - eventually_assert_that, for asserting on sporadically failing operations</p> <p>IMPORTANT: if parallel testing will be required, and supported by the SUT, then internal state must be either thread-safe, or protected by TLS vars.</p> <p>The state it holds is mutated by steps. In a scenario there might be an operation o1 reading some info to be used by o2, followed by o1 later on, effectively rewriting previous value.</p> <p>Subtypes, such as PamSteps, may provide real system steps, relying on these ones. As such, these types might choose to redefine the _retry_policy herein::</p> <pre><code>                    +---------------+\n                    |  BddKeyWords  |\n                    +---------------+\n                                    ^\n                                    |\n                                implements\n                                    |\n+-------------------+               +--------------+\n| AbstractTestsBase |---contains---&gt;| GenericSteps |\n+-------------------+               +--------------+\n</code></pre> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>class GenericSteps[TConfiguration: BaseConfiguration](\n        BddKeywords['GenericSteps'],\n        LoggerMixin,\n        ImmutableMixin):\n    \"\"\"\n    Generic steps beyond the BDD-keywords and diagnostics methods, most important:\n    - retrying, for attempting a step that sporadically fails\n    - eventually_assert_that, for asserting on sporadically failing operations\n\n    IMPORTANT: if parallel testing will be required, and supported by the SUT,\n    then internal state must be either thread-safe, or protected by TLS vars.\n\n    The state it holds is mutated by steps. In a scenario there might be an\n    operation o1 reading some info to be used by o2, followed by o1 later on,\n    effectively rewriting previous value.\n\n    Subtypes, such as PamSteps, may provide real system steps, relying on these\n    ones. As such, these types might choose to redefine the _retry_policy herein::\n\n                            +---------------+\n                            |  BddKeyWords  |\n                            +---------------+\n                                            ^\n                                            |\n                                        implements\n                                            |\n        +-------------------+               +--------------+\n        | AbstractTestsBase |---contains---&gt;| GenericSteps |\n        +-------------------+               +--------------+\n\n    \"\"\"\n\n    _retrying: Retrying\n    _configuration: TConfiguration\n\n    def __init__(self, configuration: TConfiguration):\n        self._configuration = configuration\n        # NOTE: waits 1 sec after 1st failure, 2, 4, and 8 secs on subsequent;\n        # see BddScenarioTests#should_retry\n        self._retrying = Retrying(\n            stop=stop_after_attempt(4),\n            wait=wait_exponential(min=1, max=10),\n            retry=retry_if_exception_type(Exception),\n            before_sleep=before_sleep_log(self.log, logging.DEBUG)\n        )\n\n    @final\n    @property\n    def configured(self) -&gt; TConfiguration:\n        return self._configuration\n\n    @final\n    @property\n    def retry_policy(self) -&gt; Retrying:\n        return self._retrying\n\n    @final\n    @property\n    @override\n    def given(self) -&gt; Self:\n        Context.set(lambda m: f\"Given {m}\")\n        return self\n\n    @final\n    @property\n    @override\n    def when(self) -&gt; Self:\n        Context.set(lambda m: f\"When {m}\")\n        return self\n\n    @final\n    @property\n    @override\n    def then(self) -&gt; Self:\n        Context.set(lambda m: f\"Then {m}\")\n        return self\n\n    @final\n    @property\n    @override\n    def and_(self) -&gt; Self:\n        Context.set(lambda m: f\"And {m}\")\n        return self\n\n    @final\n    @property\n    @override\n    def with_(self) -&gt; Self:\n        Context.set(lambda m: f\"With {m}\")\n        return self\n\n    @final\n    @property\n    @Context.traced\n    def nothing(self) -&gt; Self:\n        \"\"\"\n        Intended to support self-testing which does not rely on outer world\n        system::\n\n            given.nothing \\\n\n            .when.... doing your stuff here...\n\n        Returns:\n            Self: these steps\n        \"\"\"\n        return self\n\n    # DELETEME\n    # # @Context.traced -- nothing to trace here...\n    # def configuration(self, configuration: TConfiguration) -&gt; Self:\n    #     \"\"\"\n    #     Sets the configuration to use.\n\n    #     Args:\n    #         configuration (TConfiguration): the configuration\n\n    #     Returns:\n    #         Self: these steps\n    #     \"\"\"\n    #     self._configuration = configuration\n    #     return self\n\n    def set[T:Valid](self, field_name: str, field_value: T) -&gt; T:\n        \"\"\"\n        Sets field to specified value\n\n        Args:\n            field_name (str): name of field; the field should be defined as annotation\n            field_value (T:Valid): value of field that can be validated\n\n        Raises:\n            AttributeError: if the field is not defined\n            TypeError: if the object does not support the Valid protocol\n            InvalidValueException: if the object is invalid\n\n        Returns:\n            _type_: the value of set field\n        \"\"\"\n        if field_name not in self.__class__.__annotations__:\n            raise AttributeError(\n                f\"{field_name} is not a valid attribute of \"\n                f\"{self.__class__.__name__}.\")\n\n        setattr(self, field_name, valid(field_value))\n        return field_value\n\n    @final\n    def step(self, *args: Any) -&gt; Self:\n        \"\"\"\n        Casts anything to a step.\n\n        Returns:\n            Self: these steps\n        \"\"\"\n        return self\n\n    @final\n    def tracing(self, value: Any) -&gt; Self:\n        \"\"\"\n        Logs value at DEBUG level using the logger of this steps class.\n\n        Use to trace something as a step, usually in a lambda expression::\n\n            when.retrying(lambda: self.trace(valid(...call some API...))) \\\n\n                .and_....this can be further chained with other steps....\n\n        Args:\n            value (Any): _description_\n\n        Returns:\n            Self: these steps\n        \"\"\"\n        self.log.debug(f\"=== {value}\")\n        return self\n\n    @final\n    @Context.traced\n    def waiting(self, duration: timedelta = timedelta(seconds=0)) -&gt; Self:\n        \"\"\"\n        Blocks current thread for specified duration.\n\n        Consider using retrying or eventually_assert_that instead of this.\n\n        Args:\n            duration (timedelta, optional): Defaults to timedelta(seconds=0).\n\n        Returns:\n            Self: these steps\n        \"\"\"\n        sleep_for(duration)\n        return self\n\n    @final\n    @Context.traced\n    def failing(self, exception: Exception) -&gt; Self:\n        \"\"\"\n        Intended to support self-testing of retrying and eventually_assert_that\n        steps below.\n\n        Args:\n            exception (Exception): some exception\n\n        Raises:\n            exception: that exception\n\n        Returns:\n            Self: these steps\n        \"\"\"\n        raise exception\n\n    @final\n    @Context.traced\n    def repeating(self, range: range, step: Callable[[int], Self]) -&gt; Self:\n        \"\"\"\n        Intended for stress testing -- repeats specified steps.\n\n        Args:\n            range (range): a range\n            step (Callable[[int], Self]): lambda of step to repeat with counter\n\n        Returns:\n            Self: these steps\n        \"\"\"\n        seq(range).for_each(step)  # type: ignore\n        return self\n\n    # TODO parallel_repeating\n\n    @final\n    @Context.traced\n    def safely(self, step: Callable[[], Self]) -&gt; Self:\n        \"\"\"\n        Executes specified step, swallowing its exceptions.\n\n        Args:\n            step (Callable[[], Self]): a lambda expression returning Self\n\n        Returns:\n            Self: these steps\n        \"\"\"\n        return safely(lambda: step()).value_or(self)\n\n    # TODO implement a raises decorator to mark method as raising some exception\n    # at run-time the decorator shall check if raised exception matches the declared list.\n    # This one would be:\n    # @raises(tenacity.RetryError)\n    @final\n    # @Context.traced\n    def retrying(self, step: Callable[[], Self]) -&gt; Self:\n        '''\n        Retries specified step according to _retry_policy.\n\n        The default _retry_policy can be overridden by sub-types.\n\n        Args:\n            step (Callable[[], Self]): a lambda expression returning Self\n\n        Returns:\n            Self: these steps\n        '''\n        return self._retrying(step)\n\n    @final\n    # @Context.traced\n    def eventually_assert_that[T](\n            self, supplier: Supplier[T],\n            by_rule: Matcher[T]) -&gt; Self:\n        '''\n        Repeatedly applies specified rule on specified supplier, according to\n        _retry_policy.\n\n        The default _retry_policy can be overridden by sub-types.\n\n        Args:\n            supplier (Callable[[], T]): a lambda expression returning T\n            by_rule (Matcher[T]): a Hamcrest Matcher on T; basically, this is \\\n            just a predicate with a description, read more on \\\n                https://github.com/hamcrest/PyHamcrest\n\n        Returns:\n            Self: these steps\n        '''\n        return self._retrying(lambda: self._assert_that(supplier(), by_rule))\n\n    @final\n    @Context.traced\n    def it_works(self, matcher: Matcher[bool]) -&gt; Self:\n        \"\"\"\n        Intended to support self-testing of reports.\n\n        Args:\n            matcher (Matcher[bool]): is_(True) will trigger a green report, \\\n            while is_(False) will trigger a red report\n\n        Returns:\n            Self: these steps\n        \"\"\"\n        assert_that(True, matcher)\n        return self\n\n    @final\n    # NOTE @Context.traced here is redundant\n    def _assert_that[T](self, value: T, by_rule: Matcher[T]) -&gt; Self:\n        \"\"\"\n        Adapts PyHamcrest's assert_that to the BDD world by returning Self.\n\n        Args:\n            value (T): the value to assert upon\n            by_rule (Matcher[T]): the Hamcrest matcher to apply\n\n        Returns:\n            Self: these steps\n        \"\"\"\n        assert_that(value, by_rule)\n        return self\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.and_","title":"<code>and_</code>  <code>property</code>","text":""},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.configured","title":"<code>configured</code>  <code>property</code>","text":""},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.given","title":"<code>given</code>  <code>property</code>","text":""},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.nothing","title":"<code>nothing</code>  <code>property</code>","text":"<p>Intended to support self-testing which does not rely on outer world system::</p> <pre><code>given.nothing \n.when.... doing your stuff here...\n</code></pre> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>these steps</p>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.retry_policy","title":"<code>retry_policy</code>  <code>property</code>","text":""},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.then","title":"<code>then</code>  <code>property</code>","text":""},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.when","title":"<code>when</code>  <code>property</code>","text":""},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.with_","title":"<code>with_</code>  <code>property</code>","text":""},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.__init__","title":"<code>__init__(configuration)</code>","text":"Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>def __init__(self, configuration: TConfiguration):\n    self._configuration = configuration\n    # NOTE: waits 1 sec after 1st failure, 2, 4, and 8 secs on subsequent;\n    # see BddScenarioTests#should_retry\n    self._retrying = Retrying(\n        stop=stop_after_attempt(4),\n        wait=wait_exponential(min=1, max=10),\n        retry=retry_if_exception_type(Exception),\n        before_sleep=before_sleep_log(self.log, logging.DEBUG)\n    )\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.eventually_assert_that","title":"<code>eventually_assert_that(supplier, by_rule)</code>","text":"<p>Repeatedly applies specified rule on specified supplier, according to _retry_policy.</p> <p>The default _retry_policy can be overridden by sub-types.</p> <p>Parameters:</p> Name Type Description Default <code>supplier</code> <code>Callable[[], T]</code> <p>a lambda expression returning T</p> required <code>by_rule</code> <code>Matcher[T]</code> <p>a Hamcrest Matcher on T; basically, this is             just a predicate with a description, read more on                 https://github.com/hamcrest/PyHamcrest</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>these steps</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>@final\n# @Context.traced\ndef eventually_assert_that[T](\n        self, supplier: Supplier[T],\n        by_rule: Matcher[T]) -&gt; Self:\n    '''\n    Repeatedly applies specified rule on specified supplier, according to\n    _retry_policy.\n\n    The default _retry_policy can be overridden by sub-types.\n\n    Args:\n        supplier (Callable[[], T]): a lambda expression returning T\n        by_rule (Matcher[T]): a Hamcrest Matcher on T; basically, this is \\\n        just a predicate with a description, read more on \\\n            https://github.com/hamcrest/PyHamcrest\n\n    Returns:\n        Self: these steps\n    '''\n    return self._retrying(lambda: self._assert_that(supplier(), by_rule))\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.failing","title":"<code>failing(exception)</code>","text":"<p>Intended to support self-testing of retrying and eventually_assert_that steps below.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>Exception</code> <p>some exception</p> required <p>Raises:</p> Type Description <code>exception</code> <p>that exception</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>these steps</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>@final\n@Context.traced\ndef failing(self, exception: Exception) -&gt; Self:\n    \"\"\"\n    Intended to support self-testing of retrying and eventually_assert_that\n    steps below.\n\n    Args:\n        exception (Exception): some exception\n\n    Raises:\n        exception: that exception\n\n    Returns:\n        Self: these steps\n    \"\"\"\n    raise exception\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.it_works","title":"<code>it_works(matcher)</code>","text":"<p>Intended to support self-testing of reports.</p> <p>Parameters:</p> Name Type Description Default <code>matcher</code> <code>Matcher[bool]</code> <p>is_(True) will trigger a green report,             while is_(False) will trigger a red report</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>these steps</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>@final\n@Context.traced\ndef it_works(self, matcher: Matcher[bool]) -&gt; Self:\n    \"\"\"\n    Intended to support self-testing of reports.\n\n    Args:\n        matcher (Matcher[bool]): is_(True) will trigger a green report, \\\n        while is_(False) will trigger a red report\n\n    Returns:\n        Self: these steps\n    \"\"\"\n    assert_that(True, matcher)\n    return self\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.repeating","title":"<code>repeating(range, step)</code>","text":"<p>Intended for stress testing -- repeats specified steps.</p> <p>Parameters:</p> Name Type Description Default <code>range</code> <code>range</code> <p>a range</p> required <code>step</code> <code>Callable[[int], Self]</code> <p>lambda of step to repeat with counter</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>these steps</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>@final\n@Context.traced\ndef repeating(self, range: range, step: Callable[[int], Self]) -&gt; Self:\n    \"\"\"\n    Intended for stress testing -- repeats specified steps.\n\n    Args:\n        range (range): a range\n        step (Callable[[int], Self]): lambda of step to repeat with counter\n\n    Returns:\n        Self: these steps\n    \"\"\"\n    seq(range).for_each(step)  # type: ignore\n    return self\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.retrying","title":"<code>retrying(step)</code>","text":"<p>Retries specified step according to _retry_policy.</p> <p>The default _retry_policy can be overridden by sub-types.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>Callable[[], Self]</code> <p>a lambda expression returning Self</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>these steps</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>@final\n# @Context.traced\ndef retrying(self, step: Callable[[], Self]) -&gt; Self:\n    '''\n    Retries specified step according to _retry_policy.\n\n    The default _retry_policy can be overridden by sub-types.\n\n    Args:\n        step (Callable[[], Self]): a lambda expression returning Self\n\n    Returns:\n        Self: these steps\n    '''\n    return self._retrying(step)\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.safely","title":"<code>safely(step)</code>","text":"<p>Executes specified step, swallowing its exceptions.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>Callable[[], Self]</code> <p>a lambda expression returning Self</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>these steps</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>@final\n@Context.traced\ndef safely(self, step: Callable[[], Self]) -&gt; Self:\n    \"\"\"\n    Executes specified step, swallowing its exceptions.\n\n    Args:\n        step (Callable[[], Self]): a lambda expression returning Self\n\n    Returns:\n        Self: these steps\n    \"\"\"\n    return safely(lambda: step()).value_or(self)\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.set","title":"<code>set(field_name, field_value)</code>","text":"<p>Sets field to specified value</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>name of field; the field should be defined as annotation</p> required <code>field_value</code> <code>T</code> <p>Valid): value of field that can be validated</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>if the field is not defined</p> <code>TypeError</code> <p>if the object does not support the Valid protocol</p> <code>InvalidValueException</code> <p>if the object is invalid</p> <p>Returns:</p> Name Type Description <code>_type_</code> <code>T</code> <p>the value of set field</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>def set[T:Valid](self, field_name: str, field_value: T) -&gt; T:\n    \"\"\"\n    Sets field to specified value\n\n    Args:\n        field_name (str): name of field; the field should be defined as annotation\n        field_value (T:Valid): value of field that can be validated\n\n    Raises:\n        AttributeError: if the field is not defined\n        TypeError: if the object does not support the Valid protocol\n        InvalidValueException: if the object is invalid\n\n    Returns:\n        _type_: the value of set field\n    \"\"\"\n    if field_name not in self.__class__.__annotations__:\n        raise AttributeError(\n            f\"{field_name} is not a valid attribute of \"\n            f\"{self.__class__.__name__}.\")\n\n    setattr(self, field_name, valid(field_value))\n    return field_value\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.step","title":"<code>step(*args)</code>","text":"<p>Casts anything to a step.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>these steps</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>@final\ndef step(self, *args: Any) -&gt; Self:\n    \"\"\"\n    Casts anything to a step.\n\n    Returns:\n        Self: these steps\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.tracing","title":"<code>tracing(value)</code>","text":"<p>Logs value at DEBUG level using the logger of this steps class.</p> <p>Use to trace something as a step, usually in a lambda expression::</p> <pre><code>when.retrying(lambda: self.trace(valid(...call some API...))) \n    .and_....this can be further chained with other steps....\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>these steps</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>@final\ndef tracing(self, value: Any) -&gt; Self:\n    \"\"\"\n    Logs value at DEBUG level using the logger of this steps class.\n\n    Use to trace something as a step, usually in a lambda expression::\n\n        when.retrying(lambda: self.trace(valid(...call some API...))) \\\n\n            .and_....this can be further chained with other steps....\n\n    Args:\n        value (Any): _description_\n\n    Returns:\n        Self: these steps\n    \"\"\"\n    self.log.debug(f\"=== {value}\")\n    return self\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.waiting","title":"<code>waiting(duration=timedelta(seconds=0))</code>","text":"<p>Blocks current thread for specified duration.</p> <p>Consider using retrying or eventually_assert_that instead of this.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>timedelta</code> <p>Defaults to timedelta(seconds=0).</p> <code>timedelta(seconds=0)</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>these steps</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>@final\n@Context.traced\ndef waiting(self, duration: timedelta = timedelta(seconds=0)) -&gt; Self:\n    \"\"\"\n    Blocks current thread for specified duration.\n\n    Consider using retrying or eventually_assert_that instead of this.\n\n    Args:\n        duration (timedelta, optional): Defaults to timedelta(seconds=0).\n\n    Returns:\n        Self: these steps\n    \"\"\"\n    sleep_for(duration)\n    return self\n</code></pre>"},{"location":"api/qa-pytest-examples/","title":"Examples","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples","title":"<code>qa_pytest_examples</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.__all__","title":"<code>__all__ = ['CombinedConfiguration', 'CombinedSteps', 'Credentials', 'RabbitMqSelfConfiguration', 'SwaggerPetstoreConfiguration', 'SwaggerPetstoreCredentials', 'SwaggerPetstorePet', 'SwaggerPetstoreSteps', 'TerminalXConfiguration', 'TerminalXCredentials', 'TerminalXSteps', 'TerminalXUser']</code>  <code>module-attribute</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.CombinedConfiguration","title":"<code>CombinedConfiguration</code>","text":"<p>               Bases: <code>SwaggerPetstoreConfiguration</code>, <code>TerminalXConfiguration</code></p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/combined_configuration.py</code> <pre><code>class CombinedConfiguration(\n        SwaggerPetstoreConfiguration, TerminalXConfiguration):\n    pass\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.CombinedSteps","title":"<code>CombinedSteps</code>","text":"<p>               Bases: <code>SwaggerPetstoreSteps[CombinedConfiguration]</code>, <code>TerminalXSteps[CombinedConfiguration]</code></p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/combined_steps.py</code> <pre><code>class CombinedSteps(\n        SwaggerPetstoreSteps[CombinedConfiguration],\n        TerminalXSteps[CombinedConfiguration]):\n    pass\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.Credentials","title":"<code>Credentials</code>  <code>dataclass</code>","text":"Source code in <code>qa-pytest-examples/src/qa_pytest_examples/model/credentials.py</code> <pre><code>@dataclass(frozen=True)\nclass Credentials:\n    username: str\n    password: str\n\n    @classmethod\n    def from_(cls, colon_separated: str):\n        return cls(*colon_separated.split(\":\"))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.Credentials.password","title":"<code>password</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.Credentials.username","title":"<code>username</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.Credentials.__init__","title":"<code>__init__(username, password)</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.Credentials.from_","title":"<code>from_(colon_separated)</code>  <code>classmethod</code>","text":"Source code in <code>qa-pytest-examples/src/qa_pytest_examples/model/credentials.py</code> <pre><code>@classmethod\ndef from_(cls, colon_separated: str):\n    return cls(*colon_separated.split(\":\"))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.RabbitMqSelfConfiguration","title":"<code>RabbitMqSelfConfiguration</code>","text":"<p>               Bases: <code>RabbitMqConfiguration</code></p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/rabbitmq_self_configuration.py</code> <pre><code>class RabbitMqSelfConfiguration(RabbitMqConfiguration):\n    pass\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstoreConfiguration","title":"<code>SwaggerPetstoreConfiguration</code>","text":"<p>               Bases: <code>RestConfiguration</code></p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/swagger_petstore_configuration.py</code> <pre><code>class SwaggerPetstoreConfiguration(RestConfiguration):\n    pass\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstoreCredentials","title":"<code>SwaggerPetstoreCredentials</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Credentials</code></p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/model/swagger_petstore_credentials.py</code> <pre><code>@dataclass(frozen=True)\nclass SwaggerPetstoreCredentials(Credentials):\n    pass\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstoreCredentials.__init__","title":"<code>__init__(username, password)</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstorePet","title":"<code>SwaggerPetstorePet</code>  <code>dataclass</code>","text":"Source code in <code>qa-pytest-examples/src/qa_pytest_examples/model/swagger_petstore_pet.py</code> <pre><code>@dataclass(eq=True, frozen=True)\n@to_string()\nclass SwaggerPetstorePet:\n    name: str\n    status: str\n\n    @staticmethod\n    def random() -&gt; SwaggerPetstorePet:\n        return SwaggerPetstorePet(name=str(uuid4()), status=\"available\")\n\n    @staticmethod\n    def from_(response: Response) -&gt; Iterator[SwaggerPetstorePet]:\n        return (\n            SwaggerPetstorePet(name=pet[\"name\"], status=pet[\"status\"])\n            for pet in response.json()\n            if \"name\" in pet and \"status\" in pet\n        )\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstorePet.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstorePet.status","title":"<code>status</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstorePet.__init__","title":"<code>__init__(name, status)</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstorePet.from_","title":"<code>from_(response)</code>  <code>staticmethod</code>","text":"Source code in <code>qa-pytest-examples/src/qa_pytest_examples/model/swagger_petstore_pet.py</code> <pre><code>@staticmethod\ndef from_(response: Response) -&gt; Iterator[SwaggerPetstorePet]:\n    return (\n        SwaggerPetstorePet(name=pet[\"name\"], status=pet[\"status\"])\n        for pet in response.json()\n        if \"name\" in pet and \"status\" in pet\n    )\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstorePet.random","title":"<code>random()</code>  <code>staticmethod</code>","text":"Source code in <code>qa-pytest-examples/src/qa_pytest_examples/model/swagger_petstore_pet.py</code> <pre><code>@staticmethod\ndef random() -&gt; SwaggerPetstorePet:\n    return SwaggerPetstorePet(name=str(uuid4()), status=\"available\")\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstoreSteps","title":"<code>SwaggerPetstoreSteps</code>","text":"<p>               Bases: <code>RestSteps[TConfiguration]</code></p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/swagger_petstore_steps.py</code> <pre><code>class SwaggerPetstoreSteps[TConfiguration: SwaggerPetstoreConfiguration](\n        RestSteps[TConfiguration]):\n\n    @Context.traced\n    def swagger_petstore(self, client: requests.Session):\n        self._rest_session = client\n        return self\n\n    @Context.traced\n    def adding(self, pet: SwaggerPetstorePet) -&gt; Self:\n        return self.invoking(Request(\n            method=HttpMethod.POST,\n            url=self.configured.resource_uri(path=\"pet\"),\n            json=asdict(pet)\n        ))\n\n    @Context.traced\n    def the_available_pets(self, by_rule: Matcher\n                           [Iterator[SwaggerPetstorePet]]) -&gt; Self:\n        return self.the_invocation(Request(\n            method=HttpMethod.GET,\n            url=self.configured.resource_uri(path=\"pet/findByStatus\"),\n            params={\"status\": \"available\"}),\n            adapted_object(\n                lambda response: SwaggerPetstorePet.from_(response),\n                by_rule))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstoreSteps.adding","title":"<code>adding(pet)</code>","text":"Source code in <code>qa-pytest-examples/src/qa_pytest_examples/swagger_petstore_steps.py</code> <pre><code>@Context.traced\ndef adding(self, pet: SwaggerPetstorePet) -&gt; Self:\n    return self.invoking(Request(\n        method=HttpMethod.POST,\n        url=self.configured.resource_uri(path=\"pet\"),\n        json=asdict(pet)\n    ))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstoreSteps.swagger_petstore","title":"<code>swagger_petstore(client)</code>","text":"Source code in <code>qa-pytest-examples/src/qa_pytest_examples/swagger_petstore_steps.py</code> <pre><code>@Context.traced\ndef swagger_petstore(self, client: requests.Session):\n    self._rest_session = client\n    return self\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstoreSteps.the_available_pets","title":"<code>the_available_pets(by_rule)</code>","text":"Source code in <code>qa-pytest-examples/src/qa_pytest_examples/swagger_petstore_steps.py</code> <pre><code>@Context.traced\ndef the_available_pets(self, by_rule: Matcher\n                       [Iterator[SwaggerPetstorePet]]) -&gt; Self:\n    return self.the_invocation(Request(\n        method=HttpMethod.GET,\n        url=self.configured.resource_uri(path=\"pet/findByStatus\"),\n        params={\"status\": \"available\"}),\n        adapted_object(\n            lambda response: SwaggerPetstorePet.from_(response),\n            by_rule))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXConfiguration","title":"<code>TerminalXConfiguration</code>","text":"<p>               Bases: <code>SeleniumConfiguration</code></p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/terminalx_configuration.py</code> <pre><code>class TerminalXConfiguration(SeleniumConfiguration):\n    @cached_property\n    @final\n    def users(self) -&gt; List[TerminalXUser]:\n        users_section = self.parser[\"users\"]\n        return [\n            TerminalXUser(TerminalXCredentials.from_(\n                username_password), name=key)\n            for key, username_password in users_section.items()\n        ]\n\n    @final\n    @property\n    def random_user(self) -&gt; TerminalXUser:\n        return random.choice(self.users)\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXConfiguration.random_user","title":"<code>random_user</code>  <code>property</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXConfiguration.users","title":"<code>users</code>  <code>cached</code> <code>property</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXCredentials","title":"<code>TerminalXCredentials</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Credentials</code></p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/model/terminalx_credentials.py</code> <pre><code>@dataclass(frozen=True)\nclass TerminalXCredentials(Credentials):\n    pass\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXCredentials.__init__","title":"<code>__init__(username, password)</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXSteps","title":"<code>TerminalXSteps</code>","text":"<p>               Bases: <code>SeleniumSteps[TConfiguration]</code></p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/terminalx_steps.py</code> <pre><code>class TerminalXSteps[TConfiguration: TerminalXConfiguration](\n        SeleniumSteps[TConfiguration]):\n    @Context.traced\n    def terminalx(self, driver: WebDriver) -&gt; Self:\n        self._web_driver = driver\n        self._web_driver.get(self.configured.landing_page)\n        return self\n\n    def clicking_login(self) -&gt; Self:\n        return self.clicking(By.xpath(\"//div[contains(text(), '\u05d4\u05ea\u05d7\u05d1\u05e8\u05d5\u05ea')]\"))\n\n    @Context.traced\n    def clicking_search(self) -&gt; Self:\n        return self.clicking(\n            By.xpath(\"//button[@data-test-id='qa-header-search-button']\"))\n\n    def submitting_login(self) -&gt; Self:\n        return self.clicking(By.xpath(\"//button[contains(text(), '\u05d4\u05ea\u05d7\u05d1\u05e8\u05d5\u05ea')]\"))\n\n    @Context.traced\n    def logging_in_with(self, credentials: TerminalXCredentials) -&gt; Self:\n        return (self.clicking_login()\n                .and_.typing(\n                    By.id(\"qa-login-email-input\"), credentials.username)\n                .and_.typing(\n                    By.id(\"qa-login-password-input\"), credentials.password)\n                .and_.submitting_login())\n\n    @Context.traced\n    def the_user_logged_in(self, by_rule: Matcher[str]) -&gt; Self:\n        return self.the_element(\n            By.xpath(\n                \"//button[@data-test-id='qa-header-profile-button']/span[2]\"),\n            adapted_object(lambda element: element.text, by_rule))\n\n    @Context.traced\n    def searching_for(self, text: str) -&gt; Self:\n        return self.typing(\n            By.xpath(\"//input[@data-test-id='qa-search-box-input']\"),\n            text)\n\n    @Context.traced\n    def the_search_hints(self, by_rule: Matcher[Iterator[str]]) -&gt; Self:\n        return self.the_elements(\n            By.xpath(\"(//ul[@class='list_3tWy'])[2]/li/div/div/a\"),\n            adapted_iterator(lambda element: element.text, by_rule))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXSteps.clicking_login","title":"<code>clicking_login()</code>","text":"Source code in <code>qa-pytest-examples/src/qa_pytest_examples/terminalx_steps.py</code> <pre><code>def clicking_login(self) -&gt; Self:\n    return self.clicking(By.xpath(\"//div[contains(text(), '\u05d4\u05ea\u05d7\u05d1\u05e8\u05d5\u05ea')]\"))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXSteps.clicking_search","title":"<code>clicking_search()</code>","text":"Source code in <code>qa-pytest-examples/src/qa_pytest_examples/terminalx_steps.py</code> <pre><code>@Context.traced\ndef clicking_search(self) -&gt; Self:\n    return self.clicking(\n        By.xpath(\"//button[@data-test-id='qa-header-search-button']\"))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXSteps.logging_in_with","title":"<code>logging_in_with(credentials)</code>","text":"Source code in <code>qa-pytest-examples/src/qa_pytest_examples/terminalx_steps.py</code> <pre><code>@Context.traced\ndef logging_in_with(self, credentials: TerminalXCredentials) -&gt; Self:\n    return (self.clicking_login()\n            .and_.typing(\n                By.id(\"qa-login-email-input\"), credentials.username)\n            .and_.typing(\n                By.id(\"qa-login-password-input\"), credentials.password)\n            .and_.submitting_login())\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXSteps.searching_for","title":"<code>searching_for(text)</code>","text":"Source code in <code>qa-pytest-examples/src/qa_pytest_examples/terminalx_steps.py</code> <pre><code>@Context.traced\ndef searching_for(self, text: str) -&gt; Self:\n    return self.typing(\n        By.xpath(\"//input[@data-test-id='qa-search-box-input']\"),\n        text)\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXSteps.submitting_login","title":"<code>submitting_login()</code>","text":"Source code in <code>qa-pytest-examples/src/qa_pytest_examples/terminalx_steps.py</code> <pre><code>def submitting_login(self) -&gt; Self:\n    return self.clicking(By.xpath(\"//button[contains(text(), '\u05d4\u05ea\u05d7\u05d1\u05e8\u05d5\u05ea')]\"))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXSteps.terminalx","title":"<code>terminalx(driver)</code>","text":"Source code in <code>qa-pytest-examples/src/qa_pytest_examples/terminalx_steps.py</code> <pre><code>@Context.traced\ndef terminalx(self, driver: WebDriver) -&gt; Self:\n    self._web_driver = driver\n    self._web_driver.get(self.configured.landing_page)\n    return self\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXSteps.the_search_hints","title":"<code>the_search_hints(by_rule)</code>","text":"Source code in <code>qa-pytest-examples/src/qa_pytest_examples/terminalx_steps.py</code> <pre><code>@Context.traced\ndef the_search_hints(self, by_rule: Matcher[Iterator[str]]) -&gt; Self:\n    return self.the_elements(\n        By.xpath(\"(//ul[@class='list_3tWy'])[2]/li/div/div/a\"),\n        adapted_iterator(lambda element: element.text, by_rule))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXSteps.the_user_logged_in","title":"<code>the_user_logged_in(by_rule)</code>","text":"Source code in <code>qa-pytest-examples/src/qa_pytest_examples/terminalx_steps.py</code> <pre><code>@Context.traced\ndef the_user_logged_in(self, by_rule: Matcher[str]) -&gt; Self:\n    return self.the_element(\n        By.xpath(\n            \"//button[@data-test-id='qa-header-profile-button']/span[2]\"),\n        adapted_object(lambda element: element.text, by_rule))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXUser","title":"<code>TerminalXUser</code>  <code>dataclass</code>","text":"Source code in <code>qa-pytest-examples/src/qa_pytest_examples/model/terminalx_user.py</code> <pre><code>@dataclass(frozen=True)\nclass TerminalXUser:\n    credentials: TerminalXCredentials\n    name: str\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXUser.credentials","title":"<code>credentials</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXUser.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXUser.__init__","title":"<code>__init__(credentials, name)</code>","text":""},{"location":"api/qa-pytest-rabbitmq/","title":"RabbitMQ","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq","title":"<code>qa_pytest_rabbitmq</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.__all__","title":"<code>__all__ = ['Message', 'QueueHandler', 'RabbitMqConfiguration', 'RabbitMqSteps', 'RabbitMqTests']</code>  <code>module-attribute</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.__version__","title":"<code>__version__ = '0.0.11.dev7+g9b1fb9b.d20250619'</code>  <code>module-attribute</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.Message","title":"<code>Message</code>  <code>dataclass</code>","text":"Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/queue_handler.py</code> <pre><code>@to_string()\n@dataclass(frozen=True)\nclass Message[V]:\n    content: V\n    properties: BasicProperties = field(default_factory=BasicProperties)\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.Message.content","title":"<code>content</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.Message.properties","title":"<code>properties = field(default_factory=BasicProperties)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.Message.__init__","title":"<code>__init__(content, properties=BasicProperties())</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler","title":"<code>QueueHandler</code>  <code>dataclass</code>","text":"<p>               Bases: <code>LoggerMixin</code></p> Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/queue_handler.py</code> <pre><code>@to_string()\n@dataclass\n@final\nclass QueueHandler[K, V](LoggerMixin):\n    channel: Final[BlockingChannel]\n    queue_name: Final[str]\n    indexing_by: Final[Callable[[Message[V]], K]]\n    consuming_by: Final[Callable[[bytes], V]]\n    publishing_by: Final[Callable[[V], bytes]]\n\n    _received_messages: Final[dict[K, Message[V]]] = field(\n        default_factory=lambda: dict())\n    _command_queue: Final[queue.Queue[Callable[[], None]]] = field(\n        default_factory=lambda: queue.Queue())\n\n    _worker_thread: threading.Thread = field(init=False)\n    _shutdown_event: threading.Event = field(\n        default_factory=threading.Event, init=False)\n    _consumer_tag: str | None = field(default=None, init=False)\n    _lock: threading.RLock = field(default_factory=threading.RLock, init=False)\n\n    def __post_init__(self) -&gt; None:\n        self._worker_thread = threading.Thread(\n            target=self._worker_loop, name=\"rabbitmq-handler\", daemon=True)\n        self._worker_thread.start()\n\n    def __enter__(self) -&gt; \"QueueHandler[K, V]\":\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: TracebackType | None\n    ) -&gt; None:\n        self.close()\n\n    def _worker_loop(self) -&gt; None:\n        while not self._shutdown_event.is_set():\n            try:\n                self.channel.connection.process_data_events()\n                try:\n                    command = self._command_queue.get_nowait()\n                    command()\n                except queue.Empty:\n                    pass\n            except Exception as e:\n                self.log.error(f\"Unhandled error in worker thread: {e}\")\n\n    def _submit(self, fn: Callable[[], None]) -&gt; None:\n        self._command_queue.put(fn)\n\n    def consume(self) -&gt; str:\n        def _consume():\n            def on_message(ch: BlockingChannel, method: Any,\n                           props: BasicProperties, body: bytes) -&gt; None:\n                try:\n                    content = self.consuming_by(body)\n                    message = Message(content=content, properties=props)\n                    key = self.indexing_by(message)\n                    with self._lock:\n                        self._received_messages[key] = message\n                    ch.basic_ack(\n                        delivery_tag=require_not_none(\n                            method.delivery_tag))\n                    self.log.debug(f\"received {key}\")\n                except Exception as e:\n                    self.log.warning(f\"skipping message due to error: {e}\")\n                    ch.basic_reject(\n                        delivery_tag=require_not_none(\n                            method.delivery_tag),\n                        requeue=True)\n\n            self._consumer_tag = self.channel.basic_consume(\n                queue=self.queue_name, on_message_callback=on_message\n            )\n            self.log.debug(f\"consumer set up with tag {self._consumer_tag}\")\n\n        self._submit(_consume)\n        return \"pending-tag\"\n\n    def cancel(self) -&gt; str:\n        def _cancel():\n            if self._consumer_tag:\n                self.channel.connection.add_callback_threadsafe(\n                    self.channel.stop_consuming)\n                self._consumer_tag = None\n                self.log.debug(\"consumer cancelled\")\n        self._submit(_cancel)\n        return self._consumer_tag or \"\"\n\n    def publish(self, messages: Iterator[Message[V]]) -&gt; None:\n        def _publish():\n            for message in messages:\n                body = self.publishing_by(message.content)\n                self.channel.basic_publish(\n                    exchange=EMPTY_STRING,\n                    routing_key=self.queue_name,\n                    body=body,\n                    properties=message.properties\n                )\n                self.log.debug(f\"published {message}\")\n        self._submit(_publish)\n\n    def publish_values(self, values: Iterator[V]) -&gt; None:\n        self.publish((Message(content=value) for value in values))\n\n    def close(self) -&gt; None:\n        self.cancel()\n        self._shutdown_event.set()\n        self._worker_thread.join(timeout=5.0)\n\n    @property\n    def received_messages(self) -&gt; Mapping[K, Message[V]]:\n        with self._lock:\n            return dict(self._received_messages)\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.channel","title":"<code>channel</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.consuming_by","title":"<code>consuming_by</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.indexing_by","title":"<code>indexing_by</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.publishing_by","title":"<code>publishing_by</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.queue_name","title":"<code>queue_name</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.received_messages","title":"<code>received_messages</code>  <code>property</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.__enter__","title":"<code>__enter__()</code>","text":"Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/queue_handler.py</code> <pre><code>def __enter__(self) -&gt; \"QueueHandler[K, V]\":\n    return self\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.__exit__","title":"<code>__exit__(exc_type, exc_value, traceback)</code>","text":"Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/queue_handler.py</code> <pre><code>def __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: TracebackType | None\n) -&gt; None:\n    self.close()\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.__init__","title":"<code>__init__(channel, queue_name, indexing_by, consuming_by, publishing_by, _received_messages=lambda: dict()(), _command_queue=lambda: queue.Queue()())</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.__post_init__","title":"<code>__post_init__()</code>","text":"Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/queue_handler.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    self._worker_thread = threading.Thread(\n        target=self._worker_loop, name=\"rabbitmq-handler\", daemon=True)\n    self._worker_thread.start()\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.cancel","title":"<code>cancel()</code>","text":"Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/queue_handler.py</code> <pre><code>def cancel(self) -&gt; str:\n    def _cancel():\n        if self._consumer_tag:\n            self.channel.connection.add_callback_threadsafe(\n                self.channel.stop_consuming)\n            self._consumer_tag = None\n            self.log.debug(\"consumer cancelled\")\n    self._submit(_cancel)\n    return self._consumer_tag or \"\"\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.close","title":"<code>close()</code>","text":"Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/queue_handler.py</code> <pre><code>def close(self) -&gt; None:\n    self.cancel()\n    self._shutdown_event.set()\n    self._worker_thread.join(timeout=5.0)\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.consume","title":"<code>consume()</code>","text":"Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/queue_handler.py</code> <pre><code>def consume(self) -&gt; str:\n    def _consume():\n        def on_message(ch: BlockingChannel, method: Any,\n                       props: BasicProperties, body: bytes) -&gt; None:\n            try:\n                content = self.consuming_by(body)\n                message = Message(content=content, properties=props)\n                key = self.indexing_by(message)\n                with self._lock:\n                    self._received_messages[key] = message\n                ch.basic_ack(\n                    delivery_tag=require_not_none(\n                        method.delivery_tag))\n                self.log.debug(f\"received {key}\")\n            except Exception as e:\n                self.log.warning(f\"skipping message due to error: {e}\")\n                ch.basic_reject(\n                    delivery_tag=require_not_none(\n                        method.delivery_tag),\n                    requeue=True)\n\n        self._consumer_tag = self.channel.basic_consume(\n            queue=self.queue_name, on_message_callback=on_message\n        )\n        self.log.debug(f\"consumer set up with tag {self._consumer_tag}\")\n\n    self._submit(_consume)\n    return \"pending-tag\"\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.publish","title":"<code>publish(messages)</code>","text":"Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/queue_handler.py</code> <pre><code>def publish(self, messages: Iterator[Message[V]]) -&gt; None:\n    def _publish():\n        for message in messages:\n            body = self.publishing_by(message.content)\n            self.channel.basic_publish(\n                exchange=EMPTY_STRING,\n                routing_key=self.queue_name,\n                body=body,\n                properties=message.properties\n            )\n            self.log.debug(f\"published {message}\")\n    self._submit(_publish)\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.publish_values","title":"<code>publish_values(values)</code>","text":"Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/queue_handler.py</code> <pre><code>def publish_values(self, values: Iterator[V]) -&gt; None:\n    self.publish((Message(content=value) for value in values))\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqConfiguration","title":"<code>RabbitMqConfiguration</code>","text":"<p>               Bases: <code>BaseConfiguration</code></p> Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/rabbitmq_configuration.py</code> <pre><code>class RabbitMqConfiguration(BaseConfiguration):\n    @cached_property\n    def connection_uri(self) -&gt; pika.URLParameters:\n        return pika.URLParameters(self.parser.get(\"rabbitmq\", \"connection_uri\"))\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqConfiguration.connection_uri","title":"<code>connection_uri</code>  <code>cached</code> <code>property</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqSteps","title":"<code>RabbitMqSteps</code>","text":"<p>               Bases: <code>GenericSteps[TConfiguration]</code></p> Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/rabbitmq_steps.py</code> <pre><code>class RabbitMqSteps[K, V, TConfiguration: RabbitMqConfiguration](\n        GenericSteps[TConfiguration]):\n    _queue_handler: QueueHandler[K, V]\n\n    @Context.traced\n    @final\n    def a_queue_handler(self, queue_handler: QueueHandler[K, V]) -&gt; Self:\n        self._queue_handler = queue_handler\n        return self\n\n    @Context.traced\n    @final\n    def publishing(self, messages: Iterable[Message[V]]) -&gt; Self:\n        self._queue_handler.publish(iter(messages))\n        return self\n\n    @Context.traced\n    @final\n    def consuming(self) -&gt; Self:\n        self._queue_handler.consume()\n        return self\n\n    @Context.traced\n    @final\n    def the_received_messages(\n            self, by_rule: Matcher[Iterator[Message[V]]]) -&gt; Self:\n        return self.eventually_assert_that(\n            lambda: iter(self._queue_handler.received_messages.values()),\n            by_rule)\n\n    @Context.traced\n    @final\n    def the_message_by_key(\n            self, key: K, by_rule: Matcher[Message[V]]) -&gt; Self:\n        return self.eventually_assert_that(\n            lambda: require_not_none(\n                self._queue_handler.received_messages.get(key)),\n            by_rule)\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqSteps.a_queue_handler","title":"<code>a_queue_handler(queue_handler)</code>","text":"Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/rabbitmq_steps.py</code> <pre><code>@Context.traced\n@final\ndef a_queue_handler(self, queue_handler: QueueHandler[K, V]) -&gt; Self:\n    self._queue_handler = queue_handler\n    return self\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqSteps.consuming","title":"<code>consuming()</code>","text":"Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/rabbitmq_steps.py</code> <pre><code>@Context.traced\n@final\ndef consuming(self) -&gt; Self:\n    self._queue_handler.consume()\n    return self\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqSteps.publishing","title":"<code>publishing(messages)</code>","text":"Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/rabbitmq_steps.py</code> <pre><code>@Context.traced\n@final\ndef publishing(self, messages: Iterable[Message[V]]) -&gt; Self:\n    self._queue_handler.publish(iter(messages))\n    return self\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqSteps.the_message_by_key","title":"<code>the_message_by_key(key, by_rule)</code>","text":"Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/rabbitmq_steps.py</code> <pre><code>@Context.traced\n@final\ndef the_message_by_key(\n        self, key: K, by_rule: Matcher[Message[V]]) -&gt; Self:\n    return self.eventually_assert_that(\n        lambda: require_not_none(\n            self._queue_handler.received_messages.get(key)),\n        by_rule)\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqSteps.the_received_messages","title":"<code>the_received_messages(by_rule)</code>","text":"Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/rabbitmq_steps.py</code> <pre><code>@Context.traced\n@final\ndef the_received_messages(\n        self, by_rule: Matcher[Iterator[Message[V]]]) -&gt; Self:\n    return self.eventually_assert_that(\n        lambda: iter(self._queue_handler.received_messages.values()),\n        by_rule)\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqTests","title":"<code>RabbitMqTests</code>","text":"<p>               Bases: <code>Generic[_K, _V, _TSteps, _TConfiguration]</code>, <code>AbstractTestsBase[_TSteps, _TConfiguration]</code></p> Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/rabbitmq_tests.py</code> <pre><code>class RabbitMqTests(\n        Generic[_K, _V, _TSteps, _TConfiguration],\n        AbstractTestsBase[_TSteps, _TConfiguration]):\n    _connection: pika.BlockingConnection\n\n    @override\n    def setup_method(self):\n        super().setup_method()\n        self._connection = pika.BlockingConnection(\n            self._configuration.connection_uri)\n\n    @override\n    def teardown_method(self):\n        try:\n            self._connection.close()\n        finally:\n            super().teardown_method()\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqTests.setup_method","title":"<code>setup_method()</code>","text":"Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/rabbitmq_tests.py</code> <pre><code>@override\ndef setup_method(self):\n    super().setup_method()\n    self._connection = pika.BlockingConnection(\n        self._configuration.connection_uri)\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqTests.teardown_method","title":"<code>teardown_method()</code>","text":"Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/rabbitmq_tests.py</code> <pre><code>@override\ndef teardown_method(self):\n    try:\n        self._connection.close()\n    finally:\n        super().teardown_method()\n</code></pre>"},{"location":"api/qa-pytest-rest/","title":"REST","text":""},{"location":"api/qa-pytest-rest/#qa_pytest_rest","title":"<code>qa_pytest_rest</code>","text":""},{"location":"api/qa-pytest-rest/#qa_pytest_rest.__all__","title":"<code>__all__ = ['HttpMethod', 'RestConfiguration', 'RestSteps', 'RestTests']</code>  <code>module-attribute</code>","text":""},{"location":"api/qa-pytest-rest/#qa_pytest_rest.__version__","title":"<code>__version__ = '0.0.11.dev7+g9b1fb9b.d20250619'</code>  <code>module-attribute</code>","text":""},{"location":"api/qa-pytest-rest/#qa_pytest_rest.HttpMethod","title":"<code>HttpMethod</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>qa-pytest-rest/src/qa_pytest_rest/rest_steps.py</code> <pre><code>class HttpMethod(str, Enum):\n    GET = \"GET\"\n    POST = \"POST\"\n    PUT = \"PUT\"\n    DELETE = \"DELETE\"\n    PATCH = \"PATCH\"\n</code></pre>"},{"location":"api/qa-pytest-rest/#qa_pytest_rest.HttpMethod.DELETE","title":"<code>DELETE = 'DELETE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rest/#qa_pytest_rest.HttpMethod.GET","title":"<code>GET = 'GET'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rest/#qa_pytest_rest.HttpMethod.PATCH","title":"<code>PATCH = 'PATCH'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rest/#qa_pytest_rest.HttpMethod.POST","title":"<code>POST = 'POST'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rest/#qa_pytest_rest.HttpMethod.PUT","title":"<code>PUT = 'PUT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rest/#qa_pytest_rest.RestConfiguration","title":"<code>RestConfiguration</code>","text":"<p>               Bases: <code>BaseConfiguration</code></p> <p>Configuration class for REST API endpoints.</p> Inherits from <p>BaseConfiguration</p> Source code in <code>qa-pytest-rest/src/qa_pytest_rest/rest_configuration.py</code> <pre><code>class RestConfiguration(BaseConfiguration):\n    \"\"\"\n    Configuration class for REST API endpoints.\n\n    Inherits from:\n        BaseConfiguration\n    \"\"\"\n\n    @final\n    @cached_property\n    def base_url(self) -&gt; str:\n        \"\"\"\n        Returns the base URL for the endpoint from the configuration parser.\n\n        Returns:\n            str: The base URL specified in the configuration under the 'rest/base' key.\n        \"\"\"\n        return self.parser[\"rest\"][\"base_url\"]\n\n    def resource_uri(self, path: str = EMPTY_STRING) -&gt; str:\n        \"\"\"\n        Constructs and returns the full endpoint URL by joining the base endpoint URL with the specified path.\n\n        Args:\n            path (str, optional): The path to append to the base endpoint URL. Defaults to EMPTY.\n\n        Returns:\n            str: The complete URL formed by joining the base endpoint and the provided path.\n        \"\"\"\n        return urljoin(self.base_url, path)\n</code></pre>"},{"location":"api/qa-pytest-rest/#qa_pytest_rest.RestConfiguration.base_url","title":"<code>base_url</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the base URL for the endpoint from the configuration parser.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The base URL specified in the configuration under the 'rest/base' key.</p>"},{"location":"api/qa-pytest-rest/#qa_pytest_rest.RestConfiguration.resource_uri","title":"<code>resource_uri(path=EMPTY_STRING)</code>","text":"<p>Constructs and returns the full endpoint URL by joining the base endpoint URL with the specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to append to the base endpoint URL. Defaults to EMPTY.</p> <code>EMPTY_STRING</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The complete URL formed by joining the base endpoint and the provided path.</p> Source code in <code>qa-pytest-rest/src/qa_pytest_rest/rest_configuration.py</code> <pre><code>def resource_uri(self, path: str = EMPTY_STRING) -&gt; str:\n    \"\"\"\n    Constructs and returns the full endpoint URL by joining the base endpoint URL with the specified path.\n\n    Args:\n        path (str, optional): The path to append to the base endpoint URL. Defaults to EMPTY.\n\n    Returns:\n        str: The complete URL formed by joining the base endpoint and the provided path.\n    \"\"\"\n    return urljoin(self.base_url, path)\n</code></pre>"},{"location":"api/qa-pytest-rest/#qa_pytest_rest.RestSteps","title":"<code>RestSteps</code>","text":"<p>               Bases: <code>GenericSteps[TConfiguration]</code></p> Source code in <code>qa-pytest-rest/src/qa_pytest_rest/rest_steps.py</code> <pre><code>class RestSteps[TConfiguration: RestConfiguration](\n        GenericSteps[TConfiguration]):\n    _rest_session: requests.Session\n\n    @final\n    def _invoke(self, request: Request) -&gt; Response:\n        return self._rest_session.send(\n            self._rest_session.prepare_request(request))\n\n    @Context.traced\n    @final\n    def invoking(self, request: Request) -&gt; Self:\n        \"\"\"\n        Send a REST request and assert that the response is OK.\n\n        Args:\n            request (Request): The HTTP request to send.\n\n        Returns:\n            Self: Enables method chaining.\n\n        Raises:\n            AssertionError: If the response is not OK.\n        \"\"\"\n        return self.eventually_assert_that(\n            lambda: self._invoke(request).ok, is_(True))\n\n    @Context.traced\n    @final\n    def the_invocation(\n            self, request: Request, by_rule: Matcher[Response]) -&gt; Self:\n        \"\"\"\n        Send a REST request and assert that the response matches.\n\n        Args:\n            request (Request): The HTTP request to send.\n            by_ruls (Matcher[Response]): The matcher to apply to the response.\n\n        Returns:\n            Self: Enables method chaining.\n\n        Raises:\n            AssertionError: If the response does not match the rule.\n        \"\"\"\n        return self.eventually_assert_that(\n            lambda: self._invoke(request),\n            by_rule)\n</code></pre>"},{"location":"api/qa-pytest-rest/#qa_pytest_rest.RestSteps.invoking","title":"<code>invoking(request)</code>","text":"<p>Send a REST request and assert that the response is OK.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The HTTP request to send.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Enables method chaining.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the response is not OK.</p> Source code in <code>qa-pytest-rest/src/qa_pytest_rest/rest_steps.py</code> <pre><code>@Context.traced\n@final\ndef invoking(self, request: Request) -&gt; Self:\n    \"\"\"\n    Send a REST request and assert that the response is OK.\n\n    Args:\n        request (Request): The HTTP request to send.\n\n    Returns:\n        Self: Enables method chaining.\n\n    Raises:\n        AssertionError: If the response is not OK.\n    \"\"\"\n    return self.eventually_assert_that(\n        lambda: self._invoke(request).ok, is_(True))\n</code></pre>"},{"location":"api/qa-pytest-rest/#qa_pytest_rest.RestSteps.the_invocation","title":"<code>the_invocation(request, by_rule)</code>","text":"<p>Send a REST request and assert that the response matches.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The HTTP request to send.</p> required <code>by_ruls</code> <code>Matcher[Response]</code> <p>The matcher to apply to the response.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Enables method chaining.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the response does not match the rule.</p> Source code in <code>qa-pytest-rest/src/qa_pytest_rest/rest_steps.py</code> <pre><code>@Context.traced\n@final\ndef the_invocation(\n        self, request: Request, by_rule: Matcher[Response]) -&gt; Self:\n    \"\"\"\n    Send a REST request and assert that the response matches.\n\n    Args:\n        request (Request): The HTTP request to send.\n        by_ruls (Matcher[Response]): The matcher to apply to the response.\n\n    Returns:\n        Self: Enables method chaining.\n\n    Raises:\n        AssertionError: If the response does not match the rule.\n    \"\"\"\n    return self.eventually_assert_that(\n        lambda: self._invoke(request),\n        by_rule)\n</code></pre>"},{"location":"api/qa-pytest-rest/#qa_pytest_rest.RestTests","title":"<code>RestTests</code>","text":"<p>               Bases: <code>Generic[_TSteps, _TConfiguration]</code>, <code>AbstractTestsBase[_TSteps, _TConfiguration]</code></p> <p>Base class for REST API test cases.</p> <p>This class provides a reusable test base for REST API testing, managing a <code>requests.Session</code> for each test method. It is generic over the types of steps and configuration used.</p> <p>Attributes:</p> Name Type Description <code>_rest_session</code> <code>Session</code> <p>The HTTP session used for making REST requests. Note: This session is not thread-safe.</p> Type Parameters <p>TSteps: The type of the steps class, typically derived from RestSteps. TConfiguration: The type of the configuration class, typically derived from RestConfiguration.</p> <p>Methods:</p> Name Description <code>setup_method</code> <p>Initializes a new requests.Session before each test method.</p> <code>teardown_method</code> <p>Closes the requests.Session after each test method.</p> Source code in <code>qa-pytest-rest/src/qa_pytest_rest/rest_tests.py</code> <pre><code>class RestTests(\n        Generic[_TSteps, _TConfiguration],\n        AbstractTestsBase[_TSteps, _TConfiguration]):\n    \"\"\"\n    Base class for REST API test cases.\n\n    This class provides a reusable test base for REST API testing, managing a `requests.Session`\n    for each test method. It is generic over the types of steps and configuration used.\n\n    Attributes:\n        _rest_session (requests.Session): The HTTP session used for making REST requests.\n            Note: This session is not thread-safe.\n\n    Type Parameters:\n        TSteps: The type of the steps class, typically derived from RestSteps.\n        TConfiguration: The type of the configuration class, typically derived from RestConfiguration.\n\n    Methods:\n        setup_method(self):\n            Initializes a new requests.Session before each test method.\n\n        teardown_method(self):\n            Closes the requests.Session after each test method.\n    \"\"\"\n    _rest_session: requests.Session  # not thread safe\n\n    @property\n    def rest_session(self) -&gt; requests.Session:\n        \"\"\"\n        Returns the HTTP session used for making REST requests.\n\n        Returns:\n            requests.Session: The HTTP session instance.\n        \"\"\"\n        return self._rest_session\n\n    @override\n    def setup_method(self):\n        super().setup_method()\n        self._rest_session = requests.Session()\n\n    @override\n    def teardown_method(self):\n        try:\n            self._rest_session.close()\n        finally:\n            super().teardown_method()\n</code></pre>"},{"location":"api/qa-pytest-rest/#qa_pytest_rest.RestTests.rest_session","title":"<code>rest_session</code>  <code>property</code>","text":"<p>Returns the HTTP session used for making REST requests.</p> <p>Returns:</p> Type Description <code>Session</code> <p>requests.Session: The HTTP session instance.</p>"},{"location":"api/qa-pytest-rest/#qa_pytest_rest.RestTests.setup_method","title":"<code>setup_method()</code>","text":"Source code in <code>qa-pytest-rest/src/qa_pytest_rest/rest_tests.py</code> <pre><code>@override\ndef setup_method(self):\n    super().setup_method()\n    self._rest_session = requests.Session()\n</code></pre>"},{"location":"api/qa-pytest-rest/#qa_pytest_rest.RestTests.teardown_method","title":"<code>teardown_method()</code>","text":"Source code in <code>qa-pytest-rest/src/qa_pytest_rest/rest_tests.py</code> <pre><code>@override\ndef teardown_method(self):\n    try:\n        self._rest_session.close()\n    finally:\n        super().teardown_method()\n</code></pre>"},{"location":"api/qa-pytest-webdriver/","title":"WebDriver","text":""},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver","title":"<code>qa_pytest_webdriver</code>","text":""},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.ElementSupplier","title":"<code>ElementSupplier = Callable[[], WebElement]</code>  <code>module-attribute</code>","text":""},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.LocatorOrSupplier","title":"<code>LocatorOrSupplier = Union[Locator, ElementSupplier]</code>  <code>module-attribute</code>","text":""},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.__all__","title":"<code>__all__ = ['By', 'ElementSupplier', 'Locator', 'LocatorOrSupplier', 'SearchContext', 'SeleniumConfiguration', 'SeleniumSteps', 'SeleniumTests']</code>  <code>module-attribute</code>","text":""},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.__version__","title":"<code>__version__ = '0.0.11.dev7+g9b1fb9b.d20250619'</code>  <code>module-attribute</code>","text":""},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.By","title":"<code>By</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>class By:\n\n    @staticmethod\n    def id(value: str) -&gt; Locator:\n        return Locator(_By.ID, value)\n\n    @staticmethod\n    def xpath(value: str) -&gt; Locator:\n        return Locator(_By.XPATH, value)\n\n    @staticmethod\n    def link_text(value: str) -&gt; Locator:\n        return Locator(_By.LINK_TEXT, value)\n\n    @staticmethod\n    def partial_link_text(value: str) -&gt; Locator:\n        return Locator(_By.PARTIAL_LINK_TEXT, value)\n\n    @staticmethod\n    def name(value: str) -&gt; Locator:\n        return Locator(_By.NAME, value)\n\n    @staticmethod\n    def tag_name(value: str) -&gt; Locator:\n        return Locator(_By.TAG_NAME, value)\n\n    @staticmethod\n    def class_name(value: str) -&gt; Locator:\n        return Locator(_By.CLASS_NAME, value)\n\n    @staticmethod\n    def css_selector(value: str) -&gt; Locator:\n        return Locator(_By.CSS_SELECTOR, value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.By.class_name","title":"<code>class_name(value)</code>  <code>staticmethod</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@staticmethod\ndef class_name(value: str) -&gt; Locator:\n    return Locator(_By.CLASS_NAME, value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.By.css_selector","title":"<code>css_selector(value)</code>  <code>staticmethod</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@staticmethod\ndef css_selector(value: str) -&gt; Locator:\n    return Locator(_By.CSS_SELECTOR, value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.By.id","title":"<code>id(value)</code>  <code>staticmethod</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@staticmethod\ndef id(value: str) -&gt; Locator:\n    return Locator(_By.ID, value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.By.link_text","title":"<code>link_text(value)</code>  <code>staticmethod</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@staticmethod\ndef link_text(value: str) -&gt; Locator:\n    return Locator(_By.LINK_TEXT, value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.By.name","title":"<code>name(value)</code>  <code>staticmethod</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@staticmethod\ndef name(value: str) -&gt; Locator:\n    return Locator(_By.NAME, value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.By.partial_link_text","title":"<code>partial_link_text(value)</code>  <code>staticmethod</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@staticmethod\ndef partial_link_text(value: str) -&gt; Locator:\n    return Locator(_By.PARTIAL_LINK_TEXT, value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.By.tag_name","title":"<code>tag_name(value)</code>  <code>staticmethod</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@staticmethod\ndef tag_name(value: str) -&gt; Locator:\n    return Locator(_By.TAG_NAME, value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.By.xpath","title":"<code>xpath(value)</code>  <code>staticmethod</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@staticmethod\ndef xpath(value: str) -&gt; Locator:\n    return Locator(_By.XPATH, value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.Locator","title":"<code>Locator</code>  <code>dataclass</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@dataclass(frozen=True)\nclass Locator:\n    by: str\n    value: str\n\n    def as_tuple(self) -&gt; Tuple[str, str]:\n        return (self.by, self.value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.Locator.by","title":"<code>by</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.Locator.value","title":"<code>value</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.Locator.__init__","title":"<code>__init__(by, value)</code>","text":""},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.Locator.as_tuple","title":"<code>as_tuple()</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>def as_tuple(self) -&gt; Tuple[str, str]:\n    return (self.by, self.value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SearchContext","title":"<code>SearchContext</code>","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>class SearchContext(Protocol):\n    def find_element(self, by: str, value: Optional[str]) -&gt; WebElement: ...\n\n    def find_elements(\n        self, by: str, value: Optional[str]) -&gt; List[WebElement]: ...\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SearchContext.find_element","title":"<code>find_element(by, value)</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>def find_element(self, by: str, value: Optional[str]) -&gt; WebElement: ...\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SearchContext.find_elements","title":"<code>find_elements(by, value)</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>def find_elements(\n    self, by: str, value: Optional[str]) -&gt; List[WebElement]: ...\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumConfiguration","title":"<code>SeleniumConfiguration</code>","text":"<p>               Bases: <code>BaseConfiguration</code></p> <p>SeleniumConfiguration extends BaseConfiguration to provide Selenium-specific configuration options.</p> <p>This class exposes properties for retrieving the UI URL and initializing the Selenium WebDriver Service, leveraging configuration values and dynamic driver management.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_configuration.py</code> <pre><code>class SeleniumConfiguration(BaseConfiguration):\n    \"\"\"\n    SeleniumConfiguration extends BaseConfiguration to provide Selenium-specific configuration options.\n\n    This class exposes properties for retrieving the UI URL and initializing the Selenium WebDriver Service,\n    leveraging configuration values and dynamic driver management.\n    \"\"\"\n\n    @cached_property\n    @final\n    def landing_page(self) -&gt; str:\n        \"\"\"\n        Returns the UI URL from the configuration parser.\n\n        Returns:\n            str: The URL string specified under the \"selenium/base\" in the configuration.\n\n        Raises:\n            KeyError: If the \"selenium\" section or \"base\" key is not present in the configuration parser.\n        \"\"\"\n        return self.parser[\"selenium\"][\"landing_page\"]\n\n    # FIXME Service here is imported from selenium.webdriver.chrome.service\n    # which makes this method specific to ChromeDriver.\n    @cached_property\n    @final\n    def service(self) -&gt; Service:\n        \"\"\"\n        Creates and returns a Selenium WebDriver Service instance using the ChromeDriverManager.\n\n        Returns:\n            Service: An instance of Selenium's Service class, initialized with the path to the ChromeDriver executable\n            installed by ChromeDriverManager.\n\n        Note:\n            This method currently supports only ChromeDriver, but may be extended to support different services\n            based on configuration in the future.\n        \"\"\"\n        # NOTE may add support for providing different services per configuration\n        return Service(ChromeDriverManager().install())\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumConfiguration.landing_page","title":"<code>landing_page</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the UI URL from the configuration parser.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The URL string specified under the \"selenium/base\" in the configuration.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the \"selenium\" section or \"base\" key is not present in the configuration parser.</p>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumConfiguration.service","title":"<code>service</code>  <code>cached</code> <code>property</code>","text":"<p>Creates and returns a Selenium WebDriver Service instance using the ChromeDriverManager.</p> <p>Returns:</p> Name Type Description <code>Service</code> <code>Service</code> <p>An instance of Selenium's Service class, initialized with the path to the ChromeDriver executable</p> <code>Service</code> <p>installed by ChromeDriverManager.</p> Note <p>This method currently supports only ChromeDriver, but may be extended to support different services based on configuration in the future.</p>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumSteps","title":"<code>SeleniumSteps</code>","text":"<p>               Bases: <code>GenericSteps[TConfiguration]</code></p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>class SeleniumSteps[TConfiguration: SeleniumConfiguration](\n    GenericSteps[TConfiguration]\n):\n    _web_driver: WebDriver\n\n    @final\n    @Context.traced\n    def clicking_once(self, element_supplier: ElementSupplier) -&gt; Self:\n        element_supplier().click()\n        return self\n\n    @overload\n    def clicking(self, element: Locator) -&gt; Self: ...\n\n    @overload\n    def clicking(self, element: ElementSupplier) -&gt; Self: ...\n\n    @final\n    def clicking(self, element: LocatorOrSupplier) -&gt; Self:\n        return self.retrying(lambda: self.clicking_once(self._resolve(element)))\n\n    @final\n    @Context.traced\n    def typing_once(self, element_supplier: ElementSupplier, text: str) -&gt; Self:\n        element = element_supplier()\n        element.clear()\n        element.send_keys(text)\n        return self\n\n    @overload\n    def typing(self, element: Locator, text: str) -&gt; Self: ...\n\n    @overload\n    def typing(self, element: ElementSupplier, text: str) -&gt; Self: ...\n\n    @final\n    def typing(self, element: LocatorOrSupplier, text: str) -&gt; Self:\n        return self.retrying(lambda: self.typing_once(self._resolve(element), text))\n\n    @final\n    def the_element(self, locator: Locator, by_rule: Matcher[WebElement], context: Optional[SearchContext] = None) -&gt; Self:\n        return self.eventually_assert_that(lambda: self._element(locator, context), by_rule)\n\n    @final\n    def the_elements(self, locator: Locator, by_rule: Matcher[Iterator[WebElement]], context: Optional[SearchContext] = None) -&gt; Self:\n        return self.eventually_assert_that(lambda: self._elements(locator, context), by_rule)\n\n    @final\n    @Context.traced\n    def _elements(\n        self, locator: Locator, context: Optional[SearchContext] = None\n    ) -&gt; Iterator[WebElement]:\n        return iter((context or self._web_driver).find_elements(*locator.as_tuple()))\n\n    @final\n    @Context.traced\n    def _element(\n        self, locator: Locator, context: Optional[SearchContext] = None\n    ) -&gt; WebElement:\n        return self._scroll_into_view(\n            (context or self._web_driver).find_element(*locator.as_tuple())\n        )\n\n    def _scroll_into_view(self, element: WebElement) -&gt; WebElement:\n        self._web_driver.execute_script(  # type: ignore\n            \"arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});\", element)\n        return element\n\n    @final\n    def _resolve(self, element: LocatorOrSupplier) -&gt; ElementSupplier:\n        if isinstance(element, Locator):\n            return lambda: self._element(element)\n        return element\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumSteps.clicking","title":"<code>clicking(element)</code>","text":"<pre><code>clicking(element: Locator) -&gt; Self\n</code></pre><pre><code>clicking(element: ElementSupplier) -&gt; Self\n</code></pre> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@final\ndef clicking(self, element: LocatorOrSupplier) -&gt; Self:\n    return self.retrying(lambda: self.clicking_once(self._resolve(element)))\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumSteps.clicking_once","title":"<code>clicking_once(element_supplier)</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@final\n@Context.traced\ndef clicking_once(self, element_supplier: ElementSupplier) -&gt; Self:\n    element_supplier().click()\n    return self\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumSteps.the_element","title":"<code>the_element(locator, by_rule, context=None)</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@final\ndef the_element(self, locator: Locator, by_rule: Matcher[WebElement], context: Optional[SearchContext] = None) -&gt; Self:\n    return self.eventually_assert_that(lambda: self._element(locator, context), by_rule)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumSteps.the_elements","title":"<code>the_elements(locator, by_rule, context=None)</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@final\ndef the_elements(self, locator: Locator, by_rule: Matcher[Iterator[WebElement]], context: Optional[SearchContext] = None) -&gt; Self:\n    return self.eventually_assert_that(lambda: self._elements(locator, context), by_rule)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumSteps.typing","title":"<code>typing(element, text)</code>","text":"<pre><code>typing(element: Locator, text: str) -&gt; Self\n</code></pre><pre><code>typing(element: ElementSupplier, text: str) -&gt; Self\n</code></pre> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@final\ndef typing(self, element: LocatorOrSupplier, text: str) -&gt; Self:\n    return self.retrying(lambda: self.typing_once(self._resolve(element), text))\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumSteps.typing_once","title":"<code>typing_once(element_supplier, text)</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@final\n@Context.traced\ndef typing_once(self, element_supplier: ElementSupplier, text: str) -&gt; Self:\n    element = element_supplier()\n    element.clear()\n    element.send_keys(text)\n    return self\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumTests","title":"<code>SeleniumTests</code>","text":"<p>               Bases: <code>Generic[_TSteps, _TConfiguration]</code>, <code>AbstractTestsBase[_TSteps, _TConfiguration]</code></p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_tests.py</code> <pre><code>class SeleniumTests(\n        Generic[_TSteps, _TConfiguration],\n        AbstractTestsBase[_TSteps, _TConfiguration]):\n    _web_driver: WebDriver  # not thread safe\n\n    @property\n    def web_driver(self) -&gt; WebDriver:\n        '''\n        Returns the web driver instance.\n\n        Returns:\n            WebDriver: The web driver instance.\n        '''\n        return self._web_driver\n\n    @override\n    def setup_method(self):\n        super().setup_method()\n\n        options = Options()\n        options.add_argument(\"--start-maximized\")  # type: ignore\n        self._web_driver = Chrome(\n            options,\n            self._configuration.service)\n\n    @override\n    def teardown_method(self):\n        try:\n            self._web_driver.quit()\n        finally:\n            super().teardown_method()\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumTests.web_driver","title":"<code>web_driver</code>  <code>property</code>","text":"<p>Returns the web driver instance.</p> <p>Returns:</p> Name Type Description <code>WebDriver</code> <code>WebDriver</code> <p>The web driver instance.</p>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumTests.setup_method","title":"<code>setup_method()</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_tests.py</code> <pre><code>@override\ndef setup_method(self):\n    super().setup_method()\n\n    options = Options()\n    options.add_argument(\"--start-maximized\")  # type: ignore\n    self._web_driver = Chrome(\n        options,\n        self._configuration.service)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumTests.teardown_method","title":"<code>teardown_method()</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_tests.py</code> <pre><code>@override\ndef teardown_method(self):\n    try:\n        self._web_driver.quit()\n    finally:\n        super().teardown_method()\n</code></pre>"},{"location":"api/qa-testing-utils/","title":"Utils","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils","title":"<code>qa_testing_utils</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.DateOrDateTime","title":"<code>DateOrDateTime = Union[date, datetime]</code>  <code>module-attribute</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.__all__","title":"<code>__all__ = ['ContainsStringIgnoringCase', 'Context', 'DateOrDateTime', 'FromTupleMixin', 'ImmutableMixin', 'InvalidValueException', 'IsIteratorYielding', 'IsIteratorYieldingAll', 'IsStreamContainingEvery', 'IsWithinDates', 'IterableReader', 'LoggerMixin', 'SingletonBase', 'SingletonMeta', 'TestException', 'ThreadLocal', 'ToDictMixin', 'TracingMatcher', 'Valid', 'WithMixin', 'adapted_iterator', 'adapted_object', 'adapted_sequence', 'classproperty', 'configure', 'contains_string_ignoring_case', 'crc32_of', 'decompress_xz_stream', 'extract_files_from_tar', 'get_test_body', 'logger', 'makereport', 'match_as', 'process_next', 'read_lines', 'require_not_none', 'safely', 'sleep_for', 'stream_file', 'swallow', 'to_string', 'trace', 'traced', 'valid', 'within_dates', 'write_csv', 'yields_every', 'yields_item', 'yields_items']</code>  <code>module-attribute</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.__version__","title":"<code>__version__ = '0.0.11.dev7+g9b1fb9b.d20250619'</code>  <code>module-attribute</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.ContainsStringIgnoringCase","title":"<code>ContainsStringIgnoringCase</code>","text":"<p>               Bases: <code>BaseMatcher[str]</code></p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>@final\nclass ContainsStringIgnoringCase(BaseMatcher[str]):\n    def __init__(self, substring: str) -&gt; None:\n        self.substring: str = substring.lower()\n\n    def _matches(self, item: Any) -&gt; bool:\n        if not isinstance(item, str):\n            return False\n        return self.substring in item.lower()\n\n    def describe_to(self, description: Description) -&gt; None:\n        description.append_text(\n            f\"a string containing (case-insensitive) '{self.substring}'\")\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ContainsStringIgnoringCase.substring","title":"<code>substring = substring.lower()</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.ContainsStringIgnoringCase.__init__","title":"<code>__init__(substring)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def __init__(self, substring: str) -&gt; None:\n    self.substring: str = substring.lower()\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ContainsStringIgnoringCase.describe_to","title":"<code>describe_to(description)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def describe_to(self, description: Description) -&gt; None:\n    description.append_text(\n        f\"a string containing (case-insensitive) '{self.substring}'\")\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.Context","title":"<code>Context</code>  <code>dataclass</code>","text":"<p>Per-thread context for reporting and logging, allowing dynamic formatting of messages.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/logger.py</code> <pre><code>@dataclass\n@final\nclass Context:\n    \"\"\"Per-thread context for reporting and logging, allowing dynamic formatting of messages.\"\"\"\n    _THREAD_LOCAL: ClassVar[ThreadLocal['Context']]\n    _formatter: Final[Callable[[str], str]]\n\n    @classmethod\n    def default(cls) -&gt; \"Context\":\n        return cls(lambda _: _)  # no formatter\n\n    @classproperty\n    def _format(cls) -&gt; Callable[[str], str]:\n        return cls._THREAD_LOCAL.get()._formatter\n\n    @classmethod\n    def set(cls, context_fn: Callable[[str], str]) -&gt; None:\n        \"\"\"Sets per-thread context function to be used for formatting report and log messages.\"\"\"\n        cls._THREAD_LOCAL.set(Context(context_fn))\n\n    @classmethod\n    def traced(cls, func: Callable[_P, _R]) -&gt; Callable[_P, _R]:\n        \"\"\"\n        Decorator to log function entry, arguments, and return value at DEBUG level.\n\n        Also adds an Allure step for reporting. Use on methods where tracing is useful\n        for debugging or reporting.\n\n        Example:\n            @Context.traced\n            def my_method(self, x):\n                ...\n\n        Args:\n            func (Callable[P, R]): The function to be decorated.\n            *args (Any): Positional arguments to be passed to the function.\n            **kwargs (Any): Keyword arguments to be passed to the function.\n\n        Returns:\n            Callable[P, R]: The result of the function call.\n        \"\"\"\n        @wraps(func)\n        def wrapper(*args: _P.args, **kwargs: _P.kwargs) -&gt; _R:\n            # NOTE: each time a decorated function is called this logic will be\n            # re-evaluated.\n            signature = inspect.signature(func)\n            parameters = list(signature.parameters.keys())\n\n            if parameters and parameters[0] == 'self' and len(args) &gt; 0:\n                instance = args[0]\n                logger = logging.getLogger(f\"{instance.__class__.__name__}\")\n                logger.debug(f\"&gt;&gt;&gt; \"\n                             + cls._format(\n                                 f\"{func.__name__} \"\n                                 f\"{\", \".join([str(arg) for arg in args[1:]])} \"\n                                 f\"{LF.join(\n                                     f\"{key}={str(value)}\"\n                                     for key, value in kwargs.items()) if kwargs else EMPTY_STRING}\"))\n\n                with allure.step(  # type: ignore\n                    cls._format(\n                        f\"{func.__name__} \"\n                        f\"{', '.join([str(arg) for arg in args[1:]])}\")):\n                    result = func(*args, **kwargs)\n\n                if result == instance:\n                    logger.debug(f\"&lt;&lt;&lt; \" + cls._format(f\"{func.__name__}\"))\n                else:\n                    logger.debug(\n                        f\"&lt;&lt;&lt; \" + cls._format(f\"{func.__name__} {result}\"))\n\n                return result\n            else:\n                logger = logging.getLogger(func.__name__)\n                logger.debug(f\"&gt;&gt;&gt; {func.__name__} {args} {kwargs}\")\n                result = func(*args, **kwargs)\n                logger.debug(f\"&lt;&lt;&lt; {func.__name__} {result}\")\n                return result\n\n        return wrapper\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.Context.__init__","title":"<code>__init__(_formatter)</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.Context.default","title":"<code>default()</code>  <code>classmethod</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/logger.py</code> <pre><code>@classmethod\ndef default(cls) -&gt; \"Context\":\n    return cls(lambda _: _)  # no formatter\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.Context.set","title":"<code>set(context_fn)</code>  <code>classmethod</code>","text":"<p>Sets per-thread context function to be used for formatting report and log messages.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/logger.py</code> <pre><code>@classmethod\ndef set(cls, context_fn: Callable[[str], str]) -&gt; None:\n    \"\"\"Sets per-thread context function to be used for formatting report and log messages.\"\"\"\n    cls._THREAD_LOCAL.set(Context(context_fn))\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.Context.traced","title":"<code>traced(func)</code>  <code>classmethod</code>","text":"<p>Decorator to log function entry, arguments, and return value at DEBUG level.</p> <p>Also adds an Allure step for reporting. Use on methods where tracing is useful for debugging or reporting.</p> Example <p>@Context.traced def my_method(self, x):     ...</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R]</code> <p>The function to be decorated.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to be passed to the function.</p> required <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to be passed to the function.</p> required <p>Returns:</p> Type Description <code>Callable[_P, _R]</code> <p>Callable[P, R]: The result of the function call.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/logger.py</code> <pre><code>@classmethod\ndef traced(cls, func: Callable[_P, _R]) -&gt; Callable[_P, _R]:\n    \"\"\"\n    Decorator to log function entry, arguments, and return value at DEBUG level.\n\n    Also adds an Allure step for reporting. Use on methods where tracing is useful\n    for debugging or reporting.\n\n    Example:\n        @Context.traced\n        def my_method(self, x):\n            ...\n\n    Args:\n        func (Callable[P, R]): The function to be decorated.\n        *args (Any): Positional arguments to be passed to the function.\n        **kwargs (Any): Keyword arguments to be passed to the function.\n\n    Returns:\n        Callable[P, R]: The result of the function call.\n    \"\"\"\n    @wraps(func)\n    def wrapper(*args: _P.args, **kwargs: _P.kwargs) -&gt; _R:\n        # NOTE: each time a decorated function is called this logic will be\n        # re-evaluated.\n        signature = inspect.signature(func)\n        parameters = list(signature.parameters.keys())\n\n        if parameters and parameters[0] == 'self' and len(args) &gt; 0:\n            instance = args[0]\n            logger = logging.getLogger(f\"{instance.__class__.__name__}\")\n            logger.debug(f\"&gt;&gt;&gt; \"\n                         + cls._format(\n                             f\"{func.__name__} \"\n                             f\"{\", \".join([str(arg) for arg in args[1:]])} \"\n                             f\"{LF.join(\n                                 f\"{key}={str(value)}\"\n                                 for key, value in kwargs.items()) if kwargs else EMPTY_STRING}\"))\n\n            with allure.step(  # type: ignore\n                cls._format(\n                    f\"{func.__name__} \"\n                    f\"{', '.join([str(arg) for arg in args[1:]])}\")):\n                result = func(*args, **kwargs)\n\n            if result == instance:\n                logger.debug(f\"&lt;&lt;&lt; \" + cls._format(f\"{func.__name__}\"))\n            else:\n                logger.debug(\n                    f\"&lt;&lt;&lt; \" + cls._format(f\"{func.__name__} {result}\"))\n\n            return result\n        else:\n            logger = logging.getLogger(func.__name__)\n            logger.debug(f\"&gt;&gt;&gt; {func.__name__} {args} {kwargs}\")\n            result = func(*args, **kwargs)\n            logger.debug(f\"&lt;&lt;&lt; {func.__name__} {result}\")\n            return result\n\n    return wrapper\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.FromTupleMixin","title":"<code>FromTupleMixin</code>","text":"<p>Class decorator adding a <code>from_tuple</code> method allowing instantiation from a tuple matching the order of decorated class fields.</p> <p>Works with frozen dataclasses too.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/tuple_utils.py</code> <pre><code>class FromTupleMixin:\n    \"\"\"\n    Class decorator adding a `from_tuple` method allowing instantiation from\n    a tuple matching the order of decorated class fields.\n\n    Works with frozen dataclasses too.\n    \"\"\"\n    @classmethod\n    def from_tuple(cls: Type[Self], data: Tuple[Any, ...]) -&gt; Self:\n        if is_dataclass(cls):\n            # Retrieve all fields, including inherited ones\n            cls_fields = [f.name for f in fields(cls)]\n\n            # Create a dictionary of field names to values from the tuple\n            field_values = {name: value for name,\n                            value in zip(cls_fields, data)}\n\n            # Create a new instance using `__new__`\n            instance = cls.__new__(cls)\n\n            # If the dataclass is frozen, use `replace` to set the attributes\n            if getattr(cls, '__dataclass_params__').frozen:\n                return replace(instance, **field_values)\n            else:\n                # If the dataclass is not frozen, use setattr to set attributes\n                for key, value in field_values.items():\n                    setattr(instance, key, value)\n\n                # Call __init__ if defined\n                instance.__init__(*data)\n                return instance\n        else:\n            # For vanilla classes, assume fields are defined in __init__\n            # Using `__init__` directly as the custom initializer\n            instance = cls.__new__(cls)\n            for attr, value in zip(cls.__annotations__.keys(), data):\n                setattr(instance, attr, value)\n\n            # Call __init__ if it expects parameters\n            instance.__init__(*data)\n            return instance\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.FromTupleMixin.from_tuple","title":"<code>from_tuple(data)</code>  <code>classmethod</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/tuple_utils.py</code> <pre><code>@classmethod\ndef from_tuple(cls: Type[Self], data: Tuple[Any, ...]) -&gt; Self:\n    if is_dataclass(cls):\n        # Retrieve all fields, including inherited ones\n        cls_fields = [f.name for f in fields(cls)]\n\n        # Create a dictionary of field names to values from the tuple\n        field_values = {name: value for name,\n                        value in zip(cls_fields, data)}\n\n        # Create a new instance using `__new__`\n        instance = cls.__new__(cls)\n\n        # If the dataclass is frozen, use `replace` to set the attributes\n        if getattr(cls, '__dataclass_params__').frozen:\n            return replace(instance, **field_values)\n        else:\n            # If the dataclass is not frozen, use setattr to set attributes\n            for key, value in field_values.items():\n                setattr(instance, key, value)\n\n            # Call __init__ if defined\n            instance.__init__(*data)\n            return instance\n    else:\n        # For vanilla classes, assume fields are defined in __init__\n        # Using `__init__` directly as the custom initializer\n        instance = cls.__new__(cls)\n        for attr, value in zip(cls.__annotations__.keys(), data):\n            setattr(instance, attr, value)\n\n        # Call __init__ if it expects parameters\n        instance.__init__(*data)\n        return instance\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ImmutableMixin","title":"<code>ImmutableMixin</code>","text":"<p>Mixin to enforce immutability after initialization.</p> <p>Overrides setattr to raise AttributeError if an attribute is modified after being set. Intended for use with non-dataclasses. For dataclasses, use <code>@dataclass(frozen=True)</code>.</p> Limitations <ul> <li>Does not work with WithMixin if attributes have default values.</li> <li>Does not work if applied to a superclass with a custom init.</li> </ul> Example <p>class MyImmutable(ImmutableMixin):     foo: int = 1 obj = MyImmutable() obj.foo = 2  # Raises AttributeError</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>class ImmutableMixin:\n    \"\"\"\n    Mixin to enforce immutability after initialization.\n\n    Overrides __setattr__ to raise AttributeError if an attribute is modified after being set.\n    Intended for use with non-dataclasses. For dataclasses, use `@dataclass(frozen=True)`.\n\n    Limitations:\n        - Does not work with WithMixin if attributes have default values.\n        - Does not work if applied to a superclass with a custom __init__.\n\n    Example:\n        class MyImmutable(ImmutableMixin):\n            foo: int = 1\n        obj = MyImmutable()\n        obj.foo = 2  # Raises AttributeError\n    \"\"\"\n\n    def __setattr__(self, key: str, value: Any) -&gt; None:\n        if hasattr(self, key):\n            raise AttributeError(f\"Can't modify attribute '{\n                                 key}' after initialization\")\n        super().__setattr__(key, value)  # Properly sets the attribute\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ImmutableMixin.__setattr__","title":"<code>__setattr__(key, value)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>def __setattr__(self, key: str, value: Any) -&gt; None:\n    if hasattr(self, key):\n        raise AttributeError(f\"Can't modify attribute '{\n                             key}' after initialization\")\n    super().__setattr__(key, value)  # Properly sets the attribute\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.InvalidValueException","title":"<code>InvalidValueException</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an object fails validation via the Valid protocol.</p> Example <p>if not obj.is_valid():     raise InvalidValueException(obj)</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>class InvalidValueException(ValueError):\n    \"\"\"\n    Raised when an object fails validation via the Valid protocol.\n\n    Example:\n        if not obj.is_valid():\n            raise InvalidValueException(obj)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsIteratorYielding","title":"<code>IsIteratorYielding</code>","text":"<p>               Bases: <code>BaseMatcher[Iterator[T]]</code></p> <p>Matcher for data yielded by iterators.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>@final\nclass IsIteratorYielding[T](BaseMatcher[Iterator[T]]):\n    \"\"\"\n    Matcher for data yielded by iterators.\n    \"\"\"\n\n    def __init__(self, element_matcher: Matcher[T]) -&gt; None:\n        self.element_matcher = element_matcher\n\n    @override\n    def _matches(self, item: Iterable[T]) -&gt; bool:\n        for element in item:\n            if self.element_matcher.matches(element):\n                return True\n\n        # No matching element found\n        return False\n\n    @override\n    def describe_to(self, description: Description) -&gt; None:\n        description.append_text(\"a stream containing \") \\\n            .append_description_of(self.element_matcher)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsIteratorYielding.element_matcher","title":"<code>element_matcher = element_matcher</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.IsIteratorYielding.__init__","title":"<code>__init__(element_matcher)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def __init__(self, element_matcher: Matcher[T]) -&gt; None:\n    self.element_matcher = element_matcher\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsIteratorYielding.describe_to","title":"<code>describe_to(description)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>@override\ndef describe_to(self, description: Description) -&gt; None:\n    description.append_text(\"a stream containing \") \\\n        .append_description_of(self.element_matcher)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsIteratorYieldingAll","title":"<code>IsIteratorYieldingAll</code>","text":"<p>               Bases: <code>BaseMatcher[Iterator[T]]</code></p> <p>Matcher to ensure that the iterator yields at least one instance of each specified matcher.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>@final\nclass IsIteratorYieldingAll[T](BaseMatcher[Iterator[T]]):\n    \"\"\"\n    Matcher to ensure that the iterator yields at least one instance of each specified matcher.\n    \"\"\"\n\n    def __init__(self, element_matchers: List[Matcher[T]]) -&gt; None:\n        self.element_matchers = element_matchers\n\n    @override\n    def _matches(self, item: Iterable[T]) -&gt; bool:\n        unmatched_matchers = set(self.element_matchers)\n        for element in item:\n            unmatched_matchers = {\n                m for m in unmatched_matchers if not m.matches(element)}\n            if not unmatched_matchers:  # All matchers have been satisfied\n                return True\n\n        return False\n\n    @override\n    def describe_to(self, description: Description) -&gt; None:\n        description.append_text(\"a stream containing each of: \")\n        for index, matcher in enumerate(self.element_matchers):\n            if index &gt; 0:\n                description.append_text(\", \")\n            description.append_description_of(matcher)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsIteratorYieldingAll.element_matchers","title":"<code>element_matchers = element_matchers</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.IsIteratorYieldingAll.__init__","title":"<code>__init__(element_matchers)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def __init__(self, element_matchers: List[Matcher[T]]) -&gt; None:\n    self.element_matchers = element_matchers\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsIteratorYieldingAll.describe_to","title":"<code>describe_to(description)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>@override\ndef describe_to(self, description: Description) -&gt; None:\n    description.append_text(\"a stream containing each of: \")\n    for index, matcher in enumerate(self.element_matchers):\n        if index &gt; 0:\n            description.append_text(\", \")\n        description.append_description_of(matcher)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsStreamContainingEvery","title":"<code>IsStreamContainingEvery</code>","text":"<p>               Bases: <code>BaseMatcher[Iterator[T]]</code></p> <p>Matcher to ensure every element yielded by an iterator matches a given matcher.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>@final\nclass IsStreamContainingEvery[T](BaseMatcher[Iterator[T]]):\n    \"\"\"\n    Matcher to ensure every element yielded by an iterator matches a given matcher.\n    \"\"\"\n\n    def __init__(self, element_matcher: Matcher[T]) -&gt; None:\n        self.element_matcher = element_matcher\n\n    @override\n    def _matches(self, item: Iterable[T]) -&gt; bool:\n        for element in item:\n            if not self.element_matcher.matches(element):\n                return False  # One non-matching element means failure\n\n        # All elements matched\n        return True\n\n    @override\n    def describe_to(self, description: Description) -&gt; None:\n        description.append_text(\"a stream where every item is \") \\\n            .append_description_of(self.element_matcher)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsStreamContainingEvery.element_matcher","title":"<code>element_matcher = element_matcher</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.IsStreamContainingEvery.__init__","title":"<code>__init__(element_matcher)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def __init__(self, element_matcher: Matcher[T]) -&gt; None:\n    self.element_matcher = element_matcher\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsStreamContainingEvery.describe_to","title":"<code>describe_to(description)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>@override\ndef describe_to(self, description: Description) -&gt; None:\n    description.append_text(\"a stream where every item is \") \\\n        .append_description_of(self.element_matcher)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsWithinDates","title":"<code>IsWithinDates</code>","text":"<p>               Bases: <code>BaseMatcher[DateOrDateTime]</code></p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>@final\nclass IsWithinDates(BaseMatcher[DateOrDateTime]):\n    def __init__(\n            self, start_date: Optional[DateOrDateTime],\n            end_date: Optional[DateOrDateTime]) -&gt; None:\n        self.start_date = start_date\n        self.end_date = end_date\n\n    def _matches(self, item: Optional[DateOrDateTime]) -&gt; bool:\n        if item is None:\n            return False\n\n        # Normalize item to datetime\n        if not isinstance(item, datetime):\n            item = datetime.combine(item, datetime.min.time())\n\n        # Normalize start_date and end_date to datetime\n        def to_datetime(value: Optional[DateOrDateTime]) -&gt; Optional[datetime]:\n            if value is None:\n                return None\n            return value if isinstance(\n                value, datetime) else datetime.combine(\n                value, datetime.min.time())\n\n        start = to_datetime(self.start_date)\n        end = to_datetime(self.end_date)\n\n        if start and end:\n            return start &lt;= item &lt;= end\n        if start:\n            return item &gt;= start\n        if end:\n            return item &lt;= end\n\n        return False\n\n    def describe_to(self, description: Description) -&gt; None:\n        if self.start_date is None:\n            description.append_text(f\"a date before {self.end_date}\")\n        elif self.end_date is None:\n            description.append_text(f\"a date after {self.start_date}\")\n        else:\n            description.append_text(\n                f\"a date within {self.start_date} and {self.end_date}\")\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsWithinDates.end_date","title":"<code>end_date = end_date</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.IsWithinDates.start_date","title":"<code>start_date = start_date</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.IsWithinDates.__init__","title":"<code>__init__(start_date, end_date)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def __init__(\n        self, start_date: Optional[DateOrDateTime],\n        end_date: Optional[DateOrDateTime]) -&gt; None:\n    self.start_date = start_date\n    self.end_date = end_date\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsWithinDates.describe_to","title":"<code>describe_to(description)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def describe_to(self, description: Description) -&gt; None:\n    if self.start_date is None:\n        description.append_text(f\"a date before {self.end_date}\")\n    elif self.end_date is None:\n        description.append_text(f\"a date after {self.start_date}\")\n    else:\n        description.append_text(\n            f\"a date within {self.start_date} and {self.end_date}\")\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IterableReader","title":"<code>IterableReader</code>","text":"<p>               Bases: <code>RawIOBase</code>, <code>LoggerMixin</code>, <code>ImmutableMixin</code></p> <p>I/O read-only stream over iterable of bytes, enabling streaming mode.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>@final\nclass IterableReader(RawIOBase, LoggerMixin, ImmutableMixin):\n    \"\"\"\n    I/O read-only stream over iterable of bytes, enabling streaming mode.\n    \"\"\"\n\n    def __init__(self, chunks: Iterable[bytes]):\n        self._chunks = iter(chunks)\n        self._accumulated_buffer = bytearray()\n\n    @override\n    def readable(self) -&gt; bool:\n        return True\n\n    @override\n    def readinto(self, output_buffer: memoryview) -&gt; int:  # type: ignore\n        # consume chunks, accumulating their bytes up to size of output buffer\n        while len(self._accumulated_buffer) &lt; len(output_buffer) \\\n                and (chunk := next(self._chunks, None)) is not None:\n            self.log.debug(f\"buffered chunk with length={len(chunk)}\")\n            self._accumulated_buffer.extend(chunk)\n\n        # consume accumulated bytes up to size of output buffer\n        consumed_bytes = min(len(self._accumulated_buffer), len(output_buffer))\n        output_buffer[:consumed_bytes] = self._accumulated_buffer[:consumed_bytes]\n\n        # delete consumed bytes, shifting left the accumulated buffer\n        del self._accumulated_buffer[:consumed_bytes]\n\n        self.log.debug(f\"consumed {consumed_bytes} bytes\")\n        return consumed_bytes\n\n    @staticmethod\n    def from_(\n            chunks: Iterable[bytes],\n            buffer_size: int = DEFAULT_BUFFER_SIZE) -&gt; BinaryIO:\n        \"\"\"\n        Converts a stream of binary chunks into a BufferedReader.\n\n        You should ensure closing.\n\n        Args:\n            chunks (Iterable[bytes]): stream of binary chunks\n\n        Returns:\n            io.BufferedReader: buffered reader around stream of binary chunks.\n        \"\"\"\n        return BufferedReader(IterableReader(chunks), buffer_size)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IterableReader.__init__","title":"<code>__init__(chunks)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>def __init__(self, chunks: Iterable[bytes]):\n    self._chunks = iter(chunks)\n    self._accumulated_buffer = bytearray()\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IterableReader.from_","title":"<code>from_(chunks, buffer_size=DEFAULT_BUFFER_SIZE)</code>  <code>staticmethod</code>","text":"<p>Converts a stream of binary chunks into a BufferedReader.</p> <p>You should ensure closing.</p> <p>Parameters:</p> Name Type Description Default <code>chunks</code> <code>Iterable[bytes]</code> <p>stream of binary chunks</p> required <p>Returns:</p> Type Description <code>BinaryIO</code> <p>io.BufferedReader: buffered reader around stream of binary chunks.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>@staticmethod\ndef from_(\n        chunks: Iterable[bytes],\n        buffer_size: int = DEFAULT_BUFFER_SIZE) -&gt; BinaryIO:\n    \"\"\"\n    Converts a stream of binary chunks into a BufferedReader.\n\n    You should ensure closing.\n\n    Args:\n        chunks (Iterable[bytes]): stream of binary chunks\n\n    Returns:\n        io.BufferedReader: buffered reader around stream of binary chunks.\n    \"\"\"\n    return BufferedReader(IterableReader(chunks), buffer_size)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IterableReader.readable","title":"<code>readable()</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>@override\ndef readable(self) -&gt; bool:\n    return True\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IterableReader.readinto","title":"<code>readinto(output_buffer)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>@override\ndef readinto(self, output_buffer: memoryview) -&gt; int:  # type: ignore\n    # consume chunks, accumulating their bytes up to size of output buffer\n    while len(self._accumulated_buffer) &lt; len(output_buffer) \\\n            and (chunk := next(self._chunks, None)) is not None:\n        self.log.debug(f\"buffered chunk with length={len(chunk)}\")\n        self._accumulated_buffer.extend(chunk)\n\n    # consume accumulated bytes up to size of output buffer\n    consumed_bytes = min(len(self._accumulated_buffer), len(output_buffer))\n    output_buffer[:consumed_bytes] = self._accumulated_buffer[:consumed_bytes]\n\n    # delete consumed bytes, shifting left the accumulated buffer\n    del self._accumulated_buffer[:consumed_bytes]\n\n    self.log.debug(f\"consumed {consumed_bytes} bytes\")\n    return consumed_bytes\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.LoggerMixin","title":"<code>LoggerMixin</code>","text":"<p>Mixin that provides a <code>log</code> property for convenient class-based logging.</p> <p>Inherit from this mixin to get a <code>self.log</code> logger named after the class. Useful for adding debug/info/error logging to any class without boilerplate.</p> Example <p>class MyClass(LoggerMixin):     def do_something(self):         self.log.info(\"Doing something\")</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/logger.py</code> <pre><code>class LoggerMixin:\n    \"\"\"\n    Mixin that provides a `log` property for convenient class-based logging.\n\n    Inherit from this mixin to get a `self.log` logger named after the class.\n    Useful for adding debug/info/error logging to any class without boilerplate.\n\n    Example:\n        class MyClass(LoggerMixin):\n            def do_something(self):\n                self.log.info(\"Doing something\")\n    \"\"\"\n    @final\n    @cached_property\n    def log(self) -&gt; logging.Logger:\n        return logging.getLogger(self.__class__.__name__)\n\n    @final\n    def trace[T](self, value: T) -&gt; T:\n        \"\"\"\n        Logs value at DEBUG level using this logger.\n\n        Use to log something as a value, usually in a lambda expression::\n\n            then.eventually_assert_that(\n                lambda: self.trace(...call some API...),\n                greater_that(0)) \\\n\n                .and_....other verifications may follow...\n\n        Args:\n            value (T): the value\n\n        Returns:\n            T: the value\n        \"\"\"\n        self.log.debug(f\"=== {value}\")\n        return value\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.LoggerMixin.log","title":"<code>log</code>  <code>cached</code> <code>property</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.LoggerMixin.trace","title":"<code>trace(value)</code>","text":"<p>Logs value at DEBUG level using this logger.</p> <p>Use to log something as a value, usually in a lambda expression::</p> <pre><code>then.eventually_assert_that(\n    lambda: self.trace(...call some API...),\n    greater_that(0)) \n    .and_....other verifications may follow...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>the value</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>the value</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/logger.py</code> <pre><code>@final\ndef trace[T](self, value: T) -&gt; T:\n    \"\"\"\n    Logs value at DEBUG level using this logger.\n\n    Use to log something as a value, usually in a lambda expression::\n\n        then.eventually_assert_that(\n            lambda: self.trace(...call some API...),\n            greater_that(0)) \\\n\n            .and_....other verifications may follow...\n\n    Args:\n        value (T): the value\n\n    Returns:\n        T: the value\n    \"\"\"\n    self.log.debug(f\"=== {value}\")\n    return value\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.SingletonBase","title":"<code>SingletonBase</code>","text":"<p>Base class for singletons using SingletonMeta.</p> <p>Inherit from this class to make your class a singleton.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>class SingletonBase(metaclass=SingletonMeta):\n    \"\"\"\n    Base class for singletons using SingletonMeta.\n\n    Inherit from this class to make your class a singleton.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.SingletonMeta","title":"<code>SingletonMeta</code>","text":"<p>               Bases: <code>type</code></p> <p>Thread-safe singleton metaclass.</p> <p>Ensures only one instance of a class exists per process. Use by setting <code>metaclass=SingletonMeta</code> on your class.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>@final\nclass SingletonMeta(type):\n    \"\"\"\n    Thread-safe singleton metaclass.\n\n    Ensures only one instance of a class exists per process.\n    Use by setting `metaclass=SingletonMeta` on your class.\n    \"\"\"\n    _instances: ClassVar[Dict[type, object]] = {}\n    _lock: ClassVar[threading.Lock] = threading.Lock()  # Ensure thread-safety\n\n    def __call__(\n            cls: type,\n            *args: Any, **kwargs: Any) -&gt; \"SingletonBase\":\n        with SingletonMeta._lock:\n            if cls not in SingletonMeta._instances:\n                instance = super().__call__(*args, **kwargs)  # type: ignore\n                SingletonMeta._instances[cls] = instance\n        return SingletonMeta._instances[cls]  # type: ignore[return-value]\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.SingletonMeta.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>def __call__(\n        cls: type,\n        *args: Any, **kwargs: Any) -&gt; \"SingletonBase\":\n    with SingletonMeta._lock:\n        if cls not in SingletonMeta._instances:\n            instance = super().__call__(*args, **kwargs)  # type: ignore\n            SingletonMeta._instances[cls] = instance\n    return SingletonMeta._instances[cls]  # type: ignore[return-value]\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.TestException","title":"<code>TestException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Marks an exception raised by tests infrastructure. Useful to differentiate between unexpected run-time exceptions, which should be handled as programming errors, and legitimate run-time exceptions such as time-out, not found, etc. The former might be handled via a retry mechanism.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/exceptions.py</code> <pre><code>class TestException(Exception):\n    \"\"\"\n    Marks an exception raised by tests infrastructure. Useful to differentiate\n    between unexpected run-time exceptions, which should be handled as\n    programming errors, and legitimate run-time exceptions such as time-out,\n    not found, etc. The former might be handled via a retry mechanism.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ThreadLocal","title":"<code>ThreadLocal</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/thread_utils.py</code> <pre><code>class ThreadLocal[T]:\n    def __init__(self, default: T):\n        self._local = local()\n        self._local.value = default\n\n    def set(self, value: T) -&gt; None:\n        self._local.value = value\n\n    def get(self) -&gt; T:\n        return cast(T, self._local.value)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ThreadLocal.__init__","title":"<code>__init__(default)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/thread_utils.py</code> <pre><code>def __init__(self, default: T):\n    self._local = local()\n    self._local.value = default\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ThreadLocal.get","title":"<code>get()</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/thread_utils.py</code> <pre><code>def get(self) -&gt; T:\n    return cast(T, self._local.value)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ThreadLocal.set","title":"<code>set(value)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/thread_utils.py</code> <pre><code>def set(self, value: T) -&gt; None:\n    self._local.value = value\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ToDictMixin","title":"<code>ToDictMixin</code>","text":"<p>Mixin to add serialization methods to dataclasses.</p> Provides <ul> <li>to_dict(): Recursively converts a dataclass (and nested dataclasses) to a dictionary.</li> <li>flatten(): Flattens nested structure for CSV or flat serialization.</li> </ul> Example <p>@dataclass class User(ToDictMixin):     name: str     age: int</p> <p>user = User(\"Alice\", 30) user.to_dict()  # {'name': 'Alice', 'age': 30}</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>class ToDictMixin:\n    \"\"\"\n    Mixin to add serialization methods to dataclasses.\n\n    Provides:\n        - to_dict(): Recursively converts a dataclass (and nested dataclasses) to a dictionary.\n        - flatten(): Flattens nested structure for CSV or flat serialization.\n\n    Example:\n        @dataclass\n        class User(ToDictMixin):\n            name: str\n            age: int\n\n        user = User(\"Alice\", 30)\n        user.to_dict()  # {'name': 'Alice', 'age': 30}\n    \"\"\"\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts a dataclass instance (with nested dataclasses) to a dictionary.\n        \"\"\"\n        from typing import cast\n\n        def convert(value: Any) -&gt; Any:\n            if isinstance(value, ToDictMixin):\n                return value.to_dict()\n            elif isinstance(value, list):\n                # Provide a type hint for v\n                return [convert(v) for v in cast(list[Any], value)]\n            elif isinstance(value, dict):\n                return {k: convert(v) for k, v in value.items()}  # type: ignore\n            return value\n\n        if not is_dataclass(self):\n            raise TypeError(\"not a dataclass instance\")\n\n        return {key: convert(value) for key, value in asdict(self).items()}\n\n    def flatten(self, prefix: str = \"\") -&gt; Dict[str, Any]:\n        \"\"\"\n        Flattens the nested structure into a flat dictionary for CSV serialization.\n        \"\"\"\n        flat_dict: Dict[str, Any] = {}\n\n        def flatten_value(key: str, value: Any) -&gt; None:\n            if isinstance(value, ToDictMixin):\n                # Flatten nested ToDictMixin dataclasses\n                nested_flat = value.flatten(prefix=f\"{key}_\")\n                flat_dict.update(nested_flat)\n            elif isinstance(value, list):\n                # Serialize lists as JSON strings or expand into multiple columns\n                for idx, item in enumerate(value):  # type: ignore\n                    flat_dict[f\"{key}[{idx}]\"] = item\n            elif isinstance(value, dict):\n                # Serialize dicts as JSON strings or expand into multiple columns\n                for sub_key, sub_val in value.items():  # type: ignore\n                    flat_dict[f\"{key}_{sub_key}\"] = sub_val\n            else:\n                # Directly add non-nested fields\n                flat_dict[key] = value\n\n        if not is_dataclass(self):\n            raise TypeError(\"not a dataclass instance\")\n\n        for field in fields(self):\n            value = getattr(self, field.name)\n            flatten_value(f\"{prefix}{field.name}\", value)\n\n        return flat_dict\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ToDictMixin.flatten","title":"<code>flatten(prefix='')</code>","text":"<p>Flattens the nested structure into a flat dictionary for CSV serialization.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>def flatten(self, prefix: str = \"\") -&gt; Dict[str, Any]:\n    \"\"\"\n    Flattens the nested structure into a flat dictionary for CSV serialization.\n    \"\"\"\n    flat_dict: Dict[str, Any] = {}\n\n    def flatten_value(key: str, value: Any) -&gt; None:\n        if isinstance(value, ToDictMixin):\n            # Flatten nested ToDictMixin dataclasses\n            nested_flat = value.flatten(prefix=f\"{key}_\")\n            flat_dict.update(nested_flat)\n        elif isinstance(value, list):\n            # Serialize lists as JSON strings or expand into multiple columns\n            for idx, item in enumerate(value):  # type: ignore\n                flat_dict[f\"{key}[{idx}]\"] = item\n        elif isinstance(value, dict):\n            # Serialize dicts as JSON strings or expand into multiple columns\n            for sub_key, sub_val in value.items():  # type: ignore\n                flat_dict[f\"{key}_{sub_key}\"] = sub_val\n        else:\n            # Directly add non-nested fields\n            flat_dict[key] = value\n\n    if not is_dataclass(self):\n        raise TypeError(\"not a dataclass instance\")\n\n    for field in fields(self):\n        value = getattr(self, field.name)\n        flatten_value(f\"{prefix}{field.name}\", value)\n\n    return flat_dict\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ToDictMixin.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts a dataclass instance (with nested dataclasses) to a dictionary.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts a dataclass instance (with nested dataclasses) to a dictionary.\n    \"\"\"\n    from typing import cast\n\n    def convert(value: Any) -&gt; Any:\n        if isinstance(value, ToDictMixin):\n            return value.to_dict()\n        elif isinstance(value, list):\n            # Provide a type hint for v\n            return [convert(v) for v in cast(list[Any], value)]\n        elif isinstance(value, dict):\n            return {k: convert(v) for k, v in value.items()}  # type: ignore\n        return value\n\n    if not is_dataclass(self):\n        raise TypeError(\"not a dataclass instance\")\n\n    return {key: convert(value) for key, value in asdict(self).items()}\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.TracingMatcher","title":"<code>TracingMatcher</code>","text":"<p>               Bases: <code>BaseMatcher[T]</code>, <code>LoggerMixin</code></p> <p>A matcher wrapper that adds debug logging around another matcher.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>class TracingMatcher[T](BaseMatcher[T], LoggerMixin):\n    \"\"\"\n    A matcher wrapper that adds debug logging around another matcher.\n    \"\"\"\n\n    def __init__(self, matcher: Matcher[T]) -&gt; None:\n        self._matcher = matcher\n\n    def _matches(self, item: Any) -&gt; bool:\n        result = self._matcher.matches(item)\n        self.log.debug(f\"{item!r} -&gt; {result}\")\n        return result\n\n    def describe_to(self, description: Description) -&gt; None:\n        self._matcher.describe_to(description)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.TracingMatcher.__init__","title":"<code>__init__(matcher)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def __init__(self, matcher: Matcher[T]) -&gt; None:\n    self._matcher = matcher\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.TracingMatcher.describe_to","title":"<code>describe_to(description)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def describe_to(self, description: Description) -&gt; None:\n    self._matcher.describe_to(description)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.Valid","title":"<code>Valid</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Specifies a method for validating objects.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>@runtime_checkable\nclass Valid(Protocol):\n    \"\"\"\n    Specifies a method for validating objects.\n    \"\"\"\n\n    def is_valid(self) -&gt; bool:\n        \"\"\"\n        Should be implemented by objects that need validation.\n\n        Returns:\n            bool: true, if the object is valid\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.Valid.is_valid","title":"<code>is_valid()</code>","text":"<p>Should be implemented by objects that need validation.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true, if the object is valid</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>def is_valid(self) -&gt; bool:\n    \"\"\"\n    Should be implemented by objects that need validation.\n\n    Returns:\n        bool: true, if the object is valid\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.WithMixin","title":"<code>WithMixin</code>","text":"<p>Mixin to support copy-on-change (functional update) for objects.</p> <p>Instead of mutating an object, use <code>with_()</code> to create a copy with updated fields:     obj2 = obj.with_(field=new_value)</p> <p>Works with both plain Python classes and dataclasses.</p> Example <p>@dataclass(frozen=True) class Point(WithMixin):     x: int     y: int</p> <p>p1 = Point(1, 2) p2 = p1.with_(x=3)  # p2 is Point(3, 2)</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>class WithMixin:\n    '''\n    Mixin to support copy-on-change (functional update) for objects.\n\n    Instead of mutating an object, use `with_()` to create a copy with updated fields:\n        obj2 = obj.with_(field=new_value)\n\n    Works with both plain Python classes and dataclasses.\n\n    Example:\n        @dataclass(frozen=True)\n        class Point(WithMixin):\n            x: int\n            y: int\n\n        p1 = Point(1, 2)\n        p2 = p1.with_(x=3)  # p2 is Point(3, 2)\n    '''\n    @final\n    def with_[T:WithMixin](self: T, **changes: Any) -&gt; T:\n        if is_dataclass(self):\n            # Directly use replace for dataclasses; it will raise an error for invalid fields\n            return replace(self, **changes)\n\n        duplicated_object = self.__class__(**self.__dict__)\n        for key, value in changes.items():\n            # Get the current attribute to determine its type\n            current_attr = getattr(self, key, None)\n            if isinstance(current_attr, Enum):\n                # If the current attribute is an enum,\n                # convert the value to the corresponding enum\n                value = current_attr.__class__(value)\n            setattr(duplicated_object, key, value)\n        return duplicated_object\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.WithMixin.with_","title":"<code>with_(**changes)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>@final\ndef with_[T:WithMixin](self: T, **changes: Any) -&gt; T:\n    if is_dataclass(self):\n        # Directly use replace for dataclasses; it will raise an error for invalid fields\n        return replace(self, **changes)\n\n    duplicated_object = self.__class__(**self.__dict__)\n    for key, value in changes.items():\n        # Get the current attribute to determine its type\n        current_attr = getattr(self, key, None)\n        if isinstance(current_attr, Enum):\n            # If the current attribute is an enum,\n            # convert the value to the corresponding enum\n            value = current_attr.__class__(value)\n        setattr(duplicated_object, key, value)\n    return duplicated_object\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.classproperty","title":"<code>classproperty</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>@final\nclass classproperty[T]:\n    def __init__(self, fget: Callable[[Any], T]) -&gt; None:\n        self.fget = fget\n\n    def __get__(self, instance: Any, owner: Any) -&gt; T:\n        return self.fget(owner)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.classproperty.fget","title":"<code>fget = fget</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.classproperty.__get__","title":"<code>__get__(instance, owner)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>def __get__(self, instance: Any, owner: Any) -&gt; T:\n    return self.fget(owner)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.classproperty.__init__","title":"<code>__init__(fget)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>def __init__(self, fget: Callable[[Any], T]) -&gt; None:\n    self.fget = fget\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.adapted_iterator","title":"<code>adapted_iterator(converter, matcher)</code>","text":"<p>Hamcrest matcher adapting an Iterator of type T by specified converter and applying specified matcher. For example::</p> <pre><code>adapt_iterator( lambda message: message.id,\n            yields_item(is_greater_than(0)) )\n</code></pre> <p>where id being a number, and is_greater_than being a matcher that can be applied on numbers.</p> <p>See more on <code>PyHamcrest &lt;https://github.com/hamcrest/PyHamcrest&gt;</code></p> <p>Parameters:</p> Name Type Description Default <code>converter</code> <code>Callable[[T], R]</code> <p>function converting T into R</p> required <code>matcher</code> <code>Matcher[Iterator[R]</code> <p>matcher for adapted Iterator of R</p> required <p>Returns:</p> Type Description <code>Matcher[Iterator[T]]</code> <p>Matcher[Iterator[T]]: matcher for target Iterator of type T</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def adapted_iterator[T, R](\n        converter: Callable[[T], R],\n        matcher: Matcher[Iterator[R]]) -&gt; Matcher[Iterator[T]]:\n    \"\"\"\n    Hamcrest matcher adapting an Iterator of type T by specified converter and\n    applying specified matcher. For example::\n\n        adapt_iterator( lambda message: message.id,\n                    yields_item(is_greater_than(0)) )\n\n    where id being a number, and is_greater_than being a matcher that can be\n    applied on numbers.\n\n    See more on `PyHamcrest &lt;https://github.com/hamcrest/PyHamcrest&gt;`\n\n    Args:\n        converter (Callable[[T], R]): function converting T into R\n        matcher (Matcher[Iterator[R]): matcher for adapted Iterator of R\n\n    Returns:\n        Matcher[Iterator[T]]: matcher for target Iterator of type T\n    \"\"\"\n    @final\n    class AdaptedMatcher(BaseMatcher[Iterator[T]]):\n        @override\n        def _matches(self, item: Iterable[T]) -&gt; bool:\n            return matcher.matches(map(converter, item))\n\n        @override\n        def describe_to(self, description: Description) -&gt; None:\n            description.append_description_of(matcher)\n\n    return AdaptedMatcher()\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.adapted_object","title":"<code>adapted_object(converter, matcher)</code>","text":"<p>Hamcrest matcher adapting an object of type T by specified converter and applying specified matcher. For example::</p> <pre><code>adapt_object( lambda message: message.id,\n            is_greater_than(0) )\n</code></pre> <p>where id being a number, and is_greater_than being a matcher that can be applied on numbers.</p> <p>See more on <code>PyHamcrest &lt;https://github.com/hamcrest/PyHamcrest&gt;</code></p> <p>Parameters:</p> Name Type Description Default <code>converter</code> <code>Callable[[T], R]</code> <p>function converting T into R</p> required <code>matcher</code> <code>Matcher[R]</code> <p>matcher for adapted type R</p> required <p>Returns:</p> Type Description <code>Matcher[T]</code> <p>Matcher[T]: matcher for target type T</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def adapted_object[T, R](\n        converter: Callable[[T], R],\n        matcher: Matcher[R]) -&gt; Matcher[T]:\n    \"\"\"\n    Hamcrest matcher adapting an object of type T by specified converter and\n    applying specified matcher. For example::\n\n        adapt_object( lambda message: message.id,\n                    is_greater_than(0) )\n\n    where id being a number, and is_greater_than being a matcher that can be\n    applied on numbers.\n\n    See more on `PyHamcrest &lt;https://github.com/hamcrest/PyHamcrest&gt;`\n\n    Args:\n        converter (Callable[[T], R]): function converting T into R\n        matcher (Matcher[R]): matcher for adapted type R\n\n    Returns:\n        Matcher[T]: matcher for target type T\n    \"\"\"\n    @final\n    class AdaptedMatcher(BaseMatcher[T]):\n        @override\n        def _matches(self, item: T) -&gt; bool:\n            return False if item is None \\\n                else matcher.matches(converter(item))\n\n        @override\n        def describe_to(self, description: Description) -&gt; None:\n            description.append_description_of(matcher)\n\n    return AdaptedMatcher()\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.adapted_sequence","title":"<code>adapted_sequence(converter, matcher)</code>","text":"<p>Hamcrest matcher adapting a Sequence of type T by specified converter and applying specified matcher. For example::</p> <pre><code>adapt_sequence( lambda message: message.id,\n            has_item(is_greater_than(0)) )\n</code></pre> <p>where id being a number, and is_greater_than being a matcher that can be applied on numbers.</p> <p>See more on <code>PyHamcrest &lt;https://github.com/hamcrest/PyHamcrest&gt;</code></p> <p>Parameters:</p> Name Type Description Default <code>converter</code> <code>Callable[[T], R]</code> <p>function converting T into R</p> required <code>matcher</code> <code>Matcher[Sequence[R]</code> <p>matcher for adapted Sequence of R</p> required <p>Returns:</p> Type Description <code>Matcher[Sequence[T]]</code> <p>Matcher[Sequence[T]]: matcher for target Sequence of type T</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def adapted_sequence[T, R](\n        converter: Callable[[T], R],\n        matcher: Matcher[Sequence[R]]) -&gt; Matcher[Sequence[T]]:\n    \"\"\"\n    Hamcrest matcher adapting a Sequence of type T by specified converter and\n    applying specified matcher. For example::\n\n        adapt_sequence( lambda message: message.id,\n                    has_item(is_greater_than(0)) )\n\n    where id being a number, and is_greater_than being a matcher that can be\n    applied on numbers.\n\n    See more on `PyHamcrest &lt;https://github.com/hamcrest/PyHamcrest&gt;`\n\n    Args:\n        converter (Callable[[T], R]): function converting T into R\n        matcher (Matcher[Sequence[R]): matcher for adapted Sequence of R\n\n    Returns:\n        Matcher[Sequence[T]]: matcher for target Sequence of type T\n    \"\"\"\n    @final\n    class AdaptedMatcher(BaseMatcher[Sequence[T]]):\n        @override\n        def _matches(self, item: Sequence[T]) -&gt; bool:\n            return matcher.matches([converter(x) for x in item])\n\n        @override\n        def describe_to(self, description: Description) -&gt; None:\n            description.append_description_of(matcher)\n\n    return AdaptedMatcher()\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.configure","title":"<code>configure(config, path=Path(__file__).parent / 'logging.ini')</code>","text":"<p>Configures logging for pytest using a specified INI file, or defaults to internal logging.ini.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/conftest_helpers.py</code> <pre><code>def configure(config: pytest.Config,\n              path: Path = Path(__file__).parent / \"logging.ini\") -&gt; None:\n    \"\"\"\n    Configures logging for pytest using a specified INI file, or defaults to internal logging.ini.\n    \"\"\"\n    caller_module = inspect.getmodule(inspect.stack()[1][0])\n    module_name = caller_module.__name__ if caller_module else \"unknown\"\n\n    if path.is_file():\n        logging.config.fileConfig(path)\n        logging.info(f\"{module_name} loaded logs config from: {path}\")\n    else:\n        sys.stderr.write(f\"{module_name} couldn't find logs config file {path}\")\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.contains_string_ignoring_case","title":"<code>contains_string_ignoring_case(substring)</code>","text":"<p>Creates a matcher that checks if a given string contains the specified substring, ignoring case.</p> <p>Parameters:</p> Name Type Description Default <code>substring</code> <code>str</code> <p>The substring to search for within the target string, case-insensitively.</p> required <p>Returns:</p> Name Type Description <code>ContainsStringIgnoringCase</code> <code>ContainsStringIgnoringCase</code> <p>A matcher object that evaluates whether the target string contains the specified substring, ignoring case.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def contains_string_ignoring_case(substring: str) -&gt; ContainsStringIgnoringCase:\n    \"\"\"\n    Creates a matcher that checks if a given string contains the specified substring, ignoring case.\n\n    Args:\n        substring (str): The substring to search for within the target string, case-insensitively.\n\n    Returns:\n        ContainsStringIgnoringCase: A matcher object that evaluates whether the target string contains the specified substring, ignoring case.\n    \"\"\"\n    return ContainsStringIgnoringCase(substring)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.crc32_of","title":"<code>crc32_of(file, chunk_size=DEFAULT_BUFFER_SIZE)</code>","text":"<p>Calculate the CRC of a binary stream from its current position to its tail, using chunked reading.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>BinaryIO</code> <p>The file object to read data from, starting from its current position.</p> required <code>chunk_size</code> <code>int</code> <p>The size of chunks to read at a time (default is 8192).</p> <code>DEFAULT_BUFFER_SIZE</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Calculated CRC value of the remaining file content.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>def crc32_of(file: BinaryIO, chunk_size: int = DEFAULT_BUFFER_SIZE) -&gt; int:\n    \"\"\"\n    Calculate the CRC of a binary stream from its current position to its tail,\n    using chunked reading.\n\n    Args:\n        file (BinaryIO): The file object to read data from, starting from its current position.\n        chunk_size (int): The size of chunks to read at a time (default is 8192).\n\n    Returns:\n        int: Calculated CRC value of the remaining file content.\n    \"\"\"\n    crc_value = 0\n\n    while chunk := file.read(chunk_size):\n        crc_value = crc32(chunk, crc_value)\n\n    return crc_value &amp; 0xFFFFFFFF  # ensure 32-bit unsigned\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.decompress_xz_stream","title":"<code>decompress_xz_stream(compressed_chunks)</code>","text":"<p>Decompresses XZ stream.</p> <p>Parameters:</p> Name Type Description Default <code>compressed_chunks</code> <code>Iterable[bytes]</code> <p>stream of binary compressed chunks</p> required <p>Yields:</p> Type Description <code>bytes</code> <p>Iterator[bytes]: the decompressed stream</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>def decompress_xz_stream(compressed_chunks: Iterable[bytes]) -&gt; Iterator[bytes]:\n    \"\"\"\n    Decompresses XZ stream.\n\n    Args:\n        compressed_chunks (Iterable[bytes]): stream of binary compressed chunks\n\n    Yields:\n        Iterator[bytes]: the decompressed stream\n    \"\"\"\n    decompressor = LZMADecompressor()\n    return map(decompressor.decompress, compressed_chunks)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.extract_files_from_tar","title":"<code>extract_files_from_tar(tar_chunks)</code>","text":"<p>Extracts files from decompressed TAR stream.</p> <p>Parameters:</p> Name Type Description Default <code>tar_chunks</code> <code>Iterable[bytes]</code> <p>stream of decompressed TAR chunks</p> required <p>Yields:</p> Type Description <code>Tuple[TarInfo, bytes]</code> <p>Iterator[Tuple[tarfile.TarInfo, bytes]]:             streams tuples of meta-data and data for each file</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>def extract_files_from_tar(tar_chunks: Iterable[bytes]) -&gt; Iterator[Tuple[TarInfo, bytes]]:\n    \"\"\"\n    Extracts files from decompressed TAR stream.\n\n    Args:\n        tar_chunks (Iterable[bytes]): stream of decompressed TAR chunks\n\n    Yields:\n        Iterator[Tuple[tarfile.TarInfo, bytes]]: \\\n            streams tuples of meta-data and data for each file\n    \"\"\"\n    with open(fileobj=IterableReader.from_(tar_chunks),\n              mode='r|*') as tar:\n        for member in tar:\n            if member.isfile():\n                extracted_file = tar.extractfile(member)\n                if extracted_file:\n                    yield member, extracted_file.read()\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.get_test_body","title":"<code>get_test_body(item)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/conftest_helpers.py</code> <pre><code>def get_test_body(item: pytest.Item) -&gt; str:\n    function: Optional[Callable[..., None]] = getattr(item, 'function', None)\n    if function is None:\n        return \"No function found for this test item.\"\n\n    try:\n        return inspect.getsource(function)\n    except Exception as e:\n        return f\"Could not get source code: {str(e)}\"\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.makereport","title":"<code>makereport(item, call)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/conftest_helpers.py</code> <pre><code>def makereport(\n        item: pytest.Item, call: pytest.CallInfo[None]) -&gt; pytest.TestReport:\n    report = pytest.TestReport.from_item_and_call(item, call)\n\n    if call.when == \"call\":\n        report.sections.append(('body', get_test_body(item)))\n\n    return report\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.match_as","title":"<code>match_as(matcher)</code>","text":"<p>Utility function to cast a generic matcher to the specific type Matcher[T].</p> <p>Parameters:</p> Name Type Description Default <code>matcher</code> <code>Matcher[object]</code> <p>The original matcher that needs to be cast.</p> required <p>Returns:</p> Type Description <code>Matcher[T]</code> <p>A matcher cast to Matcher[T].</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def match_as[T](matcher: Matcher[object]) -&gt; Matcher[T]:  # type: ignore\n    \"\"\"\n    Utility function to cast a generic matcher to the specific type Matcher[T].\n\n    Args:\n        matcher: The original matcher that needs to be cast.\n\n    Returns:\n        A matcher cast to Matcher[T].\n    \"\"\"\n    return cast(Matcher[T], matcher)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.process_next","title":"<code>process_next(i, p)</code>","text":"<p>Processes next items per specified predicate. Useful for cases in which the first item in a stream decides the meaning of the rest of the items.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>Iterator[T]</code> <p>the iterator to process</p> required <code>p</code> <code>Predicate[T]</code> <p>the predicate to be applied on <code>next(i)</code></p> required <p>Returns:</p> Type Description <code>Iterator[T]</code> <p>Iterator[T]: the original iterator if the predicate evaluated true,             otherwise empty iterator</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/stream_utils.py</code> <pre><code>def process_next[T](i: Iterator[T], p: Predicate[T]) -&gt; Iterator[T]:\n    \"\"\"\n    Processes next items per specified predicate. Useful for cases in which\n    the first item in a stream decides the meaning of the rest of the items.\n\n    Args:\n        i (Iterator[T]): the iterator to process\n        p (Predicate[T]): the predicate to be applied on `next(i)`\n\n    Returns:\n        Iterator[T]: the original iterator if the predicate evaluated true, \\\n            otherwise empty iterator\n    \"\"\"\n    return i if p(next(i)) else iter([])\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.read_lines","title":"<code>read_lines(byte_stream, encoding=UTF_8, eol=LF)</code>","text":"<p>Converts a stream of binary chunks into stream of text lines. Handles cases where lines are split across chunks.</p> <p>Parameters:</p> Name Type Description Default <code>byte_stream</code> <code>Iterable[bytes]</code> <p>the binary (chunks) stream</p> required <code>encoding</code> <code>str</code> <p>expected text encoding. Defaults to 'utf-8'.</p> <code>UTF_8</code> <code>eol</code> <code>str</code> <p>expected line-ending. Default to LF.</p> <code>LF</code> <p>Yields:</p> Type Description <code>str</code> <p>Iterator[str]: stream of text lines, not terminated by EOL marker</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>def read_lines(\n        byte_stream: Iterable[bytes],\n        encoding: str = UTF_8,\n        eol: str = LF) -&gt; Iterator[str]:\n    \"\"\"\n    Converts a stream of binary chunks into stream of text lines.\n    Handles cases where lines are split across chunks.\n\n    Args:\n        byte_stream (Iterable[bytes]): the binary (chunks) stream\n        encoding (str, optional): expected text encoding. Defaults to 'utf-8'.\n        eol (str, optional): expected line-ending. Default to LF.\n\n    Yields:\n        Iterator[str]: stream of text lines, not terminated by EOL marker\n    \"\"\"\n    has_content = False\n    buffer = bytearray()\n    eol_bytes = eol.encode(encoding)\n\n    for chunk in byte_stream:\n        print(DOT, end=SPACE)\n        has_content = True\n        buffer.extend(chunk)\n        *lines, buffer = buffer.split(eol_bytes)  # keep partial line in buffer\n        trace(f\"streaming {len(lines)} lines; leftover {len(buffer)} chars\")\n        yield from (line.decode(encoding) for line in lines)\n\n    if buffer:  # yield the leftover\n        yield buffer.decode(encoding)\n\n    if not has_content:\n        trace(\"no lines\")\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.require_not_none","title":"<code>require_not_none(value, message='Value must not be None')</code>","text":"<p>Ensures that the provided value is not None.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Optional[T]</code> <p>The value to check for None.</p> required <code>message</code> <code>str</code> <p>The error message to use if value is None. Defaults to \"Value must not be None\".</p> <code>'Value must not be None'</code> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The value, guaranteed to be not None.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If value is None.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>def require_not_none[T](\n        value: Optional[T],\n        message: str = \"Value must not be None\") -&gt; T:\n    \"\"\"\n    Ensures that the provided value is not None.\n\n    Args:\n        value (Optional[T]): The value to check for None.\n        message (str, optional): The error message to use if value is None. Defaults to \"Value must not be None\".\n\n    Returns:\n        T: The value, guaranteed to be not None.\n\n    Raises:\n        ValueError: If value is None.\n    \"\"\"\n    if value is None:\n        raise ValueError(message)\n    return value\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.safely","title":"<code>safely(supplier)</code>","text":"<p>Calls a function safely, wrapping its result in Maybe, and swallowing any exceptions. The function should be a no-argument callable::</p> <pre><code>safely(lambda: call_something_that_may_fail(params))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>supplier</code> <code>Supplier[T]</code> <p>The supplier to be called.</p> required <p>Returns:</p> Type Description <code>Maybe[T]</code> <p>Maybe[T]: The result wrapped in Maybe, or Nothing if an exception occurs.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/exception_utils.py</code> <pre><code>def safely[T](supplier: Supplier[T]) -&gt; Maybe[T]:\n    \"\"\"\n    Calls a function safely, wrapping its result in Maybe, and swallowing any exceptions.\n    The function should be a no-argument callable::\n\n        safely(lambda: call_something_that_may_fail(params))\n\n    Args:\n        supplier (Supplier[T]): The supplier to be called.\n\n    Returns:\n        Maybe[T]: The result wrapped in Maybe, or Nothing if an exception occurs.\n    \"\"\"\n    try:\n        return Some(supplier())\n    except Exception as e:\n        logging.exception(f\"Exception occurred: {e}\")\n        return Nothing\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.sleep_for","title":"<code>sleep_for(duration)</code>","text":"<p>Sleep for the specified duration. Args:     duration (timedelta): The amount of time to sleep.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/thread_utils.py</code> <pre><code>def sleep_for(duration: timedelta):\n    \"\"\"\n    Sleep for the specified duration.\n    Args:\n        duration (timedelta): The amount of time to sleep.\n    \"\"\"\n    time.sleep(duration.total_seconds())\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.stream_file","title":"<code>stream_file(file_path, chunk_size=DEFAULT_BUFFER_SIZE)</code>","text":"<p>Streams a binary file from disk into an iterator.</p> <p>If the iterator is not consumed, the file will be closed when the iterator will be garbage collected.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>path to file</p> required <code>chunk_size</code> <code>int</code> <p>the chunk size. Defaults to 8192.</p> <code>DEFAULT_BUFFER_SIZE</code> <p>Yields:</p> Type Description <code>bytes</code> <p>Iterator[bytes]: the binary chunks stream</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>def stream_file(\n        file_path: Path,\n        chunk_size: int = DEFAULT_BUFFER_SIZE) -&gt; Iterator[bytes]:\n    \"\"\"\n    Streams a binary file from disk into an iterator.\n\n    If the iterator is not consumed, the file will be closed when the iterator\n    will be garbage collected.\n\n    Args:\n        file_path (Path): path to file\n        chunk_size (int, optional): the chunk size. Defaults to 8192.\n\n    Yields:\n        Iterator[bytes]: the binary chunks stream\n    \"\"\"\n    with file_path.open('rb') as f:\n        yield from iter(lambda: f.read(chunk_size), EMPTY_BYTES)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.swallow","title":"<code>swallow(func)</code>","text":"<p>Decorates a function to swallow any exceptions.</p> <p>If an exception will occur, None will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>the function, supplied by the run-time</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable[..., Any]</code> <p>the decorated function</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/exception_utils.py</code> <pre><code>def swallow(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n    \"\"\"\n    Decorates a function to swallow any exceptions.\n\n    If an exception will occur, None will be returned.\n\n    Args:\n        func (Callable): the function, supplied by the run-time\n\n    Returns:\n        Callable: the decorated function\n    \"\"\"\n    @functools.wraps(func)\n    def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n        return safely(lambda: func(*args, **kwargs)).value_or(None)\n\n    return wrapper\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.to_string","title":"<code>to_string(indent='    ', depth=1, width=72, seq_length=15, show_protected=False, show_private=False, show_static=False, show_properties=True, show_address=False, str_length=50)</code>","text":"<p>Class decorator providing a readable str implementation.</p> <p>The default Python str implementation, returns the type and the memory address of instance.</p> <p>Important for diagnostics, actually every object that is logged, must provide such readable str.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>str</code> <p>indentation; Defaults to '    '.</p> <code>'    '</code> <code>depth</code> <code>int</code> <p>depth in object hierarchy; defaults to 1.</p> <code>1</code> <code>width</code> <code>int</code> <p>width of line before line-feed; defaults to 72.</p> <code>72</code> <code>seq_length</code> <code>int</code> <p>how many items to include; defaults to 15.</p> <code>15</code> <code>show_protected</code> <code>bool</code> <p>include protected; Defaults to False.</p> <code>False</code> <code>show_private</code> <code>bool</code> <p>include private; defaults to False.</p> <code>False</code> <code>show_static</code> <code>bool</code> <p>include static; defaults to False.</p> <code>False</code> <code>show_properties</code> <code>bool</code> <p>include properties; defaults to True.</p> <code>True</code> <code>show_address</code> <code>bool</code> <p>include object's memory address; defaults to False.</p> <code>False</code> <code>str_length</code> <code>int</code> <p>maximum string length per item; defaults to 50.</p> <code>50</code> <p>Returns:</p> Type Description <code>Callable[[Type[T]], Type[T]]</code> <p>Callable[[Type[T]], Type[T]]: description</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/string_utils.py</code> <pre><code>def to_string[T](indent: str = '    ',\n                 depth: int = 1,\n                 width: int = 72,\n                 seq_length: int = 15,\n                 show_protected: bool = False,\n                 show_private: bool = False,\n                 show_static: bool = False,\n                 show_properties: bool = True,\n                 show_address: bool = False,\n                 str_length: int = 50) -&gt; Callable[[Type[T]], Type[T]]:\n    \"\"\"\n    Class decorator providing a readable __str__ implementation.\n\n    The default Python __str__ implementation, returns the type and the memory\n    address of instance.\n\n    Important for diagnostics, actually every object that is logged, must\n    provide such readable __str__.\n\n    Args:\n        indent (str, optional): indentation; Defaults to '    '.\n        depth (int, optional): depth in object hierarchy; defaults to 1.\n        width (int, optional): width of line before line-feed; defaults to 72.\n        seq_length (int, optional): how many items to include; defaults to 15.\n        show_protected (bool, optional): include protected; Defaults to False.\n        show_private (bool, optional): include private; defaults to False.\n        show_static (bool, optional): include static; defaults to False.\n        show_properties (bool, optional): include properties; defaults to True.\n        show_address (bool, optional): include object's memory address; defaults to False.\n        str_length (int, optional): maximum string length per item; defaults to 50.\n\n    Returns:\n        Callable[[Type[T]], Type[T]]: _description_\n    \"\"\"\n    def decorator(cls: Type[T]) -&gt; Type[T]:\n        def __str__(self: T) -&gt; str:\n            # IMPORTANT: must not use something that calls __str__\n            return ppretty(self,\n                           indent=indent,\n                           depth=depth,\n                           width=width,\n                           seq_length=seq_length,\n                           show_protected=show_protected,\n                           show_private=show_private,\n                           show_static=show_static,\n                           show_properties=show_properties,\n                           show_address=show_address,\n                           str_length=str_length)  # type: ignore\n\n        cls.__str__ = __str__\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.trace","title":"<code>trace(value)</code>","text":"<p>Logs at debug level using the invoking module name as the logger.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/logger.py</code> <pre><code>def trace[T](value: T) -&gt; T:\n    \"\"\"Logs at debug level using the invoking module name as the logger.\"\"\"\n    frame = inspect.currentframe()\n    try:\n        if frame is not None:\n            caller_frame = frame.f_back\n            if caller_frame is not None:\n                caller_module = inspect.getmodule(caller_frame)\n                logger_name = caller_module.__name__ if caller_module else '__main__'\n                logger = logging.getLogger(logger_name)\n                logger.debug(f\"=== {value}\")\n            else:\n                logging.getLogger(__name__).debug(f\"=== {value}\")\n        else:\n            logging.getLogger(__name__).debug(f\"=== {value}\")\n    finally:\n        del frame\n\n    return value\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.traced","title":"<code>traced(matcher)</code>","text":"<p>Wraps a matcher with TraceMatcher to enable debug logging.</p> Usage <p>assert_that(actual, trace(contains_string(\"hello\")))</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def traced[T](matcher: Matcher[T]) -&gt; TracingMatcher[T]:\n    \"\"\"\n    Wraps a matcher with TraceMatcher to enable debug logging.\n\n    Usage:\n        assert_that(actual, trace(contains_string(\"hello\")))\n    \"\"\"\n    return TracingMatcher(matcher)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.valid","title":"<code>valid(value)</code>","text":"<p>Validates specified object, assuming that it supports the Valid protocol.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>Valid): the object</p> required <p>Raises:</p> Type Description <code>InvalidValueException</code> <p>if the object is invalid</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>Valid: the validated object</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>def valid[T:Valid](value: T) -&gt; T:\n    \"\"\"\n    Validates specified object, assuming that it supports the Valid protocol.\n\n    Args:\n        value (T:Valid): the object\n\n    Raises:\n        InvalidValueException: if the object is invalid\n\n    Returns:\n        T:Valid: the validated object\n    \"\"\"\n    if value.is_valid():\n        return value\n\n    raise InvalidValueException(value)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.within_dates","title":"<code>within_dates(start_date, end_date)</code>","text":"<p>Creates an instance of IsWithinDates to check if a date or datetime value falls within the specified start and end dates.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>Optional[DateOrDateTime]</code> <p>The start of the date range. Can be None to indicate no lower bound.</p> required <code>end_date</code> <code>Optional[DateOrDateTime]</code> <p>The end of the date range. Can be None to indicate no upper bound.</p> required <p>Returns:</p> Name Type Description <code>IsWithinDates</code> <code>IsWithinDates</code> <p>An instance configured with the provided start and end dates.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def within_dates(\n        start_date: Optional[DateOrDateTime],\n        end_date: Optional[DateOrDateTime]) -&gt; IsWithinDates:\n    \"\"\"\n    Creates an instance of IsWithinDates to check if a date or datetime value falls within the specified start and end dates.\n\n    Args:\n        start_date (Optional[DateOrDateTime]): The start of the date range. Can be None to indicate no lower bound.\n        end_date (Optional[DateOrDateTime]): The end of the date range. Can be None to indicate no upper bound.\n\n    Returns:\n        IsWithinDates: An instance configured with the provided start and end dates.\n    \"\"\"\n    return IsWithinDates(start_date, end_date)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.write_csv","title":"<code>write_csv(file_path, data_stream)</code>","text":"<p>Writes a stream of flattened telemetry packets to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>Path to the CSV file to be written.</p> required <code>data_stream</code> <code>Iterable[dict[str, object]]</code> <p>Iterable of dictionaries representing the rows to be written.</p> required Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>def write_csv(file_path: Path, data_stream: Iterable[dict[str, object]]):\n    \"\"\"\n    Writes a stream of flattened telemetry packets to a CSV file.\n\n    Args:\n        file_path: Path to the CSV file to be written.\n        data_stream: Iterable of dictionaries representing the rows to be written.\n    \"\"\"\n    stream = peekable(data_stream)  # Allow peeking to extract headers\n    try:\n        first_row: dict[str, object] = stream.peek()\n    except StopIteration:\n        # No data to write\n        return\n    with file_path.open(mode=\"w\", newline=\"\") as csv_file:\n        writer = csv.DictWriter(\n            csv_file, fieldnames=list(first_row.keys()))\n        writer.writeheader()\n        writer.writerows(stream)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.yields_every","title":"<code>yields_every(match)</code>","text":"<p>Matches if every element yielded by the iterator matches a given matcher.</p> <p>:param match: The matcher to satisfy, or an expected value for equality matching.</p> <p>This matcher iterates through the evaluated iterator, checking that every element satisfies the given matcher. If any element does not match, the matcher fails.</p> <p>If the <code>match</code> argument is not a matcher, it is implicitly wrapped in an equality matcher.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def yields_every[T](match: Union[Matcher[T], T]) -&gt; Matcher[Iterator[T]]:\n    \"\"\"\n    Matches if every element yielded by the iterator matches a given matcher.\n\n    :param match: The matcher to satisfy, or an expected value for equality matching.\n\n    This matcher iterates through the evaluated iterator, checking that every\n    element satisfies the given matcher. If any element does not match, the matcher fails.\n\n    If the `match` argument is not a matcher, it is implicitly wrapped in an\n    equality matcher.\n    \"\"\"\n    return IsStreamContainingEvery(wrap_matcher(match))\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.yields_item","title":"<code>yields_item(match)</code>","text":"<p>Matches if any element of yielded by iterator matches a given matcher.</p> <p>:param match: The matcher to satisfy, or an expected value for     :py:func:<code>~hamcrest.core.core.isequal.equal_to</code> matching.</p> <p>This matcher iterates the evaluated iterator, searching for any element that satisfies a given matcher. If a matching element is found, <code>has_item</code> is satisfied.</p> <p>If the <code>match</code> argument is not a matcher, it is implicitly wrapped in an :py:func:<code>~hamcrest.core.core.isequal.equal_to</code> matcher to check for equality.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def yields_item[T](match: Union[Matcher[T], T]) -&gt; Matcher[Iterator[T]]:\n    \"\"\"\n    Matches if any element of yielded by iterator matches a given matcher.\n\n    :param match: The matcher to satisfy, or an expected value for\n        :py:func:`~hamcrest.core.core.isequal.equal_to` matching.\n\n    This matcher iterates the evaluated iterator, searching for any element\n    that satisfies a given matcher. If a matching element is found,\n    ``has_item`` is satisfied.\n\n    If the ``match`` argument is not a matcher, it is implicitly wrapped in an\n    :py:func:`~hamcrest.core.core.isequal.equal_to` matcher to check for\n    equality.\n    \"\"\"\n    return IsIteratorYielding(wrap_matcher(match))\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.yields_items","title":"<code>yields_items(matches)</code>","text":"<p>Matches if each specified item is yielded at least once by the iterator.</p> <p>:param matches: An iterable of matchers or values, each of which should be yielded                 at least once in the iterator for this matcher to succeed.</p> <p>This matcher will iterate through the evaluated iterator and check if it yields at least one instance of each specified matcher or value.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def yields_items[T](matches: Iterable[Union[Matcher[T],\n                                            T]]) -&gt; Matcher[Iterator[T]]:\n    \"\"\"\n    Matches if each specified item is yielded at least once by the iterator.\n\n    :param matches: An iterable of matchers or values, each of which should be yielded\n                    at least once in the iterator for this matcher to succeed.\n\n    This matcher will iterate through the evaluated iterator and check if it yields\n    at least one instance of each specified matcher or value.\n    \"\"\"\n    wrapped_matchers = [wrap_matcher(match) for match in matches]\n    return IsIteratorYieldingAll(wrapped_matchers)\n</code></pre>"}]}