{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QA Automation Starter for Python","text":"<p>Modular Python packages for maintainable, BDD-style automated tests with <code>pytest</code>, <code>Hamcrest</code>, <code>Allure</code> reporting, and configurable logging.</p> <p>Technology-agnostic; example REST, Selenium and RabbitMQ implementations included.</p>"},{"location":"#example-allure-report","title":"Example Allure Report","text":"<p>see live Example Allure Report</p>"},{"location":"#example-code","title":"Example Code","text":"<pre><code>    def should_publish_and_consume(self) -&gt; None:\n        (self.steps\n            .given.a_queue_handler(self._queue_handler)\n            .when.publishing([Message(\"test_queue\")])\n            .and_.consuming()\n            .then.the_received_messages(yields_item(\n                tracing(is_(Message(\"test_queue\"))))))\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.13</li> <li>PDM (Python package manager)</li> </ul>"},{"location":"#optional","title":"Optional","text":"<ul> <li>Google Chrome for local Selenium testing</li> <li>RabbitMQ for running local tests</li> <li>Allure for generating a nice test dashboard like above</li> </ul>"},{"location":"architecture/","title":"Architecture","text":"<p>Support for additional technologies, e.g. ElasticSearch, can be added by sub-classing these classes and adding specific steps, setup/teardown, and configuration. This allows reusing the basic configuration, reporting, logging, and retrying mechanisms. Further, application tests, steps, and configurations reuse by subclassing from technologies.</p> <pre><code>flowchart TD\n    A[Tests: Define BDD scenarios as series of steps, also define specific setup and teardown] --&gt; |contains| B[Steps: encapsulate UI or API operations and verifications, and may be composed of other steps]\n    B --&gt; |contains| C[Configurations: can be per environment, such as dev, qa, staging, and contain URLs, users, authentication schemes, encryption, etc.]\n    B --&gt; |uses| D[Matchers: Hamcrest matchers for single objects or for iterables]\n    A --&gt; |contains| C\n    B --&gt; |uses| E[Models: domain objects]\n\n    subgraph Inheritance\n        A1[GenericTests] -.-&gt; |inherits| A2[Tests]\n        B1[GenericSteps] -.-&gt; |inherits| B2[Steps]\n        C1[AbstractConfiguration] -.-&gt; |inherits| C2[Configuration]\n    end\n</code></pre>"},{"location":"architecture/#extending-the-framework","title":"Extending the Framework","text":"<p>To add support for a new technology (e.g., messaging, database), create: - <code>MyTechConfiguration(BaseConfiguration)</code> - <code>MyTechSteps(GenericSteps[MyTechConfiguration])</code> - <code>MyTechTests(AbstractTestsBase[MyTechSteps, MyTechConfiguration])</code> This pattern ensures you reuse the core BDD, configuration, and reporting mechanisms.</p> <pre><code>classDiagram\n    %% Core Abstractions\n    class AbstractTestsBase {\n        &lt;&gt;\n        +steps\n        +_configuration\n        +setup_method()\n        +teardown_method()\n    }\n    class GenericSteps {\n        &lt;&gt;\n        +given\n        +when\n        +then\n        +and_\n        +with_\n        +retrying()\n        +eventually_assert_that()\n    }\n    class BaseConfiguration {\n        &lt;&gt;\n        +parser\n    }\n\n    %% Technology-Specific Extensions\n    class RestTests\n    class RestSteps\n    class RestConfiguration\n\n    class SeleniumTests\n    class SeleniumSteps\n    class SeleniumConfiguration\n\n    %% Example: Custom Extension\n    class TerminalXTests\n    class TerminalXSteps\n    class TerminalXConfiguration\n\n    %% Relationships\n    AbstractTestsBase &lt;|-- RestTests\n    AbstractTestsBase &lt;|-- SeleniumTests\n    SeleniumTests &lt;|-- TerminalXTests\n\n    GenericSteps &lt;|-- RestSteps\n    GenericSteps &lt;|-- SeleniumSteps\n    SeleniumSteps &lt;|-- TerminalXSteps\n\n    BaseConfiguration &lt;|-- RestConfiguration\n    BaseConfiguration &lt;|-- SeleniumConfiguration\n    SeleniumConfiguration &lt;|-- TerminalXConfiguration\n\n    RestTests o-- RestSteps : uses\n    RestTests o-- RestConfiguration : configures\n\n    SeleniumTests o-- SeleniumSteps : uses\n    SeleniumTests o-- SeleniumConfiguration : configures\n\n    TerminalXTests o-- TerminalXSteps : uses\n    TerminalXTests o-- TerminalXConfiguration : configures\n\n    %% Example extension note\n    %% You can add new technologies by subclassing the three core abstractions:\n    %% AbstractTestsBase, GenericSteps, and BaseConfiguration."},{"location":"architecture/#key-classes","title":"Key Classes","text":"Class\nDescription\n\n\n\n\n<code>AbstractTestsBase</code>\nBase for all test scenarios; holds steps and config\n\n\n<code>GenericSteps</code>\nBase for all step implementations; provides BDD keywords\n\n\n<code>BaseConfiguration</code>\nBase for all configuration objects\n\n\n<code>RestTests</code>\nREST-specific test base\n\n\n<code>RestSteps</code>\nREST-specific steps\n\n\n<code>RestConfiguration</code>\nREST-specific configuration\n\n\n<code>SeleniumTests</code>\nSelenium-specific test base\n\n\n<code>SeleniumSteps</code>\nSelenium-specific steps\n\n\n<code>SeleniumConfiguration</code>\nSelenium-specific configuration\n\n\n<code>TerminalXSteps</code>\nExample: custom UI steps\n\n\n<code>TerminalXConfiguration</code>\nExample: custom UI configuration"},{"location":"architecture/#usage-examples","title":"Usage Examples","text":""},{"location":"architecture/#terminalx-tests","title":"TerminalX Tests","text":"<pre><code>@pytest.mark.external\n@pytest.mark.selenium\nclass TerminalXTests(\n    SeleniumTests[TerminalXSteps[TerminalXConfiguration],\n                  TerminalXConfiguration]):\n    _steps_type = TerminalXSteps\n    _configuration = TerminalXConfiguration()\n\n    # NOTE sections may be further collected in superclasses and reused across tests\n    def login_section(\n            self, user: TerminalXUser) -&gt; TerminalXSteps[TerminalXConfiguration]:\n        return (self.steps\n                .given.terminalx(self.web_driver)\n                .when.logging_in_with(user.credentials)\n                .then.the_user_logged_in(is_(user.name)))\n\n    def should_login(self):\n        self.login_section(self.configuration.random_user)\n\n    def should_find(self):\n        (self.login_section(self.configuration.random_user)\n            .when.clicking_search())\n\n        for word in [\"hello\", \"kitty\"]:\n            (self.steps\n             .when.searching_for(word)\n             .then.the_search_hints(yields_item(tracing(\n                 contains_string_ignoring_case(word)))))\n\n    @override\n    def setup_method(self) -&gt; None:\n        from selenium.webdriver import Firefox\n        from selenium.webdriver.firefox.options import Options as FirefoxOptions\n        from selenium.webdriver.firefox.service import Service as FirefoxService\n        from webdriver_manager.firefox import GeckoDriverManager\n        if self._configuration.parser.has_option(\"selenium\", \"browser_type\") \\\n                and self._configuration.parser[\"selenium\"][\"browser_type\"] == \"firefox\":\n            options = FirefoxOptions()\n            service = FirefoxService(GeckoDriverManager().install())\n            self._web_driver = Firefox(options=options, service=service)\n            self._web_driver.set_window_size(1920, 1080)  # type: ignore\n        else:\n            super().setup_method()\n</code></pre>"},{"location":"architecture/#the-setup-method","title":"The Setup Method","text":"<p>The <code>setup_method</code> demonstrates how default setup behavior can be overriden.\nIn real world it would be pulled into a superclass that extends <code>SeleniumTests</code>.</p>"},{"location":"architecture/#the-configuration","title":"The Configuration","text":"<p>Furthermore, the <code>self._configuration.parser[\"selenium\"][\"browser_type\"]</code> could\nbe defined as a method on the <code>TerminalXConfiguration</code> class, or a superclass of\nit.</p>\n<p>The configuration is loaded from two sources, in this example:</p>\n<ol>\n<li><code>TerminalXConfiguration</code> class looks for a matching\n<code>terminalx_configuration.ini</code> file under <code>configurations/</code>.</li>\n<li>pytest could be launched with a <code>--config</code> parameter to override\nthis or add properties:\n<pre><code>pytest --config selenium:browser_type=firefox qa-pytest-examples/tests/terminalx_tests.py::TerminalXTests\n</code></pre></li>\n</ol>\n<p>Any subclass of <code>BaseConfiguration</code>\nlooks for a matching <code>ini</code> file, this way multiple configurations can be used.</p>\n<p>If there is a <code>TEST_ENVIRONMENT</code> environment variable its value will be chained\nto the path of <code>ini</code> file, this way one can select which configuration set\nshall be used at runtime.</p>"},{"location":"architecture/#swagger-petstore-tests","title":"Swagger Petstore Tests","text":"<pre><code>@pytest.mark.external\nclass SwaggerPetstoreTests(\n    RestTests[SwaggerPetstoreSteps[SwaggerPetstoreConfiguration],\n              SwaggerPetstoreConfiguration]):\n    _steps_type = SwaggerPetstoreSteps\n    _configuration = SwaggerPetstoreConfiguration()\n\n    @pytest.mark.parametrize(\"pet\", SwaggerPetstorePet.random(range(4)))\n    def should_add(self, pet: SwaggerPetstorePet):\n        (self.steps\n            .given.swagger_petstore(self.rest_session)\n            .when.adding(pet)\n            .then.the_available_pets(yields_item(tracing(is_(pet)))))\n</code></pre>"},{"location":"architecture/#combined-tests","title":"Combined Tests","text":"<pre><code>@pytest.mark.external\n@pytest.mark.selenium\nclass CombinedTests(\n        RestTests[CombinedSteps, CombinedConfiguration],\n        SeleniumTests[CombinedSteps, CombinedConfiguration]):\n    _steps_type = CombinedSteps\n    _configuration = CombinedConfiguration()\n\n    def should_run_combined_tests(self):\n        random_pet = next(SwaggerPetstorePet.random())\n        random_user = random.choice(self.configuration.users)\n\n        (self.steps\n            .given.swagger_petstore(self.rest_session)\n            .when.adding(random_pet)\n            .then.the_available_pets(yields_item(tracing(is_(random_pet))))\n            .given.terminalx(self.web_driver)\n            .when.logging_in_with(random_user.credentials)\n            .then.the_user_logged_in(is_(random_user.name)))\n</code></pre>"},{"location":"architecture/#rabbitmq-self-tests","title":"RabbitMQ Self Tests","text":"<pre><code>class RabbitMqSelfTests(\n    RabbitMqTests[int, str,\n                  RabbitMqSteps[int, str, RabbitMqSelfConfiguration],\n                  RabbitMqSelfConfiguration]):\n    _queue_handler: QueueHandler[int, str]\n    _steps_type = RabbitMqSteps\n    _configuration = RabbitMqSelfConfiguration()\n\n    def should_publish_and_consume(self) -&gt; None:\n        (self.steps\n            .given.a_queue_handler(self._queue_handler)\n            .when.publishing([Message(\"test_queue\")])\n            .and_.consuming()\n            .then.the_received_messages(yields_item(\n                tracing(is_(Message(\"test_queue\"))))))\n\n    @override\n    def setup_method(self) -&gt; None:\n        super().setup_method()\n        self._queue_handler = QueueHandler(\n            channel := self._connection.channel(),\n            queue_name=require_not_none(\n                channel.queue_declare(\n                    queue=EMPTY_STRING, exclusive=True).method.queue),\n            indexing_by=lambda message: hash(message.content),\n            consuming_by=lambda bytes: bytes.decode(),\n            publishing_by=lambda string: string.encode())\n\n    @override\n    def teardown_method(self) -&gt; None:\n        try:\n            self._queue_handler.close()\n        finally:\n            super().teardown_method()\n</code></pre>"},{"location":"architecture/#qa_testing_utils.pytest_plugin","title":"<code>qa_testing_utils.pytest_plugin</code>","text":""},{"location":"architecture/#qa_testing_utils.pytest_plugin--qa-testing-utils-pytest-plugin","title":"QA Testing Utils \u2013 Pytest Plugin","text":"<p>This pytest plugin provides shared testing infrastructure for Python monorepos\nor standalone projects using the <code>qa-testing-utils</code> module.</p>"},{"location":"architecture/#qa_testing_utils.pytest_plugin--features","title":"Features","text":"<ol>\n<li>Per-module logging configuration:</li>\n<li>During test session startup, the plugin searches for a <code>logging.ini</code> file:<ul>\n<li>First under <code>tests/**/logging.ini</code></li>\n<li>Then under <code>src/**/logging.ini</code></li>\n<li>Falls back to <code>qa-testing-utils/src/qa_testing_utils/logging.ini</code></li>\n</ul>\n</li>\n<li>\n<p>This enables consistent, per-module logging without requiring repeated boilerplate.</p>\n</li>\n<li>\n<p>Source code inclusion in test reports:</p>\n</li>\n<li>\n<p>Adds a <code>body</code> section to each test report with the source code of the test function\n     (via <code>inspect.getsource()</code>), useful for HTML/Allure/custom reporting.</p>\n</li>\n<li>\n<p>Command-line config overrides (parsed but not yet consumed):</p>\n</li>\n<li>Adds a <code>--config</code> option that accepts <code>section:key=value,...</code> strings.</li>\n<li>Intended for runtime configuration injection (e.g., overriding .ini files or test settings).</li>\n</ol>"},{"location":"architecture/#qa_testing_utils.pytest_plugin--usage","title":"Usage","text":"<ol>\n<li>\n<p>Declare the plugin in your module's <code>pytest_plugins</code> (if not auto-loaded via PDM entry point):\n   pytest_plugins = [\"qa_testing_utils.pytest_plugin\"]</p>\n</li>\n<li>\n<p>Place a logging.ini file under your module's tests/ or src/ directory.\n   If none is found, the fallback from qa-testing-utils will be used.</p>\n</li>\n<li>\n<p>Run your tests, optionally with runtime overrides:</p>\n</li>\n</ol>\n<p>pytest --config my_section:key1=val1,key2=val2</p>\n<p>Notes:\nThis plugin is designed to be generic and reusable across any module\nconsuming qa-testing-utils.</p>\n<p>Compatible with VSCode gutter test launching and monorepo test execution.</p>"},{"location":"architecture/#qa_testing_utils.pytest_plugin.get_config_overrides","title":"<code>get_config_overrides()</code>","text":"<p>Returns parsed <code>--config</code> overrides passed to pytest.\nSafe to call from anywhere (e.g., BaseConfiguration).</p>\n\n\n            \n              Source code in <code>qa-testing-utils/src/qa_testing_utils/pytest_plugin.py</code>\n              <pre><code>def get_config_overrides() -&gt; dict[str, dict[str, str]]:\n    \"\"\"\n    Returns parsed `--config` overrides passed to pytest.\n    Safe to call from anywhere (e.g., BaseConfiguration).\n    \"\"\"\n    return _config_overrides\n</code></pre>"},{"location":"architecture/#qa_testing_utils.pytest_plugin.pytest_addoption","title":"<code>pytest_addoption(parser)</code>","text":"<p>Adds the <code>--config</code> command-line option for runtime config overrides.</p>\n\n\n            \n              Source code in <code>qa-testing-utils/src/qa_testing_utils/pytest_plugin.py</code>\n              <pre><code>def pytest_addoption(parser: pytest.Parser) -&gt; None:\n    \"\"\"Adds the `--config` command-line option for runtime config overrides.\"\"\"\n    parser.addoption(\n        \"--config\",\n        action=\"append\",\n        default=[],\n        help=\"Override config values using section:key=value format, comma-separated\"\n    )\n</code></pre>"},{"location":"architecture/#qa_testing_utils.pytest_plugin.pytest_configure","title":"<code>pytest_configure(config)</code>","text":"<p>Configures the pytest session, loading logging.ini and parsing config overrides.</p>\n\n\n            \n              Source code in <code>qa-testing-utils/src/qa_testing_utils/pytest_plugin.py</code>\n              <pre><code>@pytest.hookimpl(tryfirst=True)\ndef pytest_configure(config: pytest.Config) -&gt; None:\n    \"\"\"Configures the pytest session, loading logging.ini and parsing config overrides.\"\"\"\n    from qa_testing_utils import __file__ as utils_ini\n\n    test_args = [Path(arg.split(\"::\")[0])\n                 for arg in config.args if Path(arg.split(\"::\")[0]).is_file()]\n    root = test_args[0].parent.parent if test_args else Path.cwd()\n\n    # Collect all logging.ini files under tests/ and src/\n    logging_inis = (\n        list(root.glob(\"tests/**/logging.ini\"))\n        + list(root.glob(\"src/**/logging.ini\")))\n\n    if logging_inis:\n        # Prefer the one under tests/ if it exists\n        selected_ini = logging_inis[0]\n        logging.config.fileConfig(selected_ini)\n        print(f\"loaded logging.ini from {selected_ini}\")\n    else:\n        fallback_ini = Path(utils_ini).parent / \"logging.ini\"\n        logging.config.fileConfig(fallback_ini)\n        print(f\"loaded fallback logging.ini from {fallback_ini}\")\n\n    config_arg = config.getoption(\"--config\")\n    if config_arg:\n        _parse_config_overrides(config_arg)\n</code></pre>"},{"location":"architecture/#qa_testing_utils.pytest_plugin.pytest_runtest_makereport","title":"<code>pytest_runtest_makereport(item, call)</code>","text":"<p>Generates a test report with the source code of the test function.</p>\n\n\n            \n              Source code in <code>qa-testing-utils/src/qa_testing_utils/pytest_plugin.py</code>\n              <pre><code>@pytest.hookimpl(tryfirst=True)\ndef pytest_runtest_makereport(\n    item: pytest.Item, call: pytest.CallInfo[None]\n) -&gt; pytest.TestReport:\n    \"\"\"Generates a test report with the source code of the test function.\"\"\"\n    report = pytest.TestReport.from_item_and_call(item, call)\n\n    if call.when == \"call\":\n        report.sections.append(('body', _get_test_body(item)))\n\n    return report\n</code></pre>"},{"location":"example-tests/","title":"Example Tests","text":"<p>Below are example test cases demonstrating BDD-style usage with this framework:</p>"},{"location":"example-tests/#swagger-api-add-pet-test","title":"Swagger API add pet test","text":"<p>Uses a dataprovider with 4 random pets.</p> <p>Requires live Swagger API at https://petstore.swagger.io/v2/ <pre><code>    @pytest.mark.parametrize(\"pet\", SwaggerPetstorePet.random(range(4)))\n    def should_add(self, pet: SwaggerPetstorePet):\n        (self.steps\n            .given.swagger_petstore(self.rest_session)\n            .when.adding(pet)\n            .then.the_available_pets(yields_item(tracing(is_(pet)))))\n</code></pre></p>"},{"location":"example-tests/#mocked-swagger-api-add-pet-test","title":"Mocked Swagger API add pet test","text":"<p>Defines expected requests and then same test flow as above. <pre><code>    @pytest.mark.parametrize(\"pet\", SwaggerPetstorePet.random(range(10)))\n    @responses.activate\n    def should_add(self, pet: SwaggerPetstorePet):\n        responses.add(\n            responses.POST,\n            self.configuration.resource_uri(path=\"pet\"),\n            json=EMPTY_STRING,\n            status=200)\n        responses.add(\n            responses.GET,\n            self.configuration.resource_uri(path=\"pet/findByStatus\"),\n            json=[asdict(pet)],\n            status=200)\n        (self.steps\n            .given.swagger_petstore(self.rest_session)\n            .when.adding(pet)\n            .then.the_available_pets(yields_item(tracing(is_(pet)))))\n</code></pre></p>"},{"location":"example-tests/#terminalx-ui-search-test","title":"TerminalX (UI) search test","text":"<p>Requires live https://www.terminalx.com <pre><code>    # NOTE sections may be further collected in superclasses and reused across tests\n    def login_section(\n            self, user: TerminalXUser) -&gt; TerminalXSteps[TerminalXConfiguration]:\n        return (self.steps\n                .given.terminalx(self.web_driver)\n                .when.logging_in_with(user.credentials)\n                .then.the_user_logged_in(is_(user.name)))\n\n    def should_login(self):\n        self.login_section(self.configuration.random_user)\n\n    def should_find(self):\n        (self.login_section(self.configuration.random_user)\n            .when.clicking_search())\n\n        for word in [\"hello\", \"kitty\"]:\n            (self.steps\n             .when.searching_for(word)\n             .then.the_search_hints(yields_item(tracing(\n                 contains_string_ignoring_case(word)))))\n</code></pre></p>"},{"location":"example-tests/#example-of-overriding-the-default-setup_method","title":"Example of overriding the default <code>setup_method</code>","text":"<p><pre><code>    @override\n    def setup_method(self) -&gt; None:\n        from selenium.webdriver import Firefox\n        from selenium.webdriver.firefox.options import Options as FirefoxOptions\n        from selenium.webdriver.firefox.service import Service as FirefoxService\n        from webdriver_manager.firefox import GeckoDriverManager\n        if self._configuration.parser.has_option(\"selenium\", \"browser_type\") \\\n                and self._configuration.parser[\"selenium\"][\"browser_type\"] == \"firefox\":\n            options = FirefoxOptions()\n            service = FirefoxService(GeckoDriverManager().install())\n            self._web_driver = Firefox(options=options, service=service)\n            self._web_driver.set_window_size(1920, 1080)  # type: ignore\n        else:\n            super().setup_method()\n</code></pre> In this case, it checks if <code>browser_type</code> is firefox. This can be set temporarily via command line, like: <pre><code>pytest --config selenium:browser_type=firefox qa-pytest-examples/tests/terminalx_tests.py::TerminalXTests\n</code></pre></p> <p>More details in Architecture TerminalX Configuration section.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Open in Codespace or Dev Container and everything will get installed and configured, otherwise:</p> <ol> <li> <p>Install Python 3.13 on your system</p> </li> <li> <p>Install PDM:    <pre><code>pipx install pdm[all]\n</code></pre></p> </li> <li> <p>Generate from template:</p> <ul> <li>via cookiecutter <pre><code>cookiecutter gh:QA-Automation-Starter/qa-automation-python\n</code></pre></li> <li>or fork/clone demo project <pre><code>git clone https://github.com/QA-Automation-Starter/qa-automation-python-demo.git\n</code></pre></li> </ul> </li> <li> <p>Install dependencies:    <pre><code>pdm run install-all\n</code></pre></p> </li> <li> <p>Run all tests from the root:    <pre><code>pdm run pytest\n</code></pre>    pytest html report is in <code>report.html</code></p> <p>NOTE: Selenium tests require Google Chrome installed.</p> </li> <li> <p>Optional: Generate Allure reports     <pre><code>pdm run allure-generate\n</code></pre>     then open, <code>docs/reports/index.html</code> in a browser.</p> <p>NOTE: requires installation of Allure server</p> </li> </ol> <p>Customize for your needs :)</p>"},{"location":"api/qa-pytest-commons/","title":"Commons","text":""},{"location":"api/qa-pytest-commons/#qa_pytest_commons","title":"<code>qa_pytest_commons</code>","text":""},{"location":"api/qa-pytest-commons/#qa_pytest_commons.__all__","title":"<code>__all__ = ['AbstractTestsBase', 'BaseConfiguration', 'BddKeywords', 'Configuration', 'GenericSteps']</code>  <code>module-attribute</code>","text":""},{"location":"api/qa-pytest-commons/#qa_pytest_commons.AbstractTestsBase","title":"<code>AbstractTestsBase</code>","text":"<p>               Bases: <code>ABC</code>, <code>LoggerMixin</code>, <code>ImmutableMixin</code></p> <p>Basic test scenario implementation, holding some type of steps and a logger facility.</p> <p>Subtypes must set <code>_steps_type</code> to the actual type of steps implementation::</p> <pre><code>                    +---------------+\n                    |  BddKeyWords  |\n                    +---------------+\n                                    ^\n                                    |\n                                implements\n                                    |\n+-------------------+               +--------------+\n| AbstractTestsBase |---contains---&gt;| GenericSteps |\n|                   |               +--------------+\n|                   |                       +---------------+\n|                   |---contains-----------&gt;| Configuration |\n+-------------------+                       +---------------+\n</code></pre> <p>IMPORTANT: pytest classes must not define an init method.</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>TSteps</code> <code>(TSteps</code> <p>GenericSteps): The actual steps implementation, or partial implementation.</p> required <code>TConfiguration</code> <code>(TConfiguration</code> <p>Configuration): The configuration type for the test scenario.</p> required <p>Attributes:</p> Name Type Description <code>_steps_type</code> <code>Type[TSteps]</code> <p>The type of the steps implementation. Must be set by subtypes.</p> <code>_configuration</code> <code>TConfiguration</code> <p>The configuration instance for the test scenario. Must be set by subtypes.</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/abstract_tests_base.py</code> <pre><code>class AbstractTestsBase[\n        TSteps: GenericSteps[Any],\n        TConfiguration: Configuration](ABC, LoggerMixin, ImmutableMixin):\n    \"\"\"\n    Basic test scenario implementation, holding some type of steps and a logger\n    facility.\n\n    Subtypes must set `_steps_type` to the actual type of steps implementation::\n\n                            +---------------+\n                            |  BddKeyWords  |\n                            +---------------+\n                                            ^\n                                            |\n                                        implements\n                                            |\n        +-------------------+               +--------------+\n        | AbstractTestsBase |---contains---&gt;| GenericSteps |\n        |                   |               +--------------+\n        |                   |                       +---------------+\n        |                   |---contains-----------&gt;| Configuration |\n        +-------------------+                       +---------------+\n\n    IMPORTANT: pytest classes must not define an __init__ method.\n\n    Type Parameters:\n        TSteps (TSteps:GenericSteps): The actual steps implementation, or partial implementation.\n        TConfiguration (TConfiguration:Configuration): The configuration type for the test scenario.\n\n    Attributes:\n        _steps_type (Type[TSteps]): The type of the steps implementation. Must be set by subtypes.\n        _configuration (TConfiguration): The configuration instance for the test scenario. Must be set by subtypes.\n    \"\"\"\n    _steps_type: Type[TSteps]\n    _configuration: TConfiguration\n\n    @property\n    def configuration(self) -&gt; TConfiguration:\n        '''\n        Returns the configuration instance.\n\n        Returns:\n            TConfiguration: The configuration instance.\n        '''\n        return self._configuration\n\n    @final\n    @cached_property\n    def steps(self) -&gt; TSteps:\n        '''\n        Lazily initializes and returns an instance of steps implementation.\n\n        Returns:\n            TSteps: The instance of steps implementation.\n        '''\n        self.log.debug(f\"initiating {self._steps_type}\")\n        return self._steps_type(self._configuration)\n\n    def setup_method(self):\n        \"\"\"\n        Override in subtypes with specific setup, if any.\n        \"\"\"\n        self.log.debug(\"setup\")\n\n    def teardown_method(self):\n        \"\"\"\n        Override in subtypes with specific teardown, if any.\n        \"\"\"\n        self.log.debug(\"teardown\")\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.AbstractTestsBase.configuration","title":"<code>configuration</code>  <code>property</code>","text":"<p>Returns the configuration instance.</p> <p>Returns:</p> Name Type Description <code>TConfiguration</code> <code>TConfiguration</code> <p>The configuration instance.</p>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.AbstractTestsBase.steps","title":"<code>steps</code>  <code>cached</code> <code>property</code>","text":"<p>Lazily initializes and returns an instance of steps implementation.</p> <p>Returns:</p> Name Type Description <code>TSteps</code> <code>TSteps</code> <p>The instance of steps implementation.</p>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.AbstractTestsBase.setup_method","title":"<code>setup_method()</code>","text":"<p>Override in subtypes with specific setup, if any.</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/abstract_tests_base.py</code> <pre><code>def setup_method(self):\n    \"\"\"\n    Override in subtypes with specific setup, if any.\n    \"\"\"\n    self.log.debug(\"setup\")\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.AbstractTestsBase.teardown_method","title":"<code>teardown_method()</code>","text":"<p>Override in subtypes with specific teardown, if any.</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/abstract_tests_base.py</code> <pre><code>def teardown_method(self):\n    \"\"\"\n    Override in subtypes with specific teardown, if any.\n    \"\"\"\n    self.log.debug(\"teardown\")\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.BaseConfiguration","title":"<code>BaseConfiguration</code>","text":"<p>               Bases: <code>Configuration</code>, <code>LoggerMixin</code>, <code>ImmutableMixin</code></p> <p>Base class for all types of configurations, providing a parser for a pre-specified configuration file.</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/base_configuration.py</code> <pre><code>class BaseConfiguration(Configuration, LoggerMixin, ImmutableMixin):\n    \"\"\"\n    Base class for all types of configurations, providing a parser for a pre-specified configuration file.\n    \"\"\"\n    _path: Path\n\n    def __init__(self, path: Path | None = None):\n        \"\"\"\n        Initializes the configuration by loading the associated `.ini` file.\n\n        If `path` is not provided, the file is inferred based on the module name\n        of the subclass and loaded from a structured configuration directory.\n\n        The default lookup path follows this structure:\n            &lt;module_dir&gt;/configurations/${TEST_ENVIRONMENT}/&lt;module_name&gt;.ini\n\n        Where:\n            - &lt;module_dir&gt; is the directory where the subclass's module is located\n            - ${TEST_ENVIRONMENT} is an optional environment variable that specifies\n            the subdirectory (e.g., \"dev\", \"ci\", \"prod\"). If unset, it defaults\n            to an empty string (i.e., no subdirectory)\n            - &lt;module_name&gt; is the name of the `.py` file defining the subclass\n\n        Args:\n            path (Path, optional): Explicit path to the configuration file. If provided,\n                                overrides automatic inference.\n\n        Raises:\n            FileNotFoundError: If the resolved configuration file does not exist.\n        \"\"\"\n        if path is None:\n            module_file = Path(inspect.getfile(self.__class__))\n            module_stem = module_file.stem\n            resources_dir = module_file.parent / \"configurations\" / \\\n                os.environ.get(\"TEST_ENVIRONMENT\", EMPTY_STRING)\n            ini_file = resources_dir / f\"{module_stem}.ini\"\n            self._path = ini_file\n        else:\n            self._path = path\n\n        if not self._path.exists():\n            raise FileNotFoundError(\n                f\"configuration file not found: {self._path.resolve()}\")\n\n        self.log.debug(f\"using configuration from {self._path}\")\n\n    # NOTE if properties cannot be cached, this is a red-flag\n    # configuration properties should be immutable.\n    @final\n    @cached_property\n    def parser(self) -&gt; configparser.ConfigParser:\n        \"\"\"\n        Parser that reads this configuration.\n        \"\"\"\n        self.log.debug(f\"reading configuration from {self._path}\")\n        parser = configparser.ConfigParser()\n        config_files = parser.read(self._path)\n        self.log.debug(f\"successfully read {config_files}\")\n\n        for section, pairs in get_config_overrides().items():\n            if not parser.has_section(section):\n                parser.add_section(section)\n            for key, value in pairs.items():\n                self.log.debug(f\"overriding [{section}] {key} = {value}\")\n                parser.set(section, key, value)\n\n        return parser\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.BaseConfiguration.parser","title":"<code>parser</code>  <code>cached</code> <code>property</code>","text":"<p>Parser that reads this configuration.</p>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.BaseConfiguration.__init__","title":"<code>__init__(path=None)</code>","text":"<p>Initializes the configuration by loading the associated <code>.ini</code> file.</p> <p>If <code>path</code> is not provided, the file is inferred based on the module name of the subclass and loaded from a structured configuration directory.</p> The default lookup path follows this structure <p>/configurations/${TEST_ENVIRONMENT}/.ini Where <ul> <li> is the directory where the subclass's module is located <li>${TEST_ENVIRONMENT} is an optional environment variable that specifies the subdirectory (e.g., \"dev\", \"ci\", \"prod\"). If unset, it defaults to an empty string (i.e., no subdirectory)</li> <li> is the name of the <code>.py</code> file defining the subclass <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Explicit path to the configuration file. If provided,                 overrides automatic inference.</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the resolved configuration file does not exist.</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/base_configuration.py</code> <pre><code>def __init__(self, path: Path | None = None):\n    \"\"\"\n    Initializes the configuration by loading the associated `.ini` file.\n\n    If `path` is not provided, the file is inferred based on the module name\n    of the subclass and loaded from a structured configuration directory.\n\n    The default lookup path follows this structure:\n        &lt;module_dir&gt;/configurations/${TEST_ENVIRONMENT}/&lt;module_name&gt;.ini\n\n    Where:\n        - &lt;module_dir&gt; is the directory where the subclass's module is located\n        - ${TEST_ENVIRONMENT} is an optional environment variable that specifies\n        the subdirectory (e.g., \"dev\", \"ci\", \"prod\"). If unset, it defaults\n        to an empty string (i.e., no subdirectory)\n        - &lt;module_name&gt; is the name of the `.py` file defining the subclass\n\n    Args:\n        path (Path, optional): Explicit path to the configuration file. If provided,\n                            overrides automatic inference.\n\n    Raises:\n        FileNotFoundError: If the resolved configuration file does not exist.\n    \"\"\"\n    if path is None:\n        module_file = Path(inspect.getfile(self.__class__))\n        module_stem = module_file.stem\n        resources_dir = module_file.parent / \"configurations\" / \\\n            os.environ.get(\"TEST_ENVIRONMENT\", EMPTY_STRING)\n        ini_file = resources_dir / f\"{module_stem}.ini\"\n        self._path = ini_file\n    else:\n        self._path = path\n\n    if not self._path.exists():\n        raise FileNotFoundError(\n            f\"configuration file not found: {self._path.resolve()}\")\n\n    self.log.debug(f\"using configuration from {self._path}\")\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.BddKeywords","title":"<code>BddKeywords</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for defining Behavior-Driven Development (BDD) keywords.</p> <p>This class provides a set of properties that represent the common BDD keywords such as <code>given</code>, <code>when</code>, <code>then</code>, <code>and_</code>, <code>with_</code>. Implementations might be of two types: step implementations (GenericSteps) or scenario implementations (AbstractTestsBase). In both cases, these properties must return an object that provides same step implementation, allowing a fluent-style coding.</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>TSteps</code> <code>(TSteps</code> <p>BddKeywords): The actual steps implementation, or partial implementation.</p> required Source code in <code>qa-pytest-commons/src/qa_pytest_commons/bdd_keywords.py</code> <pre><code>class BddKeywords[TSteps:BddKeywords](ABC):\n    \"\"\"\n    Base class for defining Behavior-Driven Development (BDD) keywords.\n\n    This class provides a set of properties that represent the common BDD keywords\n    such as `given`, `when`, `then`, `and_`, `with_`. Implementations might be\n    of two types: step implementations (GenericSteps) or scenario implementations\n    (AbstractTestsBase). In both cases, these properties must return an object\n    that provides same step implementation, allowing a fluent-style coding.\n\n    Type Parameters:\n        TSteps (TSteps:BddKeywords): The actual steps implementation, or partial implementation.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def given(self) -&gt; TSteps:\n        \"\"\"\n        Use to start definition of given stage.\n\n        The given stage is the start-up point of a test.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def when(self) -&gt; TSteps:\n        \"\"\"\n        Use to start definition of operations stage.\n\n        The operations stage is the part that triggers some behavior on the SUT.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def then(self) -&gt; TSteps:\n        \"\"\"\n        Use to start definition of verifications stage.\n\n        The verifications stage is the part that samples actual output of the\n        SUT and compares it against a predefined condition (a.k.a. rule).\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def and_(self) -&gt; TSteps:\n        \"\"\"\n        Use to continue definition of previous stage.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def with_(self) -&gt; TSteps:\n        \"\"\"\n        Same as `and_`, sometimes it just sounds better.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.BddKeywords.and_","title":"<code>and_</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Use to continue definition of previous stage.</p>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.BddKeywords.given","title":"<code>given</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Use to start definition of given stage.</p> <p>The given stage is the start-up point of a test.</p>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.BddKeywords.then","title":"<code>then</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Use to start definition of verifications stage.</p> <p>The verifications stage is the part that samples actual output of the SUT and compares it against a predefined condition (a.k.a. rule).</p>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.BddKeywords.when","title":"<code>when</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Use to start definition of operations stage.</p> <p>The operations stage is the part that triggers some behavior on the SUT.</p>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.BddKeywords.with_","title":"<code>with_</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Same as <code>and_</code>, sometimes it just sounds better.</p>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.Configuration","title":"<code>Configuration</code>","text":"<p>Empty configuration base class for scenarios that do not require configuration.</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/base_configuration.py</code> <pre><code>class Configuration():\n    \"\"\"\n    Empty configuration base class for scenarios that do not require configuration.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps","title":"<code>GenericSteps</code>","text":"<p>               Bases: <code>BddKeywords['GenericSteps']</code>, <code>LoggerMixin</code>, <code>ImmutableMixin</code></p> <p>Generic steps base class for BDD-style test implementations. Provides retrying, assertion, and step chaining utilities for all step types.</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>TConfiguration</code> <code>BaseConfiguration</code> <p>The configuration type for the steps implementation.</p> required <p>Attributes:</p> Name Type Description <code>_retrying</code> <code>Retrying</code> <p>The tenacity.Retrying instance used for retry logic.</p> <code>_configuration</code> <code>TConfiguration</code> <p>The configuration instance for these steps.</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>class GenericSteps[TConfiguration: BaseConfiguration](\n        BddKeywords['GenericSteps'],\n        LoggerMixin,\n        ImmutableMixin):\n    \"\"\"\n    Generic steps base class for BDD-style test implementations.\n    Provides retrying, assertion, and step chaining utilities for all step types.\n\n    Type Parameters:\n        TConfiguration: The configuration type for the steps implementation.\n\n    Attributes:\n        _retrying (Retrying): The tenacity.Retrying instance used for retry logic.\n        _configuration (TConfiguration): The configuration instance for these steps.\n    \"\"\"\n\n    _retrying: Retrying\n    _configuration: TConfiguration\n\n    def __init__(self, configuration: TConfiguration):\n        \"\"\"\n        Initializes the steps with the given configuration and default retry policy.\n\n        Args:\n            configuration (TConfiguration): The configuration instance.\n        \"\"\"\n        self._configuration = configuration\n        # NOTE: waits 1 sec after 1st failure, 2, 4, and 8 secs on subsequent;\n        # see BddScenarioTests#should_retry\n        self._retrying = Retrying(\n            stop=stop_after_attempt(4),\n            wait=wait_exponential(min=1, max=10),\n            retry=retry_if_exception_type(Exception),\n            before_sleep=before_sleep_log(self.log, logging.DEBUG)\n        )\n\n    @final\n    @property\n    def configured(self) -&gt; TConfiguration:\n        \"\"\"\n        Returns the configuration instance for these steps.\n\n        Returns:\n            TConfiguration: The configuration instance.\n        \"\"\"\n        return self._configuration\n\n    @final\n    @property\n    def retry_policy(self) -&gt; Retrying:\n        \"\"\"\n        Returns the retry policy used for retrying steps.\n\n        Returns:\n            Retrying: The tenacity.Retrying instance.\n        \"\"\"\n        return self._retrying\n\n    @final\n    @property\n    @override\n    def given(self) -&gt; Self:\n        Context.set(lambda m: f\"Given {m}\")\n        return self\n\n    @final\n    @property\n    @override\n    def when(self) -&gt; Self:\n        Context.set(lambda m: f\"When {m}\")\n        return self\n\n    @final\n    @property\n    @override\n    def then(self) -&gt; Self:\n        Context.set(lambda m: f\"Then {m}\")\n        return self\n\n    @final\n    @property\n    @override\n    def and_(self) -&gt; Self:\n        Context.set(lambda m: f\"And {m}\")\n        return self\n\n    @final\n    @property\n    @override\n    def with_(self) -&gt; Self:\n        Context.set(lambda m: f\"With {m}\")\n        return self\n\n    @final\n    @property\n    @Context.traced\n    def nothing(self) -&gt; Self:\n        \"\"\"\n        Intended to support self-testing which does not rely on outer world system.\n\n        Returns:\n            Self: these steps\n        \"\"\"\n        return self\n\n    # DELETEME\n    # # @Context.traced -- nothing to trace here...\n    # def configuration(self, configuration: TConfiguration) -&gt; Self:\n    #     \"\"\"\n    #     Sets the configuration to use.\n\n    #     Args:\n    #         configuration (TConfiguration): the configuration\n\n    #     Returns:\n    #         Self: these steps\n    #     \"\"\"\n    #     self._configuration = configuration\n    #     return self\n\n    def set[T:Valid](self, field_name: str, field_value: T) -&gt; T:\n        \"\"\"\n        Sets field to specified value, validating it if possible.\n\n        Args:\n            field_name (str): name of field; the field should be defined as annotation\n            field_value (T:Valid): value of field that can be validated\n\n        Raises:\n            AttributeError: if the field is not defined\n            TypeError: if the object does not support the Valid protocol\n            InvalidValueException: if the object is invalid\n\n        Returns:\n            T: the value of set field\n        \"\"\"\n        if field_name not in self.__class__.__annotations__:\n            raise AttributeError(\n                f\"{field_name} is not a valid attribute of \"\n                f\"{self.__class__.__name__}.\")\n\n        setattr(self, field_name, valid(field_value))\n        return field_value\n\n    @final\n    def step(self, *args: Any) -&gt; Self:\n        \"\"\"\n        Casts anything to a step.\n\n        Returns:\n            Self: these steps\n        \"\"\"\n        return self\n\n    @final\n    def tracing(self, value: Any) -&gt; Self:\n        \"\"\"\n        Logs value at DEBUG level using the logger of this steps class.\n\n        Args:\n            value (Any): The value to log.\n        Returns:\n            Self: these steps\n        \"\"\"\n        self.log.debug(f\"=== {value}\")\n        return self\n\n    @final\n    @Context.traced\n    def waiting(self, duration: timedelta = timedelta(seconds=0)) -&gt; Self:\n        \"\"\"\n        Blocks current thread for specified duration.\n\n        Args:\n            duration (timedelta, optional): How long to wait. Defaults to 0 seconds.\n        Returns:\n            Self: these steps\n        \"\"\"\n        sleep_for(duration)\n        return self\n\n    @final\n    @Context.traced\n    def failing(self, exception: Exception) -&gt; Self:\n        \"\"\"\n        Raises the given exception, for self-testing of retrying and eventually_assert_that.\n\n        Args:\n            exception (Exception): The exception to raise.\n        Raises:\n            exception: That exception.\n        Returns:\n            Self: these steps\n        \"\"\"\n        raise exception\n\n    @final\n    @Context.traced\n    def repeating(self, range: range, step: Callable[[int], Self]) -&gt; Self:\n        \"\"\"\n        Repeats the specified step for each value in the range.\n\n        Args:\n            range (range): The range to iterate over.\n            step (Callable[[int], Self]): The step to repeat.\n        Returns:\n            Self: these steps\n        \"\"\"\n        seq(range).for_each(step)  # type: ignore\n        return self\n\n    # TODO parallel_repeating\n\n    @final\n    @Context.traced\n    def safely(self, step: Callable[[], Self]) -&gt; Self:\n        \"\"\"\n        Executes specified step, swallowing its exceptions.\n\n        Args:\n            step (Callable[[], Self]): The step to execute.\n        Returns:\n            Self: these steps\n        \"\"\"\n        return safely(lambda: step()).value_or(self)\n\n    # TODO implement a raises decorator to mark method as raising some exception\n    # at run-time the decorator shall check if raised exception matches the declared list.\n    # This one would be:\n    # @raises(tenacity.RetryError)\n    @final\n    # @Context.traced\n    def retrying(self, step: Callable[[], Self]) -&gt; Self:\n        '''\n        Retries specified step according to _retry_policy.\n\n        Args:\n            step (Callable[[], Self]): The step to retry.\n        Returns:\n            Self: these steps\n        '''\n        return self._retrying(step)\n\n    @final\n    def eventually_assert_that[T](\n            self, supplier: Supplier[T],\n            by_rule: Matcher[T]) -&gt; Self:\n        '''\n        Repeatedly applies specified rule on specified supplier, according to _retry_policy.\n\n        Args:\n            supplier (Callable[[], T]): The value supplier.\n            by_rule (Matcher[T]): The matcher to apply.\n        Returns:\n            Self: these steps\n        '''\n        return self._retrying(lambda: self._assert_that(supplier(), by_rule))\n\n    @final\n    @Context.traced\n    def it_works(self, matcher: Matcher[bool]) -&gt; Self:\n        \"\"\"\n        Intended to support self-testing of reports.\n\n        Args:\n            matcher (Matcher[bool]): Matcher for the boolean result.\n        Returns:\n            Self: these steps\n        \"\"\"\n        assert_that(True, matcher)\n        return self\n\n    @final\n    # NOTE @Context.traced here is redundant\n    def _assert_that[T](self, value: T, by_rule: Matcher[T]) -&gt; Self:\n        \"\"\"\n        Adapts PyHamcrest's assert_that to the BDD world by returning Self.\n\n        Args:\n            value (T): The value to assert upon.\n            by_rule (Matcher[T]): The matcher to apply.\n        Returns:\n            Self: these steps\n        \"\"\"\n        assert_that(value, by_rule)\n        return self\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.and_","title":"<code>and_</code>  <code>property</code>","text":""},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.configured","title":"<code>configured</code>  <code>property</code>","text":"<p>Returns the configuration instance for these steps.</p> <p>Returns:</p> Name Type Description <code>TConfiguration</code> <code>TConfiguration</code> <p>The configuration instance.</p>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.given","title":"<code>given</code>  <code>property</code>","text":""},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.nothing","title":"<code>nothing</code>  <code>property</code>","text":"<p>Intended to support self-testing which does not rely on outer world system.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>these steps</p>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.retry_policy","title":"<code>retry_policy</code>  <code>property</code>","text":"<p>Returns the retry policy used for retrying steps.</p> <p>Returns:</p> Name Type Description <code>Retrying</code> <code>Retrying</code> <p>The tenacity.Retrying instance.</p>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.then","title":"<code>then</code>  <code>property</code>","text":""},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.when","title":"<code>when</code>  <code>property</code>","text":""},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.with_","title":"<code>with_</code>  <code>property</code>","text":""},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.__init__","title":"<code>__init__(configuration)</code>","text":"<p>Initializes the steps with the given configuration and default retry policy.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>TConfiguration</code> <p>The configuration instance.</p> required Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>def __init__(self, configuration: TConfiguration):\n    \"\"\"\n    Initializes the steps with the given configuration and default retry policy.\n\n    Args:\n        configuration (TConfiguration): The configuration instance.\n    \"\"\"\n    self._configuration = configuration\n    # NOTE: waits 1 sec after 1st failure, 2, 4, and 8 secs on subsequent;\n    # see BddScenarioTests#should_retry\n    self._retrying = Retrying(\n        stop=stop_after_attempt(4),\n        wait=wait_exponential(min=1, max=10),\n        retry=retry_if_exception_type(Exception),\n        before_sleep=before_sleep_log(self.log, logging.DEBUG)\n    )\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.eventually_assert_that","title":"<code>eventually_assert_that(supplier, by_rule)</code>","text":"<p>Repeatedly applies specified rule on specified supplier, according to _retry_policy.</p> <p>Parameters:</p> Name Type Description Default <code>supplier</code> <code>Callable[[], T]</code> <p>The value supplier.</p> required <code>by_rule</code> <code>Matcher[T]</code> <p>The matcher to apply.</p> required <p>Returns:     Self: these steps</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>@final\ndef eventually_assert_that[T](\n        self, supplier: Supplier[T],\n        by_rule: Matcher[T]) -&gt; Self:\n    '''\n    Repeatedly applies specified rule on specified supplier, according to _retry_policy.\n\n    Args:\n        supplier (Callable[[], T]): The value supplier.\n        by_rule (Matcher[T]): The matcher to apply.\n    Returns:\n        Self: these steps\n    '''\n    return self._retrying(lambda: self._assert_that(supplier(), by_rule))\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.failing","title":"<code>failing(exception)</code>","text":"<p>Raises the given exception, for self-testing of retrying and eventually_assert_that.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>Exception</code> <p>The exception to raise.</p> required <p>Raises:     exception: That exception. Returns:     Self: these steps</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>@final\n@Context.traced\ndef failing(self, exception: Exception) -&gt; Self:\n    \"\"\"\n    Raises the given exception, for self-testing of retrying and eventually_assert_that.\n\n    Args:\n        exception (Exception): The exception to raise.\n    Raises:\n        exception: That exception.\n    Returns:\n        Self: these steps\n    \"\"\"\n    raise exception\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.it_works","title":"<code>it_works(matcher)</code>","text":"<p>Intended to support self-testing of reports.</p> <p>Parameters:</p> Name Type Description Default <code>matcher</code> <code>Matcher[bool]</code> <p>Matcher for the boolean result.</p> required <p>Returns:     Self: these steps</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>@final\n@Context.traced\ndef it_works(self, matcher: Matcher[bool]) -&gt; Self:\n    \"\"\"\n    Intended to support self-testing of reports.\n\n    Args:\n        matcher (Matcher[bool]): Matcher for the boolean result.\n    Returns:\n        Self: these steps\n    \"\"\"\n    assert_that(True, matcher)\n    return self\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.repeating","title":"<code>repeating(range, step)</code>","text":"<p>Repeats the specified step for each value in the range.</p> <p>Parameters:</p> Name Type Description Default <code>range</code> <code>range</code> <p>The range to iterate over.</p> required <code>step</code> <code>Callable[[int], Self]</code> <p>The step to repeat.</p> required <p>Returns:     Self: these steps</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>@final\n@Context.traced\ndef repeating(self, range: range, step: Callable[[int], Self]) -&gt; Self:\n    \"\"\"\n    Repeats the specified step for each value in the range.\n\n    Args:\n        range (range): The range to iterate over.\n        step (Callable[[int], Self]): The step to repeat.\n    Returns:\n        Self: these steps\n    \"\"\"\n    seq(range).for_each(step)  # type: ignore\n    return self\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.retrying","title":"<code>retrying(step)</code>","text":"<p>Retries specified step according to _retry_policy.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>Callable[[], Self]</code> <p>The step to retry.</p> required <p>Returns:     Self: these steps</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>@final\n# @Context.traced\ndef retrying(self, step: Callable[[], Self]) -&gt; Self:\n    '''\n    Retries specified step according to _retry_policy.\n\n    Args:\n        step (Callable[[], Self]): The step to retry.\n    Returns:\n        Self: these steps\n    '''\n    return self._retrying(step)\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.safely","title":"<code>safely(step)</code>","text":"<p>Executes specified step, swallowing its exceptions.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>Callable[[], Self]</code> <p>The step to execute.</p> required <p>Returns:     Self: these steps</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>@final\n@Context.traced\ndef safely(self, step: Callable[[], Self]) -&gt; Self:\n    \"\"\"\n    Executes specified step, swallowing its exceptions.\n\n    Args:\n        step (Callable[[], Self]): The step to execute.\n    Returns:\n        Self: these steps\n    \"\"\"\n    return safely(lambda: step()).value_or(self)\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.set","title":"<code>set(field_name, field_value)</code>","text":"<p>Sets field to specified value, validating it if possible.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>name of field; the field should be defined as annotation</p> required <code>field_value (T</code> <p>Valid): value of field that can be validated</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>if the field is not defined</p> <code>TypeError</code> <p>if the object does not support the Valid protocol</p> <code>InvalidValueException</code> <p>if the object is invalid</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>the value of set field</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>def set[T:Valid](self, field_name: str, field_value: T) -&gt; T:\n    \"\"\"\n    Sets field to specified value, validating it if possible.\n\n    Args:\n        field_name (str): name of field; the field should be defined as annotation\n        field_value (T:Valid): value of field that can be validated\n\n    Raises:\n        AttributeError: if the field is not defined\n        TypeError: if the object does not support the Valid protocol\n        InvalidValueException: if the object is invalid\n\n    Returns:\n        T: the value of set field\n    \"\"\"\n    if field_name not in self.__class__.__annotations__:\n        raise AttributeError(\n            f\"{field_name} is not a valid attribute of \"\n            f\"{self.__class__.__name__}.\")\n\n    setattr(self, field_name, valid(field_value))\n    return field_value\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.step","title":"<code>step(*args)</code>","text":"<p>Casts anything to a step.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>these steps</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>@final\ndef step(self, *args: Any) -&gt; Self:\n    \"\"\"\n    Casts anything to a step.\n\n    Returns:\n        Self: these steps\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.tracing","title":"<code>tracing(value)</code>","text":"<p>Logs value at DEBUG level using the logger of this steps class.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to log.</p> required <p>Returns:     Self: these steps</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>@final\ndef tracing(self, value: Any) -&gt; Self:\n    \"\"\"\n    Logs value at DEBUG level using the logger of this steps class.\n\n    Args:\n        value (Any): The value to log.\n    Returns:\n        Self: these steps\n    \"\"\"\n    self.log.debug(f\"=== {value}\")\n    return self\n</code></pre>"},{"location":"api/qa-pytest-commons/#qa_pytest_commons.GenericSteps.waiting","title":"<code>waiting(duration=timedelta(seconds=0))</code>","text":"<p>Blocks current thread for specified duration.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>timedelta</code> <p>How long to wait. Defaults to 0 seconds.</p> <code>timedelta(seconds=0)</code> <p>Returns:     Self: these steps</p> Source code in <code>qa-pytest-commons/src/qa_pytest_commons/generic_steps.py</code> <pre><code>@final\n@Context.traced\ndef waiting(self, duration: timedelta = timedelta(seconds=0)) -&gt; Self:\n    \"\"\"\n    Blocks current thread for specified duration.\n\n    Args:\n        duration (timedelta, optional): How long to wait. Defaults to 0 seconds.\n    Returns:\n        Self: these steps\n    \"\"\"\n    sleep_for(duration)\n    return self\n</code></pre>"},{"location":"api/qa-pytest-examples/","title":"Examples","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples","title":"<code>qa_pytest_examples</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.__all__","title":"<code>__all__ = ['CombinedConfiguration', 'CombinedSteps', 'Credentials', 'RabbitMqSelfConfiguration', 'SwaggerPetstoreConfiguration', 'SwaggerPetstoreCredentials', 'SwaggerPetstorePet', 'SwaggerPetstoreSteps', 'TerminalXConfiguration', 'TerminalXCredentials', 'TerminalXSteps', 'TerminalXUser']</code>  <code>module-attribute</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.CombinedConfiguration","title":"<code>CombinedConfiguration</code>","text":"<p>               Bases: <code>SwaggerPetstoreConfiguration</code>, <code>TerminalXConfiguration</code></p> <p>Combined configuration that inherits settings from both SwaggerPetstoreConfiguration and TerminalXConfiguration. Useful for scenarios requiring both sets of configuration.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/combined_configuration.py</code> <pre><code>class CombinedConfiguration(\n        SwaggerPetstoreConfiguration, TerminalXConfiguration):\n    \"\"\"\n    Combined configuration that inherits settings from both SwaggerPetstoreConfiguration\n    and TerminalXConfiguration. Useful for scenarios requiring both sets of configuration.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.CombinedSteps","title":"<code>CombinedSteps</code>","text":"<p>               Bases: <code>SwaggerPetstoreSteps[CombinedConfiguration]</code>, <code>TerminalXSteps[CombinedConfiguration]</code></p> <p>Combined steps implementation that inherits step definitions from both SwaggerPetstoreSteps and TerminalXSteps, using CombinedConfiguration. Useful for scenarios requiring both sets of step logic in a single test suite.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/combined_steps.py</code> <pre><code>class CombinedSteps(\n        SwaggerPetstoreSteps[CombinedConfiguration],\n        TerminalXSteps[CombinedConfiguration]):\n    \"\"\"\n    Combined steps implementation that inherits step definitions from both\n    SwaggerPetstoreSteps and TerminalXSteps, using CombinedConfiguration.\n    Useful for scenarios requiring both sets of step logic in a single test suite.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.Credentials","title":"<code>Credentials</code>  <code>dataclass</code>","text":"<p>Represents user credentials with username and password.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/model/credentials.py</code> <pre><code>@dataclass(frozen=True)\nclass Credentials:\n    \"\"\"\n    Represents user credentials with username and password.\n    \"\"\"\n\n    username: str\n    password: str\n\n    @classmethod\n    def from_(cls, colon_separated: str):\n        \"\"\"\n        Creates a Credentials instance from a colon-separated string.\n\n        Args:\n            colon_separated (str): String in the format 'username:password'.\n\n        Returns:\n            Credentials: The created credentials instance.\n        \"\"\"\n        return cls(*colon_separated.split(\":\"))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.Credentials.password","title":"<code>password</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.Credentials.username","title":"<code>username</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.Credentials.__init__","title":"<code>__init__(username, password)</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.Credentials.from_","title":"<code>from_(colon_separated)</code>  <code>classmethod</code>","text":"<p>Creates a Credentials instance from a colon-separated string.</p> <p>Parameters:</p> Name Type Description Default <code>colon_separated</code> <code>str</code> <p>String in the format 'username:password'.</p> required <p>Returns:</p> Name Type Description <code>Credentials</code> <p>The created credentials instance.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/model/credentials.py</code> <pre><code>@classmethod\ndef from_(cls, colon_separated: str):\n    \"\"\"\n    Creates a Credentials instance from a colon-separated string.\n\n    Args:\n        colon_separated (str): String in the format 'username:password'.\n\n    Returns:\n        Credentials: The created credentials instance.\n    \"\"\"\n    return cls(*colon_separated.split(\":\"))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.RabbitMqSelfConfiguration","title":"<code>RabbitMqSelfConfiguration</code>","text":"<p>               Bases: <code>RabbitMqConfiguration</code></p> <p>Configuration for self-contained RabbitMQ test scenarios. Inherits all settings from RabbitMqConfiguration and can be extended for test-specific overrides or additional configuration.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/rabbitmq_self_configuration.py</code> <pre><code>class RabbitMqSelfConfiguration(RabbitMqConfiguration):\n    \"\"\"\n    Configuration for self-contained RabbitMQ test scenarios.\n    Inherits all settings from RabbitMqConfiguration and can be extended for\n    test-specific overrides or additional configuration.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstoreConfiguration","title":"<code>SwaggerPetstoreConfiguration</code>","text":"<p>               Bases: <code>RestConfiguration</code></p> <p>Configuration for Swagger Petstore REST API tests. Inherits from RestConfiguration.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/swagger_petstore_configuration.py</code> <pre><code>class SwaggerPetstoreConfiguration(RestConfiguration):\n    \"\"\"\n    Configuration for Swagger Petstore REST API tests.\n    Inherits from RestConfiguration.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstoreCredentials","title":"<code>SwaggerPetstoreCredentials</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Credentials</code></p> <p>Credentials for Swagger Petstore users. Inherits from Credentials.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/model/swagger_petstore_credentials.py</code> <pre><code>@dataclass(frozen=True)\nclass SwaggerPetstoreCredentials(Credentials):\n    \"\"\"\n    Credentials for Swagger Petstore users.\n    Inherits from Credentials.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstoreCredentials.__init__","title":"<code>__init__(username, password)</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstorePet","title":"<code>SwaggerPetstorePet</code>  <code>dataclass</code>","text":"<p>Represents a pet in the Swagger Petstore API.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/model/swagger_petstore_pet.py</code> <pre><code>@dataclass(eq=True, frozen=True)\n@to_string()\nclass SwaggerPetstorePet:\n    \"\"\"\n    Represents a pet in the Swagger Petstore API.\n    \"\"\"\n    name: str\n    status: str\n\n    @staticmethod\n    def random(range: range = range(1)) -&gt; Iterator['SwaggerPetstorePet']:\n        \"\"\"\n        Generates a random SwaggerPetstorePet with a unique name and 'available' status.\n\n        Returns:\n            SwaggerPetstorePet: The generated pet.\n        \"\"\"\n        for _ in range:\n            yield SwaggerPetstorePet(name=str(uuid4()), status=\"available\")\n\n    @staticmethod\n    def from_(response: Response) -&gt; Iterator['SwaggerPetstorePet']:\n        \"\"\"\n        Parses a response and yields SwaggerPetstorePet objects for each valid pet entry.\n\n        Args:\n            response (Response): The HTTP response containing pet data.\n        Returns:\n            Iterator[SwaggerPetstorePet]: Iterator over parsed pets.\n        \"\"\"\n        return (\n            SwaggerPetstorePet(name=pet[\"name\"], status=pet[\"status\"])\n            for pet in response.json()\n            if \"name\" in pet and \"status\" in pet\n        )\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstorePet.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstorePet.status","title":"<code>status</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstorePet.__init__","title":"<code>__init__(name, status)</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstorePet.from_","title":"<code>from_(response)</code>  <code>staticmethod</code>","text":"<p>Parses a response and yields SwaggerPetstorePet objects for each valid pet entry.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>The HTTP response containing pet data.</p> required <p>Returns:     Iterator[SwaggerPetstorePet]: Iterator over parsed pets.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/model/swagger_petstore_pet.py</code> <pre><code>@staticmethod\ndef from_(response: Response) -&gt; Iterator['SwaggerPetstorePet']:\n    \"\"\"\n    Parses a response and yields SwaggerPetstorePet objects for each valid pet entry.\n\n    Args:\n        response (Response): The HTTP response containing pet data.\n    Returns:\n        Iterator[SwaggerPetstorePet]: Iterator over parsed pets.\n    \"\"\"\n    return (\n        SwaggerPetstorePet(name=pet[\"name\"], status=pet[\"status\"])\n        for pet in response.json()\n        if \"name\" in pet and \"status\" in pet\n    )\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstorePet.random","title":"<code>random(range=range(1))</code>  <code>staticmethod</code>","text":"<p>Generates a random SwaggerPetstorePet with a unique name and 'available' status.</p> <p>Returns:</p> Name Type Description <code>SwaggerPetstorePet</code> <code>Iterator['SwaggerPetstorePet']</code> <p>The generated pet.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/model/swagger_petstore_pet.py</code> <pre><code>@staticmethod\ndef random(range: range = range(1)) -&gt; Iterator['SwaggerPetstorePet']:\n    \"\"\"\n    Generates a random SwaggerPetstorePet with a unique name and 'available' status.\n\n    Returns:\n        SwaggerPetstorePet: The generated pet.\n    \"\"\"\n    for _ in range:\n        yield SwaggerPetstorePet(name=str(uuid4()), status=\"available\")\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstoreSteps","title":"<code>SwaggerPetstoreSteps</code>","text":"<p>               Bases: <code>RestSteps[TConfiguration]</code></p> <p>BDD-style step definitions for Swagger Petstore API operations.</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>TConfiguration</code> <code>SwaggerPetstoreConfiguration</code> <p>The configuration type, must be a SwaggerPetstoreConfiguration.</p> required Source code in <code>qa-pytest-examples/src/qa_pytest_examples/swagger_petstore_steps.py</code> <pre><code>class SwaggerPetstoreSteps[TConfiguration: SwaggerPetstoreConfiguration](\n        RestSteps[TConfiguration]):\n    \"\"\"\n    BDD-style step definitions for Swagger Petstore API operations.\n\n    Type Parameters:\n        TConfiguration: The configuration type, must be a SwaggerPetstoreConfiguration.\n    \"\"\"\n\n    @Context.traced\n    def swagger_petstore(self, client: requests.Session):\n        \"\"\"\n        Sets the REST session to use for subsequent steps.\n\n        Args:\n            client (requests.Session): The HTTP client session.\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        self._rest_session = client\n        return self\n\n    @Context.traced\n    def adding(self, pet: SwaggerPetstorePet) -&gt; Self:\n        \"\"\"\n        Adds a pet to the Swagger Petstore via the API.\n\n        Args:\n            pet (SwaggerPetstorePet): The pet to add.\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        return self.invoking(Request(\n            method=HttpMethod.POST,\n            url=self.configured.resource_uri(path=\"pet\"),\n            json=asdict(pet)\n        ))\n\n    @Context.traced\n    def the_available_pets(self, by_rule: Matcher\n                           [Iterator[SwaggerPetstorePet]]) -&gt; Self:\n        \"\"\"\n        Asserts that the available pets match the provided matcher rule.\n\n        Args:\n            by_rule (Matcher[Iterator[SwaggerPetstorePet]]): Matcher for the available pets iterator.\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        return self.the_invocation(Request(\n            method=HttpMethod.GET,\n            url=self.configured.resource_uri(path=\"pet/findByStatus\"),\n            params={\"status\": \"available\"}),\n            adapted_object(\n                lambda response: SwaggerPetstorePet.from_(response),\n                by_rule))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstoreSteps.adding","title":"<code>adding(pet)</code>","text":"<p>Adds a pet to the Swagger Petstore via the API.</p> <p>Parameters:</p> Name Type Description Default <code>pet</code> <code>SwaggerPetstorePet</code> <p>The pet to add.</p> required <p>Returns:     Self: The current step instance for chaining.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/swagger_petstore_steps.py</code> <pre><code>@Context.traced\ndef adding(self, pet: SwaggerPetstorePet) -&gt; Self:\n    \"\"\"\n    Adds a pet to the Swagger Petstore via the API.\n\n    Args:\n        pet (SwaggerPetstorePet): The pet to add.\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    return self.invoking(Request(\n        method=HttpMethod.POST,\n        url=self.configured.resource_uri(path=\"pet\"),\n        json=asdict(pet)\n    ))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstoreSteps.swagger_petstore","title":"<code>swagger_petstore(client)</code>","text":"<p>Sets the REST session to use for subsequent steps.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Session</code> <p>The HTTP client session.</p> required <p>Returns:     Self: The current step instance for chaining.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/swagger_petstore_steps.py</code> <pre><code>@Context.traced\ndef swagger_petstore(self, client: requests.Session):\n    \"\"\"\n    Sets the REST session to use for subsequent steps.\n\n    Args:\n        client (requests.Session): The HTTP client session.\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    self._rest_session = client\n    return self\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.SwaggerPetstoreSteps.the_available_pets","title":"<code>the_available_pets(by_rule)</code>","text":"<p>Asserts that the available pets match the provided matcher rule.</p> <p>Parameters:</p> Name Type Description Default <code>by_rule</code> <code>Matcher[Iterator[SwaggerPetstorePet]]</code> <p>Matcher for the available pets iterator.</p> required <p>Returns:     Self: The current step instance for chaining.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/swagger_petstore_steps.py</code> <pre><code>@Context.traced\ndef the_available_pets(self, by_rule: Matcher\n                       [Iterator[SwaggerPetstorePet]]) -&gt; Self:\n    \"\"\"\n    Asserts that the available pets match the provided matcher rule.\n\n    Args:\n        by_rule (Matcher[Iterator[SwaggerPetstorePet]]): Matcher for the available pets iterator.\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    return self.the_invocation(Request(\n        method=HttpMethod.GET,\n        url=self.configured.resource_uri(path=\"pet/findByStatus\"),\n        params={\"status\": \"available\"}),\n        adapted_object(\n            lambda response: SwaggerPetstorePet.from_(response),\n            by_rule))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXConfiguration","title":"<code>TerminalXConfiguration</code>","text":"<p>               Bases: <code>SeleniumConfiguration</code></p> <p>Configuration for TerminalX Selenium-based tests. Provides access to users and random user selection.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/terminalx_configuration.py</code> <pre><code>class TerminalXConfiguration(SeleniumConfiguration):\n    \"\"\"\n    Configuration for TerminalX Selenium-based tests.\n    Provides access to users and random user selection.\n    \"\"\"\n\n    @cached_property\n    @final\n    def users(self) -&gt; List[TerminalXUser]:\n        \"\"\"\n        Returns the list of TerminalX users from the configuration parser.\n\n        Returns:\n            List[TerminalXUser]: The list of users.\n        \"\"\"\n        users_section = self.parser[\"users\"]\n        return [\n            TerminalXUser(TerminalXCredentials.from_(\n                username_password), name=key)\n            for key, username_password in users_section.items()\n        ]\n\n    @final\n    @property\n    def random_user(self) -&gt; TerminalXUser:\n        \"\"\"\n        Returns a random user from the list of users.\n\n        Returns:\n            TerminalXUser: A randomly selected user.\n        \"\"\"\n        return random.choice(self.users)\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXConfiguration.random_user","title":"<code>random_user</code>  <code>property</code>","text":"<p>Returns a random user from the list of users.</p> <p>Returns:</p> Name Type Description <code>TerminalXUser</code> <code>TerminalXUser</code> <p>A randomly selected user.</p>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXConfiguration.users","title":"<code>users</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the list of TerminalX users from the configuration parser.</p> <p>Returns:</p> Type Description <code>List[TerminalXUser]</code> <p>List[TerminalXUser]: The list of users.</p>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXCredentials","title":"<code>TerminalXCredentials</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Credentials</code></p> <p>Credentials for TerminalX users. Inherits from Credentials.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/model/terminalx_credentials.py</code> <pre><code>@dataclass(frozen=True)\nclass TerminalXCredentials(Credentials):\n    \"\"\"\n    Credentials for TerminalX users.\n    Inherits from Credentials.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXCredentials.__init__","title":"<code>__init__(username, password)</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXSteps","title":"<code>TerminalXSteps</code>","text":"<p>               Bases: <code>SeleniumSteps[TConfiguration]</code></p> <p>BDD-style step definitions for TerminalX UI operations using Selenium.</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>TConfiguration</code> <code>TerminalXConfiguration</code> <p>The configuration type, must be a TerminalXConfiguration.</p> required Source code in <code>qa-pytest-examples/src/qa_pytest_examples/terminalx_steps.py</code> <pre><code>class TerminalXSteps[TConfiguration: TerminalXConfiguration](\n        SeleniumSteps[TConfiguration]):\n    \"\"\"\n    BDD-style step definitions for TerminalX UI operations using Selenium.\n\n    Type Parameters:\n        TConfiguration: The configuration type, must be a TerminalXConfiguration.\n    \"\"\"\n    @Context.traced\n    def terminalx(self, driver: WebDriver) -&gt; Self:\n        \"\"\"\n        Sets the Selenium WebDriver and navigates to the landing page.\n\n        Args:\n            driver (WebDriver): The Selenium WebDriver instance.\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        self._web_driver = driver\n        self._web_driver.get(self.configured.landing_page)\n        return self\n\n    def clicking_login(self) -&gt; Self:\n        \"\"\"\n        Clicks the login button on the TerminalX landing page.\n\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        return self.clicking(By.xpath(\"//div[contains(text(), '\u05d4\u05ea\u05d7\u05d1\u05e8\u05d5\u05ea')]\"))\n\n    @Context.traced\n    def clicking_search(self) -&gt; Self:\n        \"\"\"\n        Clicks the search button in the TerminalX header.\n\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        return self.clicking(\n            By.xpath(\"//button[@data-test-id='qa-header-search-button']\"))\n\n    def submitting_login(self) -&gt; Self:\n        \"\"\"\n        Clicks the submit button on the login form.\n\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        return self.clicking(By.xpath(\"//button[contains(text(), '\u05d4\u05ea\u05d7\u05d1\u05e8\u05d5\u05ea')]\"))\n\n    @Context.traced\n    def logging_in_with(self, credentials: TerminalXCredentials) -&gt; Self:\n        \"\"\"\n        Logs in using the provided credentials.\n\n        Args:\n            credentials (TerminalXCredentials): The credentials to use for login.\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        return (self.clicking_login()\n                .and_.typing(\n                    By.id(\"qa-login-email-input\"), credentials.username)\n                .and_.typing(\n                    By.id(\"qa-login-password-input\"), credentials.password)\n                .and_.submitting_login())\n\n    @Context.traced\n    def the_user_logged_in(self, by_rule: Matcher[str]) -&gt; Self:\n        \"\"\"\n        Asserts that the user is logged in by checking the profile button text.\n\n        Args:\n            by_rule (Matcher[str]): Matcher for the user name text.\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        return self.the_element(\n            By.xpath(\n                \"//button[@data-test-id='qa-header-profile-button']/span[2]\"),\n            adapted_object(lambda element: element.text, by_rule))\n\n    @Context.traced\n    def searching_for(self, text: str) -&gt; Self:\n        \"\"\"\n        Types the given text into the search box.\n\n        Args:\n            text (str): The text to search for.\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        return self.typing(\n            By.xpath(\"//input[@data-test-id='qa-search-box-input']\"),\n            text)\n\n    @Context.traced\n    def the_search_hints(self, by_rule: Matcher[Iterator[str]]) -&gt; Self:\n        \"\"\"\n        Asserts that the search hints match the provided matcher rule.\n\n        Args:\n            by_rule (Matcher[Iterator[str]]): Matcher for the search hints iterator.\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        return self.the_elements(\n            By.xpath(\"(//ul[@class='list_3tWy'])[2]/li/div/div/a\"),\n            adapted_iterator(lambda element: element.text, by_rule))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXSteps.clicking_login","title":"<code>clicking_login()</code>","text":"<p>Clicks the login button on the TerminalX landing page.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The current step instance for chaining.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/terminalx_steps.py</code> <pre><code>def clicking_login(self) -&gt; Self:\n    \"\"\"\n    Clicks the login button on the TerminalX landing page.\n\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    return self.clicking(By.xpath(\"//div[contains(text(), '\u05d4\u05ea\u05d7\u05d1\u05e8\u05d5\u05ea')]\"))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXSteps.clicking_search","title":"<code>clicking_search()</code>","text":"<p>Clicks the search button in the TerminalX header.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The current step instance for chaining.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/terminalx_steps.py</code> <pre><code>@Context.traced\ndef clicking_search(self) -&gt; Self:\n    \"\"\"\n    Clicks the search button in the TerminalX header.\n\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    return self.clicking(\n        By.xpath(\"//button[@data-test-id='qa-header-search-button']\"))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXSteps.logging_in_with","title":"<code>logging_in_with(credentials)</code>","text":"<p>Logs in using the provided credentials.</p> <p>Parameters:</p> Name Type Description Default <code>credentials</code> <code>TerminalXCredentials</code> <p>The credentials to use for login.</p> required <p>Returns:     Self: The current step instance for chaining.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/terminalx_steps.py</code> <pre><code>@Context.traced\ndef logging_in_with(self, credentials: TerminalXCredentials) -&gt; Self:\n    \"\"\"\n    Logs in using the provided credentials.\n\n    Args:\n        credentials (TerminalXCredentials): The credentials to use for login.\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    return (self.clicking_login()\n            .and_.typing(\n                By.id(\"qa-login-email-input\"), credentials.username)\n            .and_.typing(\n                By.id(\"qa-login-password-input\"), credentials.password)\n            .and_.submitting_login())\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXSteps.searching_for","title":"<code>searching_for(text)</code>","text":"<p>Types the given text into the search box.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to search for.</p> required <p>Returns:     Self: The current step instance for chaining.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/terminalx_steps.py</code> <pre><code>@Context.traced\ndef searching_for(self, text: str) -&gt; Self:\n    \"\"\"\n    Types the given text into the search box.\n\n    Args:\n        text (str): The text to search for.\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    return self.typing(\n        By.xpath(\"//input[@data-test-id='qa-search-box-input']\"),\n        text)\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXSteps.submitting_login","title":"<code>submitting_login()</code>","text":"<p>Clicks the submit button on the login form.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The current step instance for chaining.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/terminalx_steps.py</code> <pre><code>def submitting_login(self) -&gt; Self:\n    \"\"\"\n    Clicks the submit button on the login form.\n\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    return self.clicking(By.xpath(\"//button[contains(text(), '\u05d4\u05ea\u05d7\u05d1\u05e8\u05d5\u05ea')]\"))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXSteps.terminalx","title":"<code>terminalx(driver)</code>","text":"<p>Sets the Selenium WebDriver and navigates to the landing page.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>WebDriver</code> <p>The Selenium WebDriver instance.</p> required <p>Returns:     Self: The current step instance for chaining.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/terminalx_steps.py</code> <pre><code>@Context.traced\ndef terminalx(self, driver: WebDriver) -&gt; Self:\n    \"\"\"\n    Sets the Selenium WebDriver and navigates to the landing page.\n\n    Args:\n        driver (WebDriver): The Selenium WebDriver instance.\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    self._web_driver = driver\n    self._web_driver.get(self.configured.landing_page)\n    return self\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXSteps.the_search_hints","title":"<code>the_search_hints(by_rule)</code>","text":"<p>Asserts that the search hints match the provided matcher rule.</p> <p>Parameters:</p> Name Type Description Default <code>by_rule</code> <code>Matcher[Iterator[str]]</code> <p>Matcher for the search hints iterator.</p> required <p>Returns:     Self: The current step instance for chaining.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/terminalx_steps.py</code> <pre><code>@Context.traced\ndef the_search_hints(self, by_rule: Matcher[Iterator[str]]) -&gt; Self:\n    \"\"\"\n    Asserts that the search hints match the provided matcher rule.\n\n    Args:\n        by_rule (Matcher[Iterator[str]]): Matcher for the search hints iterator.\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    return self.the_elements(\n        By.xpath(\"(//ul[@class='list_3tWy'])[2]/li/div/div/a\"),\n        adapted_iterator(lambda element: element.text, by_rule))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXSteps.the_user_logged_in","title":"<code>the_user_logged_in(by_rule)</code>","text":"<p>Asserts that the user is logged in by checking the profile button text.</p> <p>Parameters:</p> Name Type Description Default <code>by_rule</code> <code>Matcher[str]</code> <p>Matcher for the user name text.</p> required <p>Returns:     Self: The current step instance for chaining.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/terminalx_steps.py</code> <pre><code>@Context.traced\ndef the_user_logged_in(self, by_rule: Matcher[str]) -&gt; Self:\n    \"\"\"\n    Asserts that the user is logged in by checking the profile button text.\n\n    Args:\n        by_rule (Matcher[str]): Matcher for the user name text.\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    return self.the_element(\n        By.xpath(\n            \"//button[@data-test-id='qa-header-profile-button']/span[2]\"),\n        adapted_object(lambda element: element.text, by_rule))\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXUser","title":"<code>TerminalXUser</code>  <code>dataclass</code>","text":"<p>Represents a TerminalX user with credentials and a display name.</p> Source code in <code>qa-pytest-examples/src/qa_pytest_examples/model/terminalx_user.py</code> <pre><code>@dataclass(frozen=True)\nclass TerminalXUser:\n    \"\"\"\n    Represents a TerminalX user with credentials and a display name.\n    \"\"\"\n\n    credentials: TerminalXCredentials\n    name: str\n</code></pre>"},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXUser.credentials","title":"<code>credentials</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXUser.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-examples/#qa_pytest_examples.TerminalXUser.__init__","title":"<code>__init__(credentials, name)</code>","text":""},{"location":"api/qa-pytest-rabbitmq/","title":"RabbitMQ","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq","title":"<code>qa_pytest_rabbitmq</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.__all__","title":"<code>__all__ = ['Message', 'QueueHandler', 'RabbitMqConfiguration', 'RabbitMqSteps', 'RabbitMqTests']</code>  <code>module-attribute</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.Message","title":"<code>Message</code>  <code>dataclass</code>","text":"<p>Represents a message to be published or consumed from a RabbitMQ queue.</p> <p>Attributes:</p> Name Type Description <code>content</code> <code>V</code> <p>The message payload.</p> <code>properties</code> <code>BasicProperties</code> <p>Optional message properties for RabbitMQ.</p> Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/queue_handler.py</code> <pre><code>@to_string()\n@dataclass(frozen=True)\nclass Message[V]:\n    \"\"\"\n    Represents a message to be published or consumed from a RabbitMQ queue.\n\n    Attributes:\n        content (V): The message payload.\n        properties (BasicProperties): Optional message properties for RabbitMQ.\n    \"\"\"\n    content: V\n    properties: BasicProperties = field(default_factory=BasicProperties)\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.Message.content","title":"<code>content</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.Message.properties","title":"<code>properties = field(default_factory=BasicProperties)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.Message.__init__","title":"<code>__init__(content, properties=BasicProperties())</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler","title":"<code>QueueHandler</code>  <code>dataclass</code>","text":"<p>               Bases: <code>LoggerMixin</code></p> <p>Handles publishing and consuming messages from a RabbitMQ queue in a thread-safe, asynchronous manner.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>BlockingChannel</code> <p>The RabbitMQ channel to use.</p> required <code>queue_name</code> <code>str</code> <p>The name of the queue to operate on.</p> required <code>indexing_by</code> <code>Callable</code> <p>Function to extract a key from a message.</p> required <code>consuming_by</code> <code>Callable</code> <p>Function to deserialize message bytes.</p> required <code>publishing_by</code> <code>Callable</code> <p>Function to serialize message content.</p> required Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/queue_handler.py</code> <pre><code>@to_string()\n@dataclass\n@final\nclass QueueHandler[K, V](LoggerMixin):\n    \"\"\"\n    Handles publishing and consuming messages from a RabbitMQ queue in a thread-safe, asynchronous manner.\n\n    Args:\n        channel (BlockingChannel): The RabbitMQ channel to use.\n        queue_name (str): The name of the queue to operate on.\n        indexing_by (Callable): Function to extract a key from a message.\n        consuming_by (Callable): Function to deserialize message bytes.\n        publishing_by (Callable): Function to serialize message content.\n    \"\"\"\n    channel: Final[BlockingChannel]\n    queue_name: Final[str]\n    indexing_by: Final[Callable[[Message[V]], K]]\n    consuming_by: Final[Callable[[bytes], V]]\n    publishing_by: Final[Callable[[V], bytes]]\n\n    _received_messages: Final[dict[K, Message[V]]] = field(\n        default_factory=lambda: dict())\n    _command_queue: Final[queue.Queue[Callable[[], None]]] = field(\n        default_factory=lambda: queue.Queue())\n\n    _worker_thread: threading.Thread = field(init=False)\n    _shutdown_event: threading.Event = field(\n        default_factory=threading.Event, init=False)\n    _consumer_tag: str | None = field(default=None, init=False)\n    _lock: threading.RLock = field(default_factory=threading.RLock, init=False)\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"\n        Starts the worker thread for handling asynchronous queue operations.\n        \"\"\"\n        self._worker_thread = threading.Thread(\n            target=self._worker_loop, name=\"rabbitmq-handler\", daemon=True)\n        self._worker_thread.start()\n\n    def __enter__(self) -&gt; \"QueueHandler[K, V]\":\n        \"\"\"\n        Context manager entry. Returns self.\n        \"\"\"\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: TracebackType | None\n    ) -&gt; None:\n        \"\"\"\n        Context manager exit. Ensures the handler is closed and resources are released.\n        \"\"\"\n        self.close()\n\n    def _worker_loop(self) -&gt; None:\n        \"\"\"\n        Internal worker loop for processing commands and RabbitMQ events.\n        \"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                self.channel.connection.process_data_events()\n                try:\n                    command = self._command_queue.get_nowait()\n                    command()\n                except queue.Empty:\n                    pass\n            except Exception as e:\n                self.log.error(f\"Unhandled error in worker thread: {e}\")\n\n    def _submit(self, fn: Callable[[], None]) -&gt; None:\n        \"\"\"\n        Submits a callable to be executed by the worker thread.\n        \"\"\"\n        self._command_queue.put(fn)\n\n    def consume(self) -&gt; str:\n        \"\"\"\n        Starts consuming messages from the queue asynchronously.\n        Returns:\n            str: A placeholder consumer tag (actual tag is set internally).\n        \"\"\"\n        def _consume():\n            def on_message(ch: BlockingChannel, method: Any,\n                           props: BasicProperties, body: bytes) -&gt; None:\n                try:\n                    content = self.consuming_by(body)\n                    message = Message(content=content, properties=props)\n                    key = self.indexing_by(message)\n                    with self._lock:\n                        self._received_messages[key] = message\n                    ch.basic_ack(\n                        delivery_tag=require_not_none(\n                            method.delivery_tag))\n                    self.log.debug(f\"received {key}\")\n                except Exception as e:\n                    self.log.warning(f\"skipping message due to error: {e}\")\n                    ch.basic_reject(\n                        delivery_tag=require_not_none(\n                            method.delivery_tag),\n                        requeue=True)\n\n            self._consumer_tag = self.channel.basic_consume(\n                queue=self.queue_name, on_message_callback=on_message\n            )\n            self.log.debug(f\"consumer set up with tag {self._consumer_tag}\")\n\n        self._submit(_consume)\n        return \"pending-tag\"\n\n    def cancel(self) -&gt; str:\n        \"\"\"\n        Cancels the active consumer, if any.\n        Returns:\n            str: The previous consumer tag, or an empty string if none.\n        \"\"\"\n        def _cancel():\n            if self._consumer_tag:\n                self.channel.connection.add_callback_threadsafe(\n                    self.channel.stop_consuming)\n                self._consumer_tag = None\n                self.log.debug(\"consumer cancelled\")\n        self._submit(_cancel)\n        return self._consumer_tag or \"\"\n\n    def publish(self, messages: Iterator[Message[V]]) -&gt; None:\n        \"\"\"\n        Publishes an iterable of Message objects to the queue asynchronously.\n\n        Args:\n            messages (Iterator[Message[V]]): The messages to publish.\n        \"\"\"\n        def _publish():\n            for message in messages:\n                body = self.publishing_by(message.content)\n                self.channel.basic_publish(\n                    exchange=EMPTY_STRING,\n                    routing_key=self.queue_name,\n                    body=body,\n                    properties=message.properties\n                )\n                self.log.debug(f\"published {message}\")\n        self._submit(_publish)\n\n    def publish_values(self, values: Iterator[V]) -&gt; None:\n        \"\"\"\n        Publishes an iterable of values to the queue, wrapping each in a Message.\n\n        Args:\n            values (Iterator[V]): The values to publish.\n        \"\"\"\n        self.publish((Message(content=value) for value in values))\n\n    def close(self) -&gt; None:\n        \"\"\"\n        Gracefully shuts down the handler, cancels consumers, and joins the worker thread.\n        \"\"\"\n        self.cancel()\n        self._shutdown_event.set()\n        self._worker_thread.join(timeout=5.0)\n\n    @property\n    def received_messages(self) -&gt; Mapping[K, Message[V]]:\n        \"\"\"\n        Returns a snapshot of all received messages, indexed by key.\n\n        Returns:\n            Mapping[K, Message[V]]: The received messages.\n        \"\"\"\n        with self._lock:\n            return dict(self._received_messages)\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.channel","title":"<code>channel</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.consuming_by","title":"<code>consuming_by</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.indexing_by","title":"<code>indexing_by</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.publishing_by","title":"<code>publishing_by</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.queue_name","title":"<code>queue_name</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.received_messages","title":"<code>received_messages</code>  <code>property</code>","text":"<p>Returns a snapshot of all received messages, indexed by key.</p> <p>Returns:</p> Type Description <code>Mapping[K, Message[V]]</code> <p>Mapping[K, Message[V]]: The received messages.</p>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry. Returns self.</p> Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/queue_handler.py</code> <pre><code>def __enter__(self) -&gt; \"QueueHandler[K, V]\":\n    \"\"\"\n    Context manager entry. Returns self.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.__exit__","title":"<code>__exit__(exc_type, exc_value, traceback)</code>","text":"<p>Context manager exit. Ensures the handler is closed and resources are released.</p> Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/queue_handler.py</code> <pre><code>def __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: TracebackType | None\n) -&gt; None:\n    \"\"\"\n    Context manager exit. Ensures the handler is closed and resources are released.\n    \"\"\"\n    self.close()\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.__init__","title":"<code>__init__(channel, queue_name, indexing_by, consuming_by, publishing_by, _received_messages=(lambda: dict())(), _command_queue=(lambda: queue.Queue())())</code>","text":""},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Starts the worker thread for handling asynchronous queue operations.</p> Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/queue_handler.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"\n    Starts the worker thread for handling asynchronous queue operations.\n    \"\"\"\n    self._worker_thread = threading.Thread(\n        target=self._worker_loop, name=\"rabbitmq-handler\", daemon=True)\n    self._worker_thread.start()\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.cancel","title":"<code>cancel()</code>","text":"<p>Cancels the active consumer, if any. Returns:     str: The previous consumer tag, or an empty string if none.</p> Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/queue_handler.py</code> <pre><code>def cancel(self) -&gt; str:\n    \"\"\"\n    Cancels the active consumer, if any.\n    Returns:\n        str: The previous consumer tag, or an empty string if none.\n    \"\"\"\n    def _cancel():\n        if self._consumer_tag:\n            self.channel.connection.add_callback_threadsafe(\n                self.channel.stop_consuming)\n            self._consumer_tag = None\n            self.log.debug(\"consumer cancelled\")\n    self._submit(_cancel)\n    return self._consumer_tag or \"\"\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.close","title":"<code>close()</code>","text":"<p>Gracefully shuts down the handler, cancels consumers, and joins the worker thread.</p> Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/queue_handler.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"\n    Gracefully shuts down the handler, cancels consumers, and joins the worker thread.\n    \"\"\"\n    self.cancel()\n    self._shutdown_event.set()\n    self._worker_thread.join(timeout=5.0)\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.consume","title":"<code>consume()</code>","text":"<p>Starts consuming messages from the queue asynchronously. Returns:     str: A placeholder consumer tag (actual tag is set internally).</p> Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/queue_handler.py</code> <pre><code>def consume(self) -&gt; str:\n    \"\"\"\n    Starts consuming messages from the queue asynchronously.\n    Returns:\n        str: A placeholder consumer tag (actual tag is set internally).\n    \"\"\"\n    def _consume():\n        def on_message(ch: BlockingChannel, method: Any,\n                       props: BasicProperties, body: bytes) -&gt; None:\n            try:\n                content = self.consuming_by(body)\n                message = Message(content=content, properties=props)\n                key = self.indexing_by(message)\n                with self._lock:\n                    self._received_messages[key] = message\n                ch.basic_ack(\n                    delivery_tag=require_not_none(\n                        method.delivery_tag))\n                self.log.debug(f\"received {key}\")\n            except Exception as e:\n                self.log.warning(f\"skipping message due to error: {e}\")\n                ch.basic_reject(\n                    delivery_tag=require_not_none(\n                        method.delivery_tag),\n                    requeue=True)\n\n        self._consumer_tag = self.channel.basic_consume(\n            queue=self.queue_name, on_message_callback=on_message\n        )\n        self.log.debug(f\"consumer set up with tag {self._consumer_tag}\")\n\n    self._submit(_consume)\n    return \"pending-tag\"\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.publish","title":"<code>publish(messages)</code>","text":"<p>Publishes an iterable of Message objects to the queue asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>Iterator[Message[V]]</code> <p>The messages to publish.</p> required Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/queue_handler.py</code> <pre><code>def publish(self, messages: Iterator[Message[V]]) -&gt; None:\n    \"\"\"\n    Publishes an iterable of Message objects to the queue asynchronously.\n\n    Args:\n        messages (Iterator[Message[V]]): The messages to publish.\n    \"\"\"\n    def _publish():\n        for message in messages:\n            body = self.publishing_by(message.content)\n            self.channel.basic_publish(\n                exchange=EMPTY_STRING,\n                routing_key=self.queue_name,\n                body=body,\n                properties=message.properties\n            )\n            self.log.debug(f\"published {message}\")\n    self._submit(_publish)\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.QueueHandler.publish_values","title":"<code>publish_values(values)</code>","text":"<p>Publishes an iterable of values to the queue, wrapping each in a Message.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Iterator[V]</code> <p>The values to publish.</p> required Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/queue_handler.py</code> <pre><code>def publish_values(self, values: Iterator[V]) -&gt; None:\n    \"\"\"\n    Publishes an iterable of values to the queue, wrapping each in a Message.\n\n    Args:\n        values (Iterator[V]): The values to publish.\n    \"\"\"\n    self.publish((Message(content=value) for value in values))\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqConfiguration","title":"<code>RabbitMqConfiguration</code>","text":"<p>               Bases: <code>BaseConfiguration</code></p> <p>RabbitMQ-specific test configuration. Provides access to the RabbitMQ connection URI from the configuration parser.</p> Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/rabbitmq_configuration.py</code> <pre><code>class RabbitMqConfiguration(BaseConfiguration):\n    \"\"\"\n    RabbitMQ-specific test configuration.\n    Provides access to the RabbitMQ connection URI from the configuration parser.\n    \"\"\"\n\n    @cached_property\n    def connection_uri(self) -&gt; pika.URLParameters:\n        \"\"\"\n        Returns the RabbitMQ connection URI as a pika.URLParameters object.\n\n        Returns:\n            pika.URLParameters: The connection URI for RabbitMQ.\n        \"\"\"\n        return pika.URLParameters(self.parser.get(\"rabbitmq\", \"connection_uri\"))\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqConfiguration.connection_uri","title":"<code>connection_uri</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the RabbitMQ connection URI as a pika.URLParameters object.</p> <p>Returns:</p> Type Description <code>URLParameters</code> <p>pika.URLParameters: The connection URI for RabbitMQ.</p>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqSteps","title":"<code>RabbitMqSteps</code>","text":"<p>               Bases: <code>GenericSteps[TConfiguration]</code></p> <p>BDD-style step definitions for RabbitMQ queue operations.</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>K</code> <p>The type of the message key.</p> required <code>V</code> <p>The type of the message content.</p> required <code>TConfiguration</code> <code>RabbitMqConfiguration</code> <p>The configuration type, must be a RabbitMqConfiguration.</p> required Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/rabbitmq_steps.py</code> <pre><code>class RabbitMqSteps[K, V, TConfiguration: RabbitMqConfiguration](\n        GenericSteps[TConfiguration]):\n    \"\"\"\n    BDD-style step definitions for RabbitMQ queue operations.\n\n    Type Parameters:\n        K: The type of the message key.\n        V: The type of the message content.\n        TConfiguration: The configuration type, must be a RabbitMqConfiguration.\n    \"\"\"\n    _queue_handler: QueueHandler[K, V]\n\n    @Context.traced\n    @final\n    def a_queue_handler(self, queue_handler: QueueHandler[K, V]) -&gt; Self:\n        \"\"\"\n        Sets the queue handler to use for subsequent steps.\n\n        Args:\n            queue_handler (QueueHandler[K, V]): The handler instance.\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        self._queue_handler = queue_handler\n        return self\n\n    @Context.traced\n    @final\n    def publishing(self, messages: Iterable[Message[V]]) -&gt; Self:\n        \"\"\"\n        Publishes the provided messages to the queue.\n\n        Args:\n            messages (Iterable[Message[V]]): The messages to publish.\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        self._queue_handler.publish(iter(messages))\n        return self\n\n    @Context.traced\n    @final\n    def consuming(self) -&gt; Self:\n        \"\"\"\n        Starts consuming messages from the queue.\n\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        self._queue_handler.consume()\n        return self\n\n    @Context.traced\n    @final\n    def the_received_messages(\n            self, by_rule: Matcher[Iterator[Message[V]]]) -&gt; Self:\n        \"\"\"\n        Asserts that the received messages match the provided matcher rule.\n\n        Args:\n            by_rule (Matcher[Iterator[Message[V]]]): Matcher for the received messages iterator.\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        return self.eventually_assert_that(\n            lambda: iter(self._queue_handler.received_messages.values()),\n            by_rule)\n\n    @Context.traced\n    @final\n    def the_message_by_key(\n            self, key: K, by_rule: Matcher[Message[V]]) -&gt; Self:\n        \"\"\"\n        Asserts that the message with the given key matches the provided matcher rule.\n\n        Args:\n            key (K): The key to look up.\n            by_rule (Matcher[Message[V]]): Matcher for the message.\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        return self.eventually_assert_that(\n            lambda: require_not_none(\n                self._queue_handler.received_messages.get(key)),\n            by_rule)\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqSteps.a_queue_handler","title":"<code>a_queue_handler(queue_handler)</code>","text":"<p>Sets the queue handler to use for subsequent steps.</p> <p>Parameters:</p> Name Type Description Default <code>queue_handler</code> <code>QueueHandler[K, V]</code> <p>The handler instance.</p> required <p>Returns:     Self: The current step instance for chaining.</p> Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/rabbitmq_steps.py</code> <pre><code>@Context.traced\n@final\ndef a_queue_handler(self, queue_handler: QueueHandler[K, V]) -&gt; Self:\n    \"\"\"\n    Sets the queue handler to use for subsequent steps.\n\n    Args:\n        queue_handler (QueueHandler[K, V]): The handler instance.\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    self._queue_handler = queue_handler\n    return self\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqSteps.consuming","title":"<code>consuming()</code>","text":"<p>Starts consuming messages from the queue.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The current step instance for chaining.</p> Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/rabbitmq_steps.py</code> <pre><code>@Context.traced\n@final\ndef consuming(self) -&gt; Self:\n    \"\"\"\n    Starts consuming messages from the queue.\n\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    self._queue_handler.consume()\n    return self\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqSteps.publishing","title":"<code>publishing(messages)</code>","text":"<p>Publishes the provided messages to the queue.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>Iterable[Message[V]]</code> <p>The messages to publish.</p> required <p>Returns:     Self: The current step instance for chaining.</p> Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/rabbitmq_steps.py</code> <pre><code>@Context.traced\n@final\ndef publishing(self, messages: Iterable[Message[V]]) -&gt; Self:\n    \"\"\"\n    Publishes the provided messages to the queue.\n\n    Args:\n        messages (Iterable[Message[V]]): The messages to publish.\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    self._queue_handler.publish(iter(messages))\n    return self\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqSteps.the_message_by_key","title":"<code>the_message_by_key(key, by_rule)</code>","text":"<p>Asserts that the message with the given key matches the provided matcher rule.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>K</code> <p>The key to look up.</p> required <code>by_rule</code> <code>Matcher[Message[V]]</code> <p>Matcher for the message.</p> required <p>Returns:     Self: The current step instance for chaining.</p> Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/rabbitmq_steps.py</code> <pre><code>@Context.traced\n@final\ndef the_message_by_key(\n        self, key: K, by_rule: Matcher[Message[V]]) -&gt; Self:\n    \"\"\"\n    Asserts that the message with the given key matches the provided matcher rule.\n\n    Args:\n        key (K): The key to look up.\n        by_rule (Matcher[Message[V]]): Matcher for the message.\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    return self.eventually_assert_that(\n        lambda: require_not_none(\n            self._queue_handler.received_messages.get(key)),\n        by_rule)\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqSteps.the_received_messages","title":"<code>the_received_messages(by_rule)</code>","text":"<p>Asserts that the received messages match the provided matcher rule.</p> <p>Parameters:</p> Name Type Description Default <code>by_rule</code> <code>Matcher[Iterator[Message[V]]]</code> <p>Matcher for the received messages iterator.</p> required <p>Returns:     Self: The current step instance for chaining.</p> Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/rabbitmq_steps.py</code> <pre><code>@Context.traced\n@final\ndef the_received_messages(\n        self, by_rule: Matcher[Iterator[Message[V]]]) -&gt; Self:\n    \"\"\"\n    Asserts that the received messages match the provided matcher rule.\n\n    Args:\n        by_rule (Matcher[Iterator[Message[V]]]): Matcher for the received messages iterator.\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    return self.eventually_assert_that(\n        lambda: iter(self._queue_handler.received_messages.values()),\n        by_rule)\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqTests","title":"<code>RabbitMqTests</code>","text":"<p>               Bases: <code>AbstractTestsBase[TSteps, TConfiguration]</code></p> <p>Base class for BDD-style RabbitMQ integration tests. Manages the lifecycle of a RabbitMQ connection for test scenarios.</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>K</code> <p>The type of the message key.</p> required <code>V</code> <p>The type of the message content.</p> required <code>TSteps</code> <code>RabbitMqSteps[Any, Any, Any]</code> <p>The steps implementation type.</p> required <code>TConfiguration</code> <code>RabbitMqConfiguration</code> <p>The configuration type, must be a RabbitMqConfiguration.</p> required Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/rabbitmq_tests.py</code> <pre><code>class RabbitMqTests[\n    K,\n    V,\n    TSteps: RabbitMqSteps[Any, Any, Any],\n    TConfiguration: RabbitMqConfiguration\n](AbstractTestsBase[TSteps, TConfiguration]):\n    \"\"\"\n    Base class for BDD-style RabbitMQ integration tests.\n    Manages the lifecycle of a RabbitMQ connection for test scenarios.\n\n    Type Args:\n        K: The type of the message key.\n        V: The type of the message content.\n        TSteps: The steps implementation type.\n        TConfiguration: The configuration type, must be a RabbitMqConfiguration.\n    \"\"\"\n    _connection: pika.BlockingConnection\n\n    @override\n    def setup_method(self):\n        \"\"\"\n        Sets up the RabbitMQ connection before each test method.\n        \"\"\"\n        super().setup_method()\n        self._connection = pika.BlockingConnection(\n            self._configuration.connection_uri)\n\n    @override\n    def teardown_method(self):\n        \"\"\"\n        Tears down the RabbitMQ connection after each test method.\n        \"\"\"\n        try:\n            self._connection.close()\n        finally:\n            super().teardown_method()\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqTests.setup_method","title":"<code>setup_method()</code>","text":"<p>Sets up the RabbitMQ connection before each test method.</p> Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/rabbitmq_tests.py</code> <pre><code>@override\ndef setup_method(self):\n    \"\"\"\n    Sets up the RabbitMQ connection before each test method.\n    \"\"\"\n    super().setup_method()\n    self._connection = pika.BlockingConnection(\n        self._configuration.connection_uri)\n</code></pre>"},{"location":"api/qa-pytest-rabbitmq/#qa_pytest_rabbitmq.RabbitMqTests.teardown_method","title":"<code>teardown_method()</code>","text":"<p>Tears down the RabbitMQ connection after each test method.</p> Source code in <code>qa-pytest-rabbitmq/src/qa_pytest_rabbitmq/rabbitmq_tests.py</code> <pre><code>@override\ndef teardown_method(self):\n    \"\"\"\n    Tears down the RabbitMQ connection after each test method.\n    \"\"\"\n    try:\n        self._connection.close()\n    finally:\n        super().teardown_method()\n</code></pre>"},{"location":"api/qa-pytest-rest/","title":"REST","text":""},{"location":"api/qa-pytest-rest/#qa_pytest_rest","title":"<code>qa_pytest_rest</code>","text":""},{"location":"api/qa-pytest-rest/#qa_pytest_rest.__all__","title":"<code>__all__ = ['HttpMethod', 'RestConfiguration', 'RestSteps', 'RestTests']</code>  <code>module-attribute</code>","text":""},{"location":"api/qa-pytest-rest/#qa_pytest_rest.HttpMethod","title":"<code>HttpMethod</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum representing HTTP methods for REST requests.</p> Source code in <code>qa-pytest-rest/src/qa_pytest_rest/rest_steps.py</code> <pre><code>class HttpMethod(str, Enum):\n    \"\"\"\n    Enum representing HTTP methods for REST requests.\n    \"\"\"\n    GET = \"GET\"\n    POST = \"POST\"\n    PUT = \"PUT\"\n    DELETE = \"DELETE\"\n    PATCH = \"PATCH\"\n</code></pre>"},{"location":"api/qa-pytest-rest/#qa_pytest_rest.HttpMethod.DELETE","title":"<code>DELETE = 'DELETE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rest/#qa_pytest_rest.HttpMethod.GET","title":"<code>GET = 'GET'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rest/#qa_pytest_rest.HttpMethod.PATCH","title":"<code>PATCH = 'PATCH'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rest/#qa_pytest_rest.HttpMethod.POST","title":"<code>POST = 'POST'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rest/#qa_pytest_rest.HttpMethod.PUT","title":"<code>PUT = 'PUT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-rest/#qa_pytest_rest.RestConfiguration","title":"<code>RestConfiguration</code>","text":"<p>               Bases: <code>BaseConfiguration</code></p> <p>Configuration class for REST API endpoints.</p> Inherits from <p>BaseConfiguration</p> Source code in <code>qa-pytest-rest/src/qa_pytest_rest/rest_configuration.py</code> <pre><code>class RestConfiguration(BaseConfiguration):\n    \"\"\"\n    Configuration class for REST API endpoints.\n\n    Inherits from:\n        BaseConfiguration\n    \"\"\"\n\n    @final\n    @cached_property\n    def base_url(self) -&gt; str:\n        \"\"\"\n        Returns the base URL for the endpoint from the configuration parser.\n\n        Returns:\n            str: The base URL specified in the configuration under the 'rest/base_url' key.\n        \"\"\"\n        return self.parser[\"rest\"][\"base_url\"]\n\n    def resource_uri(self, path: str = EMPTY_STRING) -&gt; str:\n        \"\"\"\n        Constructs and returns the full endpoint URL by joining the base endpoint URL with the specified path.\n\n        Args:\n            path (str, optional): The path to append to the base endpoint URL. Defaults to EMPTY_STRING.\n\n        Returns:\n            str: The complete URL formed by joining the base endpoint and the provided path.\n        \"\"\"\n        return urljoin(self.base_url, path)\n</code></pre>"},{"location":"api/qa-pytest-rest/#qa_pytest_rest.RestConfiguration.base_url","title":"<code>base_url</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the base URL for the endpoint from the configuration parser.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The base URL specified in the configuration under the 'rest/base_url' key.</p>"},{"location":"api/qa-pytest-rest/#qa_pytest_rest.RestConfiguration.resource_uri","title":"<code>resource_uri(path=EMPTY_STRING)</code>","text":"<p>Constructs and returns the full endpoint URL by joining the base endpoint URL with the specified path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to append to the base endpoint URL. Defaults to EMPTY_STRING.</p> <code>EMPTY_STRING</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The complete URL formed by joining the base endpoint and the provided path.</p> Source code in <code>qa-pytest-rest/src/qa_pytest_rest/rest_configuration.py</code> <pre><code>def resource_uri(self, path: str = EMPTY_STRING) -&gt; str:\n    \"\"\"\n    Constructs and returns the full endpoint URL by joining the base endpoint URL with the specified path.\n\n    Args:\n        path (str, optional): The path to append to the base endpoint URL. Defaults to EMPTY_STRING.\n\n    Returns:\n        str: The complete URL formed by joining the base endpoint and the provided path.\n    \"\"\"\n    return urljoin(self.base_url, path)\n</code></pre>"},{"location":"api/qa-pytest-rest/#qa_pytest_rest.RestSteps","title":"<code>RestSteps</code>","text":"<p>               Bases: <code>GenericSteps[TConfiguration]</code></p> <p>BDD-style step definitions for REST API operations.</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>TConfiguration</code> <code>RestConfiguration</code> <p>The configuration type, must be a RestConfiguration.</p> required <p>Attributes:</p> Name Type Description <code>_rest_session</code> <code>Session</code> <p>The HTTP session used for sending REST requests.</p> Source code in <code>qa-pytest-rest/src/qa_pytest_rest/rest_steps.py</code> <pre><code>class RestSteps[TConfiguration: RestConfiguration](\n        GenericSteps[TConfiguration]):\n    \"\"\"\n    BDD-style step definitions for REST API operations.\n\n    Type Parameters:\n        TConfiguration: The configuration type, must be a RestConfiguration.\n\n    Attributes:\n        _rest_session (requests.Session): The HTTP session used for sending REST requests.\n    \"\"\"\n    _rest_session: requests.Session\n\n    @final\n    def _invoke(self, request: Request) -&gt; Response:\n        \"\"\"\n        Sends the given HTTP request using the configured session.\n\n        Args:\n            request (Request): The HTTP request to send.\n        Returns:\n            Response: The HTTP response.\n        \"\"\"\n        return self._rest_session.send(\n            self._rest_session.prepare_request(request))\n\n    @Context.traced\n    @final\n    def invoking(self, request: Request) -&gt; Self:\n        \"\"\"\n        Send a REST request and assert that the response is OK.\n\n        Args:\n            request (Request): The HTTP request to send.\n        Returns:\n            Self: Enables method chaining.\n        Raises:\n            AssertionError: If the response is not OK.\n        \"\"\"\n        return self.eventually_assert_that(\n            lambda: self._invoke(request).ok, is_(True))\n\n    @Context.traced\n    @final\n    def the_invocation(\n            self, request: Request, by_rule: Matcher[Response]) -&gt; Self:\n        \"\"\"\n        Send a REST request and assert that the response matches the given matcher.\n\n        Args:\n            request (Request): The HTTP request to send.\n            by_rule (Matcher[Response]): The matcher to apply to the response.\n        Returns:\n            Self: Enables method chaining.\n        Raises:\n            AssertionError: If the response does not match the rule.\n        \"\"\"\n        return self.eventually_assert_that(\n            lambda: self._invoke(request),\n            by_rule)\n</code></pre>"},{"location":"api/qa-pytest-rest/#qa_pytest_rest.RestSteps.invoking","title":"<code>invoking(request)</code>","text":"<p>Send a REST request and assert that the response is OK.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The HTTP request to send.</p> required <p>Returns:     Self: Enables method chaining. Raises:     AssertionError: If the response is not OK.</p> Source code in <code>qa-pytest-rest/src/qa_pytest_rest/rest_steps.py</code> <pre><code>@Context.traced\n@final\ndef invoking(self, request: Request) -&gt; Self:\n    \"\"\"\n    Send a REST request and assert that the response is OK.\n\n    Args:\n        request (Request): The HTTP request to send.\n    Returns:\n        Self: Enables method chaining.\n    Raises:\n        AssertionError: If the response is not OK.\n    \"\"\"\n    return self.eventually_assert_that(\n        lambda: self._invoke(request).ok, is_(True))\n</code></pre>"},{"location":"api/qa-pytest-rest/#qa_pytest_rest.RestSteps.the_invocation","title":"<code>the_invocation(request, by_rule)</code>","text":"<p>Send a REST request and assert that the response matches the given matcher.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The HTTP request to send.</p> required <code>by_rule</code> <code>Matcher[Response]</code> <p>The matcher to apply to the response.</p> required <p>Returns:     Self: Enables method chaining. Raises:     AssertionError: If the response does not match the rule.</p> Source code in <code>qa-pytest-rest/src/qa_pytest_rest/rest_steps.py</code> <pre><code>@Context.traced\n@final\ndef the_invocation(\n        self, request: Request, by_rule: Matcher[Response]) -&gt; Self:\n    \"\"\"\n    Send a REST request and assert that the response matches the given matcher.\n\n    Args:\n        request (Request): The HTTP request to send.\n        by_rule (Matcher[Response]): The matcher to apply to the response.\n    Returns:\n        Self: Enables method chaining.\n    Raises:\n        AssertionError: If the response does not match the rule.\n    \"\"\"\n    return self.eventually_assert_that(\n        lambda: self._invoke(request),\n        by_rule)\n</code></pre>"},{"location":"api/qa-pytest-rest/#qa_pytest_rest.RestTests","title":"<code>RestTests</code>","text":"<p>               Bases: <code>AbstractTestsBase[TSteps, TConfiguration]</code></p> <p>Base class for REST API test cases.</p> <p>This class provides a reusable test base for REST API testing, managing a <code>requests.Session</code> for each test method. It is generic over the types of steps and configuration used.</p> <p>Attributes:</p> Name Type Description <code>_rest_session</code> <code>Session</code> <p>The HTTP session used for making REST requests. Not thread-safe.</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>TSteps</code> <code>RestSteps[Any]</code> <p>The type of the steps class, typically derived from RestSteps.</p> required <code>TConfiguration</code> <code>RestConfiguration</code> <p>The type of the configuration class, typically derived from RestConfiguration.</p> required Source code in <code>qa-pytest-rest/src/qa_pytest_rest/rest_tests.py</code> <pre><code>class RestTests[\n    TSteps: RestSteps[Any],\n    TConfiguration: RestConfiguration\n](AbstractTestsBase[TSteps, TConfiguration]):\n    \"\"\"\n    Base class for REST API test cases.\n\n    This class provides a reusable test base for REST API testing, managing a `requests.Session`\n    for each test method. It is generic over the types of steps and configuration used.\n\n    Attributes:\n        _rest_session (requests.Session): The HTTP session used for making REST requests. Not thread-safe.\n\n    Type Parameters:\n        TSteps: The type of the steps class, typically derived from RestSteps.\n        TConfiguration: The type of the configuration class, typically derived from RestConfiguration.\n    \"\"\"\n    _rest_session: requests.Session  # not thread safe\n\n    @property\n    def rest_session(self) -&gt; requests.Session:\n        \"\"\"\n        Returns the HTTP session used for making REST requests.\n\n        Returns:\n            requests.Session: The HTTP session instance.\n        \"\"\"\n        return self._rest_session\n\n    @override\n    def setup_method(self):\n        \"\"\"\n        Initializes a new requests.Session before each test method.\n        \"\"\"\n        super().setup_method()\n        self._rest_session = requests.Session()\n\n    @override\n    def teardown_method(self):\n        \"\"\"\n        Closes the requests.Session after each test method.\n        \"\"\"\n        try:\n            self._rest_session.close()\n        finally:\n            super().teardown_method()\n</code></pre>"},{"location":"api/qa-pytest-rest/#qa_pytest_rest.RestTests.rest_session","title":"<code>rest_session</code>  <code>property</code>","text":"<p>Returns the HTTP session used for making REST requests.</p> <p>Returns:</p> Type Description <code>Session</code> <p>requests.Session: The HTTP session instance.</p>"},{"location":"api/qa-pytest-rest/#qa_pytest_rest.RestTests.setup_method","title":"<code>setup_method()</code>","text":"<p>Initializes a new requests.Session before each test method.</p> Source code in <code>qa-pytest-rest/src/qa_pytest_rest/rest_tests.py</code> <pre><code>@override\ndef setup_method(self):\n    \"\"\"\n    Initializes a new requests.Session before each test method.\n    \"\"\"\n    super().setup_method()\n    self._rest_session = requests.Session()\n</code></pre>"},{"location":"api/qa-pytest-rest/#qa_pytest_rest.RestTests.teardown_method","title":"<code>teardown_method()</code>","text":"<p>Closes the requests.Session after each test method.</p> Source code in <code>qa-pytest-rest/src/qa_pytest_rest/rest_tests.py</code> <pre><code>@override\ndef teardown_method(self):\n    \"\"\"\n    Closes the requests.Session after each test method.\n    \"\"\"\n    try:\n        self._rest_session.close()\n    finally:\n        super().teardown_method()\n</code></pre>"},{"location":"api/qa-pytest-webdriver/","title":"WebDriver","text":""},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver","title":"<code>qa_pytest_webdriver</code>","text":""},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.__all__","title":"<code>__all__ = ['By', 'Locator', 'SearchContext', 'SeleniumConfiguration', 'SeleniumSteps', 'SeleniumTests']</code>  <code>module-attribute</code>","text":""},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.By","title":"<code>By</code>","text":"<p>Factory for Selenium locators, matching Selenium's By API.</p> <p>Provides static methods to create Locator objects for each Selenium locator strategy.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>class By:\n    \"\"\"\n    Factory for Selenium locators, matching Selenium's By API.\n\n    Provides static methods to create Locator objects for each Selenium locator strategy.\n    \"\"\"\n\n    @staticmethod\n    def id(value: str) -&gt; Locator:\n        \"\"\"\n        Creates a locator for elements with the given id attribute.\n\n        Args:\n            value (str): The id value.\n        Returns:\n            Locator: The locator object.\n        \"\"\"\n        return Locator(_By.ID, value)\n\n    @staticmethod\n    def xpath(value: str) -&gt; Locator:\n        \"\"\"\n        Creates a locator for elements matching the given XPath expression.\n\n        Args:\n            value (str): The XPath expression.\n        Returns:\n            Locator: The locator object.\n        \"\"\"\n        return Locator(_By.XPATH, value)\n\n    @staticmethod\n    def link_text(value: str) -&gt; Locator:\n        \"\"\"\n        Creates a locator for elements with the given link text.\n\n        Args:\n            value (str): The link text.\n        Returns:\n            Locator: The locator object.\n        \"\"\"\n        return Locator(_By.LINK_TEXT, value)\n\n    @staticmethod\n    def partial_link_text(value: str) -&gt; Locator:\n        \"\"\"\n        Creates a locator for elements with the given partial link text.\n\n        Args:\n            value (str): The partial link text.\n        Returns:\n            Locator: The locator object.\n        \"\"\"\n        return Locator(_By.PARTIAL_LINK_TEXT, value)\n\n    @staticmethod\n    def name(value: str) -&gt; Locator:\n        \"\"\"\n        Creates a locator for elements with the given name attribute.\n\n        Args:\n            value (str): The name value.\n        Returns:\n            Locator: The locator object.\n        \"\"\"\n        return Locator(_By.NAME, value)\n\n    @staticmethod\n    def tag_name(value: str) -&gt; Locator:\n        \"\"\"\n        Creates a locator for elements with the given tag name.\n\n        Args:\n            value (str): The tag name.\n        Returns:\n            Locator: The locator object.\n        \"\"\"\n        return Locator(_By.TAG_NAME, value)\n\n    @staticmethod\n    def class_name(value: str) -&gt; Locator:\n        \"\"\"\n        Creates a locator for elements with the given class name.\n\n        Args:\n            value (str): The class name.\n        Returns:\n            Locator: The locator object.\n        \"\"\"\n        return Locator(_By.CLASS_NAME, value)\n\n    @staticmethod\n    def css_selector(value: str) -&gt; Locator:\n        \"\"\"\n        Creates a locator for elements matching the given CSS selector.\n\n        Args:\n            value (str): The CSS selector.\n        Returns:\n            Locator: The locator object.\n        \"\"\"\n        return Locator(_By.CSS_SELECTOR, value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.By.class_name","title":"<code>class_name(value)</code>  <code>staticmethod</code>","text":"<p>Creates a locator for elements with the given class name.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The class name.</p> required <p>Returns:     Locator: The locator object.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@staticmethod\ndef class_name(value: str) -&gt; Locator:\n    \"\"\"\n    Creates a locator for elements with the given class name.\n\n    Args:\n        value (str): The class name.\n    Returns:\n        Locator: The locator object.\n    \"\"\"\n    return Locator(_By.CLASS_NAME, value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.By.css_selector","title":"<code>css_selector(value)</code>  <code>staticmethod</code>","text":"<p>Creates a locator for elements matching the given CSS selector.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The CSS selector.</p> required <p>Returns:     Locator: The locator object.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@staticmethod\ndef css_selector(value: str) -&gt; Locator:\n    \"\"\"\n    Creates a locator for elements matching the given CSS selector.\n\n    Args:\n        value (str): The CSS selector.\n    Returns:\n        Locator: The locator object.\n    \"\"\"\n    return Locator(_By.CSS_SELECTOR, value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.By.id","title":"<code>id(value)</code>  <code>staticmethod</code>","text":"<p>Creates a locator for elements with the given id attribute.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The id value.</p> required <p>Returns:     Locator: The locator object.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@staticmethod\ndef id(value: str) -&gt; Locator:\n    \"\"\"\n    Creates a locator for elements with the given id attribute.\n\n    Args:\n        value (str): The id value.\n    Returns:\n        Locator: The locator object.\n    \"\"\"\n    return Locator(_By.ID, value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.By.link_text","title":"<code>link_text(value)</code>  <code>staticmethod</code>","text":"<p>Creates a locator for elements with the given link text.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The link text.</p> required <p>Returns:     Locator: The locator object.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@staticmethod\ndef link_text(value: str) -&gt; Locator:\n    \"\"\"\n    Creates a locator for elements with the given link text.\n\n    Args:\n        value (str): The link text.\n    Returns:\n        Locator: The locator object.\n    \"\"\"\n    return Locator(_By.LINK_TEXT, value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.By.name","title":"<code>name(value)</code>  <code>staticmethod</code>","text":"<p>Creates a locator for elements with the given name attribute.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The name value.</p> required <p>Returns:     Locator: The locator object.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@staticmethod\ndef name(value: str) -&gt; Locator:\n    \"\"\"\n    Creates a locator for elements with the given name attribute.\n\n    Args:\n        value (str): The name value.\n    Returns:\n        Locator: The locator object.\n    \"\"\"\n    return Locator(_By.NAME, value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.By.partial_link_text","title":"<code>partial_link_text(value)</code>  <code>staticmethod</code>","text":"<p>Creates a locator for elements with the given partial link text.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The partial link text.</p> required <p>Returns:     Locator: The locator object.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@staticmethod\ndef partial_link_text(value: str) -&gt; Locator:\n    \"\"\"\n    Creates a locator for elements with the given partial link text.\n\n    Args:\n        value (str): The partial link text.\n    Returns:\n        Locator: The locator object.\n    \"\"\"\n    return Locator(_By.PARTIAL_LINK_TEXT, value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.By.tag_name","title":"<code>tag_name(value)</code>  <code>staticmethod</code>","text":"<p>Creates a locator for elements with the given tag name.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The tag name.</p> required <p>Returns:     Locator: The locator object.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@staticmethod\ndef tag_name(value: str) -&gt; Locator:\n    \"\"\"\n    Creates a locator for elements with the given tag name.\n\n    Args:\n        value (str): The tag name.\n    Returns:\n        Locator: The locator object.\n    \"\"\"\n    return Locator(_By.TAG_NAME, value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.By.xpath","title":"<code>xpath(value)</code>  <code>staticmethod</code>","text":"<p>Creates a locator for elements matching the given XPath expression.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The XPath expression.</p> required <p>Returns:     Locator: The locator object.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@staticmethod\ndef xpath(value: str) -&gt; Locator:\n    \"\"\"\n    Creates a locator for elements matching the given XPath expression.\n\n    Args:\n        value (str): The XPath expression.\n    Returns:\n        Locator: The locator object.\n    \"\"\"\n    return Locator(_By.XPATH, value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.Locator","title":"<code>Locator</code>  <code>dataclass</code>","text":"<p>Represents a Selenium locator as a (by, value) pair.</p> <p>Attributes:</p> Name Type Description <code>by</code> <code>str</code> <p>The Selenium locator strategy (e.g., By.ID, By.XPATH).</p> <code>value</code> <code>str</code> <p>The locator value.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@dataclass(frozen=True)\nclass Locator:\n    \"\"\"\n    Represents a Selenium locator as a (by, value) pair.\n\n    Attributes:\n        by (str): The Selenium locator strategy (e.g., By.ID, By.XPATH).\n        value (str): The locator value.\n    \"\"\"\n    by: str\n    value: str\n\n    def as_tuple(self) -&gt; Tuple[str, str]:\n        \"\"\"\n        Returns the locator as a tuple (by, value), suitable for Selenium APIs.\n\n        Returns:\n            Tuple[str, str]: The locator as a tuple.\n        \"\"\"\n        return (self.by, self.value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.Locator.by","title":"<code>by</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.Locator.value","title":"<code>value</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.Locator.__init__","title":"<code>__init__(by, value)</code>","text":""},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.Locator.as_tuple","title":"<code>as_tuple()</code>","text":"<p>Returns the locator as a tuple (by, value), suitable for Selenium APIs.</p> <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>Tuple[str, str]: The locator as a tuple.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>def as_tuple(self) -&gt; Tuple[str, str]:\n    \"\"\"\n    Returns the locator as a tuple (by, value), suitable for Selenium APIs.\n\n    Returns:\n        Tuple[str, str]: The locator as a tuple.\n    \"\"\"\n    return (self.by, self.value)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SearchContext","title":"<code>SearchContext</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for Selenium search contexts (e.g., WebDriver, WebElement).</p> <p>Provides methods to find single or multiple elements using Selenium's locator strategy.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>class SearchContext(Protocol):\n    \"\"\"\n    Protocol for Selenium search contexts (e.g., WebDriver, WebElement).\n\n    Provides methods to find single or multiple elements using Selenium's locator strategy.\n    \"\"\"\n\n    def find_element(self, by: str, value: Optional[str]) -&gt; WebElement: ...\n\n    def find_elements(\n        self, by: str, value: Optional[str]) -&gt; List[WebElement]: ...\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SearchContext.find_element","title":"<code>find_element(by, value)</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>def find_element(self, by: str, value: Optional[str]) -&gt; WebElement: ...\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SearchContext.find_elements","title":"<code>find_elements(by, value)</code>","text":"Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>def find_elements(\n    self, by: str, value: Optional[str]) -&gt; List[WebElement]: ...\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumConfiguration","title":"<code>SeleniumConfiguration</code>","text":"<p>               Bases: <code>BaseConfiguration</code></p> <p>SeleniumConfiguration extends BaseConfiguration to provide Selenium-specific configuration options.</p> <p>This class exposes properties for retrieving the UI URL and initializing the Selenium WebDriver Service, leveraging configuration values and dynamic driver management.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_configuration.py</code> <pre><code>class SeleniumConfiguration(BaseConfiguration):\n    \"\"\"\n    SeleniumConfiguration extends BaseConfiguration to provide Selenium-specific configuration options.\n\n    This class exposes properties for retrieving the UI URL and initializing the Selenium WebDriver Service,\n    leveraging configuration values and dynamic driver management.\n    \"\"\"\n\n    @cached_property\n    @final\n    def landing_page(self) -&gt; str:\n        \"\"\"\n        Returns the UI URL from the configuration parser.\n\n        Returns:\n            str: The URL string specified under the \"selenium/base\" in the configuration.\n\n        Raises:\n            KeyError: If the \"selenium\" section or \"base\" key is not present in the configuration parser.\n        \"\"\"\n        return self.parser[\"selenium\"][\"landing_page\"]\n\n    # FIXME Service here is imported from selenium.webdriver.chrome.service\n    # which makes this method specific to ChromeDriver.\n    @cached_property\n    @final\n    def service(self) -&gt; Service:\n        \"\"\"\n        Creates and returns a Selenium WebDriver Service instance using the ChromeDriverManager.\n\n        Returns:\n            Service: An instance of Selenium's Service class, initialized with the path to the ChromeDriver executable\n            installed by ChromeDriverManager.\n\n        Note:\n            This method currently supports only ChromeDriver, but may be extended to support different services\n            based on configuration in the future.\n        \"\"\"\n        # NOTE may add support for providing different services per configuration\n        return Service(ChromeDriverManager().install())\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumConfiguration.landing_page","title":"<code>landing_page</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the UI URL from the configuration parser.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The URL string specified under the \"selenium/base\" in the configuration.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the \"selenium\" section or \"base\" key is not present in the configuration parser.</p>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumConfiguration.service","title":"<code>service</code>  <code>cached</code> <code>property</code>","text":"<p>Creates and returns a Selenium WebDriver Service instance using the ChromeDriverManager.</p> <p>Returns:</p> Name Type Description <code>Service</code> <code>Service</code> <p>An instance of Selenium's Service class, initialized with the path to the ChromeDriver executable</p> <code>Service</code> <p>installed by ChromeDriverManager.</p> Note <p>This method currently supports only ChromeDriver, but may be extended to support different services based on configuration in the future.</p>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumSteps","title":"<code>SeleniumSteps</code>","text":"<p>               Bases: <code>GenericSteps[TConfiguration]</code></p> <p>BDD-style step definitions for Selenium-based UI operations.</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>TConfiguration</code> <code>SeleniumConfiguration</code> <p>The configuration type, must be a SeleniumConfiguration.</p> required <p>Attributes:</p> Name Type Description <code>_web_driver</code> <code>WebDriver</code> <p>The Selenium WebDriver instance used for browser automation.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>class SeleniumSteps[TConfiguration: SeleniumConfiguration](\n    GenericSteps[TConfiguration]\n):\n    \"\"\"\n    BDD-style step definitions for Selenium-based UI operations.\n\n    Type Parameters:\n        TConfiguration: The configuration type, must be a SeleniumConfiguration.\n\n    Attributes:\n        _web_driver (WebDriver): The Selenium WebDriver instance used for browser automation.\n    \"\"\"\n    _web_driver: WebDriver\n\n    @final\n    @Context.traced\n    def clicking_once(self, element_supplier: ElementSupplier) -&gt; Self:\n        \"\"\"\n        Clicks the element supplied by the given callable.\n\n        Args:\n            element_supplier (ElementSupplier): Callable returning a WebElement.\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        element_supplier().click()\n        return self\n\n    @overload\n    def clicking(self, element: Locator) -&gt; Self: ...\n\n    @overload\n    def clicking(self, element: ElementSupplier) -&gt; Self: ...\n\n    @final\n    def clicking(self, element: LocatorOrSupplier) -&gt; Self:\n        \"\"\"\n        Clicks the element specified by a locator or supplier, with retry logic.\n\n        Args:\n            element (LocatorOrSupplier): Locator or callable returning a WebElement.\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        return self.retrying(lambda: self.clicking_once(self._resolve(element)))\n\n    @final\n    @Context.traced\n    def typing_once(self, element_supplier: ElementSupplier, text: str) -&gt; Self:\n        \"\"\"\n        Types the given text into the element supplied by the callable.\n\n        Args:\n            element_supplier (ElementSupplier): Callable returning a WebElement.\n            text (str): The text to type.\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        element = element_supplier()\n        element.clear()\n        element.send_keys(text)\n        return self\n\n    @overload\n    def typing(self, element: Locator, text: str) -&gt; Self: ...\n\n    @overload\n    def typing(self, element: ElementSupplier, text: str) -&gt; Self: ...\n\n    @final\n    def typing(self, element: LocatorOrSupplier, text: str) -&gt; Self:\n        \"\"\"\n        Types the given text into the element specified by a locator or supplier, with retry logic.\n\n        Args:\n            element (LocatorOrSupplier): Locator or callable returning a WebElement.\n            text (str): The text to type.\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        return self.retrying(lambda: self.typing_once(self._resolve(element), text))\n\n    @final\n    def the_element(self, locator: Locator, by_rule: Matcher[WebElement], context: Optional[SearchContext] = None) -&gt; Self:\n        \"\"\"\n        Asserts that the element found by the locator matches the given matcher.\n\n        Args:\n            locator (Locator): The locator to find the element.\n            by_rule (Matcher[WebElement]): Matcher for the element.\n            context (Optional[SearchContext]): Optional search context.\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        return self.eventually_assert_that(lambda: self._element(locator, context), by_rule)\n\n    @final\n    def the_elements(self, locator: Locator, by_rule: Matcher[Iterator[WebElement]], context: Optional[SearchContext] = None) -&gt; Self:\n        \"\"\"\n        Asserts that the elements found by the locator match the given matcher.\n\n        Args:\n            locator (Locator): The locator to find the elements.\n            by_rule (Matcher[Iterator[WebElement]]): Matcher for the elements iterator.\n            context (Optional[SearchContext]): Optional search context.\n        Returns:\n            Self: The current step instance for chaining.\n        \"\"\"\n        return self.eventually_assert_that(lambda: self._elements(locator, context), by_rule)\n\n    @final\n    @Context.traced\n    def _elements(\n        self, locator: Locator, context: Optional[SearchContext] = None\n    ) -&gt; Iterator[WebElement]:\n        return iter((context or self._web_driver).find_elements(*locator.as_tuple()))\n\n    @final\n    @Context.traced\n    def _element(\n        self, locator: Locator, context: Optional[SearchContext] = None\n    ) -&gt; WebElement:\n        return self._scroll_into_view(\n            (context or self._web_driver).find_element(*locator.as_tuple())\n        )\n\n    def _scroll_into_view(self, element: WebElement) -&gt; WebElement:\n        self._web_driver.execute_script(  # type: ignore\n            \"arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});\", element)\n        return element\n\n    @final\n    def _resolve(self, element: LocatorOrSupplier) -&gt; ElementSupplier:\n        if isinstance(element, Locator):\n            return lambda: self._element(element)\n        return element\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumSteps.clicking","title":"<code>clicking(element)</code>","text":"<pre><code>clicking(element: Locator) -&gt; Self\n</code></pre><pre><code>clicking(element: ElementSupplier) -&gt; Self\n</code></pre> <p>Clicks the element specified by a locator or supplier, with retry logic.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>LocatorOrSupplier</code> <p>Locator or callable returning a WebElement.</p> required <p>Returns:     Self: The current step instance for chaining.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@final\ndef clicking(self, element: LocatorOrSupplier) -&gt; Self:\n    \"\"\"\n    Clicks the element specified by a locator or supplier, with retry logic.\n\n    Args:\n        element (LocatorOrSupplier): Locator or callable returning a WebElement.\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    return self.retrying(lambda: self.clicking_once(self._resolve(element)))\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumSteps.clicking_once","title":"<code>clicking_once(element_supplier)</code>","text":"<p>Clicks the element supplied by the given callable.</p> <p>Parameters:</p> Name Type Description Default <code>element_supplier</code> <code>ElementSupplier</code> <p>Callable returning a WebElement.</p> required <p>Returns:     Self: The current step instance for chaining.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@final\n@Context.traced\ndef clicking_once(self, element_supplier: ElementSupplier) -&gt; Self:\n    \"\"\"\n    Clicks the element supplied by the given callable.\n\n    Args:\n        element_supplier (ElementSupplier): Callable returning a WebElement.\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    element_supplier().click()\n    return self\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumSteps.the_element","title":"<code>the_element(locator, by_rule, context=None)</code>","text":"<p>Asserts that the element found by the locator matches the given matcher.</p> <p>Parameters:</p> Name Type Description Default <code>locator</code> <code>Locator</code> <p>The locator to find the element.</p> required <code>by_rule</code> <code>Matcher[WebElement]</code> <p>Matcher for the element.</p> required <code>context</code> <code>Optional[SearchContext]</code> <p>Optional search context.</p> <code>None</code> <p>Returns:     Self: The current step instance for chaining.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@final\ndef the_element(self, locator: Locator, by_rule: Matcher[WebElement], context: Optional[SearchContext] = None) -&gt; Self:\n    \"\"\"\n    Asserts that the element found by the locator matches the given matcher.\n\n    Args:\n        locator (Locator): The locator to find the element.\n        by_rule (Matcher[WebElement]): Matcher for the element.\n        context (Optional[SearchContext]): Optional search context.\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    return self.eventually_assert_that(lambda: self._element(locator, context), by_rule)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumSteps.the_elements","title":"<code>the_elements(locator, by_rule, context=None)</code>","text":"<p>Asserts that the elements found by the locator match the given matcher.</p> <p>Parameters:</p> Name Type Description Default <code>locator</code> <code>Locator</code> <p>The locator to find the elements.</p> required <code>by_rule</code> <code>Matcher[Iterator[WebElement]]</code> <p>Matcher for the elements iterator.</p> required <code>context</code> <code>Optional[SearchContext]</code> <p>Optional search context.</p> <code>None</code> <p>Returns:     Self: The current step instance for chaining.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@final\ndef the_elements(self, locator: Locator, by_rule: Matcher[Iterator[WebElement]], context: Optional[SearchContext] = None) -&gt; Self:\n    \"\"\"\n    Asserts that the elements found by the locator match the given matcher.\n\n    Args:\n        locator (Locator): The locator to find the elements.\n        by_rule (Matcher[Iterator[WebElement]]): Matcher for the elements iterator.\n        context (Optional[SearchContext]): Optional search context.\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    return self.eventually_assert_that(lambda: self._elements(locator, context), by_rule)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumSteps.typing","title":"<code>typing(element, text)</code>","text":"<pre><code>typing(element: Locator, text: str) -&gt; Self\n</code></pre><pre><code>typing(element: ElementSupplier, text: str) -&gt; Self\n</code></pre> <p>Types the given text into the element specified by a locator or supplier, with retry logic.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>LocatorOrSupplier</code> <p>Locator or callable returning a WebElement.</p> required <code>text</code> <code>str</code> <p>The text to type.</p> required <p>Returns:     Self: The current step instance for chaining.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@final\ndef typing(self, element: LocatorOrSupplier, text: str) -&gt; Self:\n    \"\"\"\n    Types the given text into the element specified by a locator or supplier, with retry logic.\n\n    Args:\n        element (LocatorOrSupplier): Locator or callable returning a WebElement.\n        text (str): The text to type.\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    return self.retrying(lambda: self.typing_once(self._resolve(element), text))\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumSteps.typing_once","title":"<code>typing_once(element_supplier, text)</code>","text":"<p>Types the given text into the element supplied by the callable.</p> <p>Parameters:</p> Name Type Description Default <code>element_supplier</code> <code>ElementSupplier</code> <p>Callable returning a WebElement.</p> required <code>text</code> <code>str</code> <p>The text to type.</p> required <p>Returns:     Self: The current step instance for chaining.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_steps.py</code> <pre><code>@final\n@Context.traced\ndef typing_once(self, element_supplier: ElementSupplier, text: str) -&gt; Self:\n    \"\"\"\n    Types the given text into the element supplied by the callable.\n\n    Args:\n        element_supplier (ElementSupplier): Callable returning a WebElement.\n        text (str): The text to type.\n    Returns:\n        Self: The current step instance for chaining.\n    \"\"\"\n    element = element_supplier()\n    element.clear()\n    element.send_keys(text)\n    return self\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumTests","title":"<code>SeleniumTests</code>","text":"<p>               Bases: <code>AbstractTestsBase[TSteps, TConfiguration]</code></p> <p>Base class for Selenium-based UI test cases.</p> <p>This class manages the lifecycle of a Selenium WebDriver for each test method. It is generic over the types of steps and configuration used.</p> <p>Attributes:</p> Name Type Description <code>_web_driver</code> <code>WebDriver</code> <p>The Selenium WebDriver instance (not thread safe).</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>TSteps</code> <code>SeleniumSteps[Any]</code> <p>The type of the steps class, typically derived from SeleniumSteps.</p> required <code>TConfiguration</code> <code>SeleniumConfiguration</code> <p>The type of the configuration class, typically derived from SeleniumConfiguration.</p> required Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_tests.py</code> <pre><code>class SeleniumTests[\n    TSteps: SeleniumSteps[Any],\n    TConfiguration: SeleniumConfiguration\n](AbstractTestsBase[TSteps, TConfiguration]):\n    \"\"\"\n    Base class for Selenium-based UI test cases.\n\n    This class manages the lifecycle of a Selenium WebDriver for each test method.\n    It is generic over the types of steps and configuration used.\n\n    Attributes:\n        _web_driver (WebDriver): The Selenium WebDriver instance (not thread safe).\n\n    Type Parameters:\n        TSteps: The type of the steps class, typically derived from SeleniumSteps.\n        TConfiguration: The type of the configuration class, typically derived from SeleniumConfiguration.\n    \"\"\"\n    _web_driver: WebDriver  # not thread safe\n\n    @property\n    def web_driver(self) -&gt; WebDriver:\n        '''\n        Returns the web driver instance.\n\n        Returns:\n            WebDriver: The web driver instance.\n        '''\n        return self._web_driver\n\n    @override\n    def setup_method(self):\n        '''\n        Initializes a local Chrome WebDriver before each test method.\n\n        If you need to customize or use other driver, override this method in your test class.\n        '''\n        super().setup_method()\n\n        options = Options()\n        options.add_argument(\"--start-maximized\")  # type: ignore\n        self._web_driver = Chrome(\n            options,\n            self._configuration.service)\n\n    @override\n    def teardown_method(self):\n        '''\n        Quits the Selenium WebDriver after each test method.\n        '''\n        try:\n            self._web_driver.quit()\n        finally:\n            super().teardown_method()\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumTests.web_driver","title":"<code>web_driver</code>  <code>property</code>","text":"<p>Returns the web driver instance.</p> <p>Returns:</p> Name Type Description <code>WebDriver</code> <code>WebDriver</code> <p>The web driver instance.</p>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumTests.setup_method","title":"<code>setup_method()</code>","text":"<p>Initializes a local Chrome WebDriver before each test method.</p> <p>If you need to customize or use other driver, override this method in your test class.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_tests.py</code> <pre><code>@override\ndef setup_method(self):\n    '''\n    Initializes a local Chrome WebDriver before each test method.\n\n    If you need to customize or use other driver, override this method in your test class.\n    '''\n    super().setup_method()\n\n    options = Options()\n    options.add_argument(\"--start-maximized\")  # type: ignore\n    self._web_driver = Chrome(\n        options,\n        self._configuration.service)\n</code></pre>"},{"location":"api/qa-pytest-webdriver/#qa_pytest_webdriver.SeleniumTests.teardown_method","title":"<code>teardown_method()</code>","text":"<p>Quits the Selenium WebDriver after each test method.</p> Source code in <code>qa-pytest-webdriver/src/qa_pytest_webdriver/selenium_tests.py</code> <pre><code>@override\ndef teardown_method(self):\n    '''\n    Quits the Selenium WebDriver after each test method.\n    '''\n    try:\n        self._web_driver.quit()\n    finally:\n        super().teardown_method()\n</code></pre>"},{"location":"api/qa-testing-utils/","title":"Utils","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils","title":"<code>qa_testing_utils</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.__all__","title":"<code>__all__ = ['ContainsStringIgnoringCase', 'Context', 'FromTupleMixin', 'ImmutableMixin', 'InvalidValueException', 'IsIteratorYielding', 'IsIteratorYieldingAll', 'IsStreamContainingEvery', 'IsWithinDates', 'IterableReader', 'LoggerMixin', 'SingletonBase', 'SingletonMeta', 'TestException', 'ThreadLocal', 'ToDictMixin', 'TracingMatcher', 'Valid', 'WithMixin', 'adapted_iterator', 'adapted_object', 'adapted_sequence', 'classproperty', 'contains_string_ignoring_case', 'crc32_of', 'decompress_xz_stream', 'extract_files_from_tar', 'get_config_overrides', 'logger', 'match_as', 'process_next', 'pytest_addoption', 'pytest_configure', 'pytest_runtest_makereport', 'read_lines', 'require_not_none', 'safely', 'sleep_for', 'stream_file', 'swallow', 'to_string', 'trace', 'tracing', 'valid', 'within_dates', 'write_csv', 'yields_every', 'yields_item', 'yields_items']</code>  <code>module-attribute</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.ContainsStringIgnoringCase","title":"<code>ContainsStringIgnoringCase</code>","text":"<p>               Bases: <code>BaseMatcher[str]</code></p> <p>Matcher that checks if a string contains a given substring, ignoring case.</p> <p>Parameters:</p> Name Type Description Default <code>substring</code> <code>str</code> <p>The substring to search for (case-insensitive).</p> required Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>@final\nclass ContainsStringIgnoringCase(BaseMatcher[str]):\n    \"\"\"\n    Matcher that checks if a string contains a given substring, ignoring case.\n\n    Args:\n        substring (str): The substring to search for (case-insensitive).\n    \"\"\"\n\n    def __init__(self, substring: str) -&gt; None:\n        self.substring: str = substring.lower()\n\n    def _matches(self, item: Any) -&gt; bool:\n        if not isinstance(item, str):\n            return False\n        return self.substring in item.lower()\n\n    def describe_to(self, description: Description) -&gt; None:\n        description.append_text(\n            f\"a string containing (case-insensitive) '{self.substring}'\")\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ContainsStringIgnoringCase.substring","title":"<code>substring = substring.lower()</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.ContainsStringIgnoringCase.__init__","title":"<code>__init__(substring)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def __init__(self, substring: str) -&gt; None:\n    self.substring: str = substring.lower()\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ContainsStringIgnoringCase.describe_to","title":"<code>describe_to(description)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def describe_to(self, description: Description) -&gt; None:\n    description.append_text(\n        f\"a string containing (case-insensitive) '{self.substring}'\")\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.Context","title":"<code>Context</code>  <code>dataclass</code>","text":"<p>Per-thread context for reporting and logging, allowing dynamic formatting of messages.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/logger.py</code> <pre><code>@dataclass\n@final\nclass Context:\n    \"\"\"Per-thread context for reporting and logging, allowing dynamic formatting of messages.\"\"\"\n    _THREAD_LOCAL: ClassVar[ThreadLocal['Context']]\n    _formatter: Final[Callable[[str], str]]\n\n    @classmethod\n    def default(cls) -&gt; \"Context\":\n        \"\"\"\n        Returns a default Context instance with a no-op formatter.\n\n        Returns:\n            Context: A Context instance with the identity formatter.\n        \"\"\"\n        return cls(lambda _: _)  # no formatter\n\n    @classproperty\n    def _format(cls) -&gt; Callable[[str], str]:\n        return cls._THREAD_LOCAL.get()._formatter\n\n    @classmethod\n    def set(cls, context_fn: Callable[[str], str]) -&gt; None:\n        \"\"\"Sets per-thread context function to be used for formatting report and log messages.\"\"\"\n        cls._THREAD_LOCAL.set(Context(context_fn))\n\n    @classmethod\n    def traced(cls, func: Callable[_P, _R]) -&gt; Callable[_P, _R]:\n        \"\"\"\n        Decorator to log function entry, arguments, and return value at DEBUG level.\n\n        Also adds an Allure step for reporting. Use on methods where tracing is useful\n        for debugging or reporting.\n\n        Example:\n            @Context.traced\n            def my_method(self, x):\n                ...\n\n        Args:\n            func (Callable[P, R]): The function to be decorated.\n            *args (Any): Positional arguments to be passed to the function.\n            **kwargs (Any): Keyword arguments to be passed to the function.\n\n        Returns:\n            Callable[P, R]: The result of the function call.\n        \"\"\"\n        @wraps(func)\n        def wrapper(*args: _P.args, **kwargs: _P.kwargs) -&gt; _R:\n            # NOTE: each time a decorated function is called this logic will be\n            # re-evaluated.\n            signature = inspect.signature(func)\n            parameters = list(signature.parameters.keys())\n\n            if parameters and parameters[0] == 'self' and len(args) &gt; 0:\n                instance = args[0]\n                logger = logging.getLogger(f\"{instance.__class__.__name__}\")\n                logger.debug(f\"&gt;&gt;&gt; \"\n                             + cls._format(\n                                 f\"{func.__name__} \"\n                                 f\"{\", \".join([str(arg) for arg in args[1:]])} \"\n                                 f\"{LF.join(\n                                     f\"{key}={str(value)}\"\n                                     for key, value in kwargs.items()) if kwargs else EMPTY_STRING}\"))\n\n                with allure.step(  # type: ignore\n                    cls._format(\n                        f\"{func.__name__} \"\n                        f\"{', '.join([str(arg) for arg in args[1:]])}\")):\n                    result = func(*args, **kwargs)\n\n                if result == instance:\n                    logger.debug(f\"&lt;&lt;&lt; \" + cls._format(f\"{func.__name__}\"))\n                else:\n                    logger.debug(\n                        f\"&lt;&lt;&lt; \" + cls._format(f\"{func.__name__} {result}\"))\n\n                return result\n            else:\n                logger = logging.getLogger(func.__name__)\n                logger.debug(f\"&gt;&gt;&gt; {func.__name__} {args} {kwargs}\")\n                result = func(*args, **kwargs)\n                logger.debug(f\"&lt;&lt;&lt; {func.__name__} {result}\")\n                return result\n\n        return wrapper\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.Context.__init__","title":"<code>__init__(_formatter)</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.Context.default","title":"<code>default()</code>  <code>classmethod</code>","text":"<p>Returns a default Context instance with a no-op formatter.</p> <p>Returns:</p> Name Type Description <code>Context</code> <code>Context</code> <p>A Context instance with the identity formatter.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/logger.py</code> <pre><code>@classmethod\ndef default(cls) -&gt; \"Context\":\n    \"\"\"\n    Returns a default Context instance with a no-op formatter.\n\n    Returns:\n        Context: A Context instance with the identity formatter.\n    \"\"\"\n    return cls(lambda _: _)  # no formatter\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.Context.set","title":"<code>set(context_fn)</code>  <code>classmethod</code>","text":"<p>Sets per-thread context function to be used for formatting report and log messages.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/logger.py</code> <pre><code>@classmethod\ndef set(cls, context_fn: Callable[[str], str]) -&gt; None:\n    \"\"\"Sets per-thread context function to be used for formatting report and log messages.\"\"\"\n    cls._THREAD_LOCAL.set(Context(context_fn))\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.Context.traced","title":"<code>traced(func)</code>  <code>classmethod</code>","text":"<p>Decorator to log function entry, arguments, and return value at DEBUG level.</p> <p>Also adds an Allure step for reporting. Use on methods where tracing is useful for debugging or reporting.</p> Example <p>@Context.traced def my_method(self, x):     ...</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R]</code> <p>The function to be decorated.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to be passed to the function.</p> required <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to be passed to the function.</p> required <p>Returns:</p> Type Description <code>Callable[_P, _R]</code> <p>Callable[P, R]: The result of the function call.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/logger.py</code> <pre><code>@classmethod\ndef traced(cls, func: Callable[_P, _R]) -&gt; Callable[_P, _R]:\n    \"\"\"\n    Decorator to log function entry, arguments, and return value at DEBUG level.\n\n    Also adds an Allure step for reporting. Use on methods where tracing is useful\n    for debugging or reporting.\n\n    Example:\n        @Context.traced\n        def my_method(self, x):\n            ...\n\n    Args:\n        func (Callable[P, R]): The function to be decorated.\n        *args (Any): Positional arguments to be passed to the function.\n        **kwargs (Any): Keyword arguments to be passed to the function.\n\n    Returns:\n        Callable[P, R]: The result of the function call.\n    \"\"\"\n    @wraps(func)\n    def wrapper(*args: _P.args, **kwargs: _P.kwargs) -&gt; _R:\n        # NOTE: each time a decorated function is called this logic will be\n        # re-evaluated.\n        signature = inspect.signature(func)\n        parameters = list(signature.parameters.keys())\n\n        if parameters and parameters[0] == 'self' and len(args) &gt; 0:\n            instance = args[0]\n            logger = logging.getLogger(f\"{instance.__class__.__name__}\")\n            logger.debug(f\"&gt;&gt;&gt; \"\n                         + cls._format(\n                             f\"{func.__name__} \"\n                             f\"{\", \".join([str(arg) for arg in args[1:]])} \"\n                             f\"{LF.join(\n                                 f\"{key}={str(value)}\"\n                                 for key, value in kwargs.items()) if kwargs else EMPTY_STRING}\"))\n\n            with allure.step(  # type: ignore\n                cls._format(\n                    f\"{func.__name__} \"\n                    f\"{', '.join([str(arg) for arg in args[1:]])}\")):\n                result = func(*args, **kwargs)\n\n            if result == instance:\n                logger.debug(f\"&lt;&lt;&lt; \" + cls._format(f\"{func.__name__}\"))\n            else:\n                logger.debug(\n                    f\"&lt;&lt;&lt; \" + cls._format(f\"{func.__name__} {result}\"))\n\n            return result\n        else:\n            logger = logging.getLogger(func.__name__)\n            logger.debug(f\"&gt;&gt;&gt; {func.__name__} {args} {kwargs}\")\n            result = func(*args, **kwargs)\n            logger.debug(f\"&lt;&lt;&lt; {func.__name__} {result}\")\n            return result\n\n    return wrapper\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.FromTupleMixin","title":"<code>FromTupleMixin</code>","text":"<p>Mixin that adds a <code>from_tuple</code> class method for instantiating objects from a tuple.</p> <p>Allows creating an instance of a class (dataclass or regular class) by passing a tuple whose values match the order of the class fields. Works with frozen dataclasses as well.</p> Example <p>@dataclass(frozen=True) class Point(FromTupleMixin):     x: int     y: int p = Point.from_tuple((1, 2))</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/tuple_utils.py</code> <pre><code>class FromTupleMixin:\n    \"\"\"\n    Mixin that adds a `from_tuple` class method for instantiating objects from a tuple.\n\n    Allows creating an instance of a class (dataclass or regular class) by passing a tuple\n    whose values match the order of the class fields. Works with frozen dataclasses as well.\n\n    Example:\n        @dataclass(frozen=True)\n        class Point(FromTupleMixin):\n            x: int\n            y: int\n        p = Point.from_tuple((1, 2))\n    \"\"\"\n    @classmethod\n    def from_tuple(cls: Type[Self], data: Tuple[Any, ...]) -&gt; Self:\n        \"\"\"\n        Instantiates the class from a tuple of values, matching the order of class fields.\n\n        Args:\n            data (Tuple[Any, ...]): Tuple of values corresponding to the class fields.\n        Returns:\n            Self: An instance of the class with fields set from the tuple.\n        \"\"\"\n        if is_dataclass(cls):\n            # Retrieve all fields, including inherited ones\n            cls_fields = [f.name for f in fields(cls)]\n\n            # Create a dictionary of field names to values from the tuple\n            field_values = {name: value for name,\n                            value in zip(cls_fields, data)}\n\n            # Create a new instance using `__new__`\n            instance = cls.__new__(cls)\n\n            # If the dataclass is frozen, use `replace` to set the attributes\n            if getattr(cls, '__dataclass_params__').frozen:\n                return replace(instance, **field_values)\n            else:\n                # If the dataclass is not frozen, use setattr to set attributes\n                for key, value in field_values.items():\n                    setattr(instance, key, value)\n\n                # Call __init__ if defined\n                instance.__init__(*data)\n                return instance\n        else:\n            # For vanilla classes, assume fields are defined in __init__\n            # Using `__init__` directly as the custom initializer\n            instance = cls.__new__(cls)\n            for attr, value in zip(cls.__annotations__.keys(), data):\n                setattr(instance, attr, value)\n\n            # Call __init__ if it expects parameters\n            instance.__init__(*data)\n            return instance\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.FromTupleMixin.from_tuple","title":"<code>from_tuple(data)</code>  <code>classmethod</code>","text":"<p>Instantiates the class from a tuple of values, matching the order of class fields.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Tuple[Any, ...]</code> <p>Tuple of values corresponding to the class fields.</p> required <p>Returns:     Self: An instance of the class with fields set from the tuple.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/tuple_utils.py</code> <pre><code>@classmethod\ndef from_tuple(cls: Type[Self], data: Tuple[Any, ...]) -&gt; Self:\n    \"\"\"\n    Instantiates the class from a tuple of values, matching the order of class fields.\n\n    Args:\n        data (Tuple[Any, ...]): Tuple of values corresponding to the class fields.\n    Returns:\n        Self: An instance of the class with fields set from the tuple.\n    \"\"\"\n    if is_dataclass(cls):\n        # Retrieve all fields, including inherited ones\n        cls_fields = [f.name for f in fields(cls)]\n\n        # Create a dictionary of field names to values from the tuple\n        field_values = {name: value for name,\n                        value in zip(cls_fields, data)}\n\n        # Create a new instance using `__new__`\n        instance = cls.__new__(cls)\n\n        # If the dataclass is frozen, use `replace` to set the attributes\n        if getattr(cls, '__dataclass_params__').frozen:\n            return replace(instance, **field_values)\n        else:\n            # If the dataclass is not frozen, use setattr to set attributes\n            for key, value in field_values.items():\n                setattr(instance, key, value)\n\n            # Call __init__ if defined\n            instance.__init__(*data)\n            return instance\n    else:\n        # For vanilla classes, assume fields are defined in __init__\n        # Using `__init__` directly as the custom initializer\n        instance = cls.__new__(cls)\n        for attr, value in zip(cls.__annotations__.keys(), data):\n            setattr(instance, attr, value)\n\n        # Call __init__ if it expects parameters\n        instance.__init__(*data)\n        return instance\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ImmutableMixin","title":"<code>ImmutableMixin</code>","text":"<p>Mixin to enforce immutability after initialization.</p> <p>Overrides setattr to raise AttributeError if an attribute is modified after being set. Intended for use with non-dataclasses. For dataclasses, use <code>@dataclass(frozen=True)</code>.</p> Limitations <ul> <li>Does not work with WithMixin if attributes have default values.</li> <li>Does not work if applied to a superclass with a custom init.</li> </ul> Example <p>class MyImmutable(ImmutableMixin):     foo: int = 1 obj = MyImmutable() obj.foo = 2  # Raises AttributeError</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>class ImmutableMixin:\n    \"\"\"\n    Mixin to enforce immutability after initialization.\n\n    Overrides __setattr__ to raise AttributeError if an attribute is modified after being set.\n    Intended for use with non-dataclasses. For dataclasses, use `@dataclass(frozen=True)`.\n\n    Limitations:\n        - Does not work with WithMixin if attributes have default values.\n        - Does not work if applied to a superclass with a custom __init__.\n\n    Example:\n        class MyImmutable(ImmutableMixin):\n            foo: int = 1\n        obj = MyImmutable()\n        obj.foo = 2  # Raises AttributeError\n    \"\"\"\n\n    def __setattr__(self, key: str, value: Any) -&gt; None:\n        if hasattr(self, key):\n            raise AttributeError(f\"Can't modify attribute '{\n                                 key}' after initialization\")\n        super().__setattr__(key, value)  # Properly sets the attribute\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ImmutableMixin.__setattr__","title":"<code>__setattr__(key, value)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>def __setattr__(self, key: str, value: Any) -&gt; None:\n    if hasattr(self, key):\n        raise AttributeError(f\"Can't modify attribute '{\n                             key}' after initialization\")\n    super().__setattr__(key, value)  # Properly sets the attribute\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.InvalidValueException","title":"<code>InvalidValueException</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when an object fails validation via the Valid protocol.</p> Example <p>if not obj.is_valid():     raise InvalidValueException(obj)</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>class InvalidValueException(ValueError):\n    \"\"\"\n    Raised when an object fails validation via the Valid protocol.\n\n    Example:\n        if not obj.is_valid():\n            raise InvalidValueException(obj)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsIteratorYielding","title":"<code>IsIteratorYielding</code>","text":"<p>               Bases: <code>BaseMatcher[Iterator[T]]</code></p> <p>Matcher for data yielded by iterators.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>@final\nclass IsIteratorYielding[T](BaseMatcher[Iterator[T]]):\n    \"\"\"\n    Matcher for data yielded by iterators.\n    \"\"\"\n\n    def __init__(self, element_matcher: Matcher[T]) -&gt; None:\n        self.element_matcher = element_matcher\n\n    @override\n    def _matches(self, item: Iterable[T]) -&gt; bool:\n        for element in item:\n            if self.element_matcher.matches(element):\n                return True\n\n        # No matching element found\n        return False\n\n    @override\n    def describe_to(self, description: Description) -&gt; None:\n        description.append_text(\"a stream containing \") \\\n            .append_description_of(self.element_matcher)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsIteratorYielding.element_matcher","title":"<code>element_matcher = element_matcher</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.IsIteratorYielding.__init__","title":"<code>__init__(element_matcher)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def __init__(self, element_matcher: Matcher[T]) -&gt; None:\n    self.element_matcher = element_matcher\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsIteratorYielding.describe_to","title":"<code>describe_to(description)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>@override\ndef describe_to(self, description: Description) -&gt; None:\n    description.append_text(\"a stream containing \") \\\n        .append_description_of(self.element_matcher)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsIteratorYieldingAll","title":"<code>IsIteratorYieldingAll</code>","text":"<p>               Bases: <code>BaseMatcher[Iterator[T]]</code></p> <p>Matcher to ensure that the iterator yields at least one instance of each specified matcher.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>@final\nclass IsIteratorYieldingAll[T](BaseMatcher[Iterator[T]]):\n    \"\"\"\n    Matcher to ensure that the iterator yields at least one instance of each specified matcher.\n    \"\"\"\n\n    def __init__(self, element_matchers: List[Matcher[T]]) -&gt; None:\n        self.element_matchers = element_matchers\n\n    @override\n    def _matches(self, item: Iterable[T]) -&gt; bool:\n        unmatched_matchers = set(self.element_matchers)\n        for element in item:\n            unmatched_matchers = {\n                m for m in unmatched_matchers if not m.matches(element)}\n            if not unmatched_matchers:  # All matchers have been satisfied\n                return True\n\n        return False\n\n    @override\n    def describe_to(self, description: Description) -&gt; None:\n        description.append_text(\"a stream containing each of: \")\n        for index, matcher in enumerate(self.element_matchers):\n            if index &gt; 0:\n                description.append_text(\", \")\n            description.append_description_of(matcher)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsIteratorYieldingAll.element_matchers","title":"<code>element_matchers = element_matchers</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.IsIteratorYieldingAll.__init__","title":"<code>__init__(element_matchers)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def __init__(self, element_matchers: List[Matcher[T]]) -&gt; None:\n    self.element_matchers = element_matchers\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsIteratorYieldingAll.describe_to","title":"<code>describe_to(description)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>@override\ndef describe_to(self, description: Description) -&gt; None:\n    description.append_text(\"a stream containing each of: \")\n    for index, matcher in enumerate(self.element_matchers):\n        if index &gt; 0:\n            description.append_text(\", \")\n        description.append_description_of(matcher)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsStreamContainingEvery","title":"<code>IsStreamContainingEvery</code>","text":"<p>               Bases: <code>BaseMatcher[Iterator[T]]</code></p> <p>Matcher to ensure every element yielded by an iterator matches a given matcher.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>@final\nclass IsStreamContainingEvery[T](BaseMatcher[Iterator[T]]):\n    \"\"\"\n    Matcher to ensure every element yielded by an iterator matches a given matcher.\n    \"\"\"\n\n    def __init__(self, element_matcher: Matcher[T]) -&gt; None:\n        self.element_matcher = element_matcher\n\n    @override\n    def _matches(self, item: Iterable[T]) -&gt; bool:\n        for element in item:\n            if not self.element_matcher.matches(element):\n                return False  # One non-matching element means failure\n\n        # All elements matched\n        return True\n\n    @override\n    def describe_to(self, description: Description) -&gt; None:\n        description.append_text(\"a stream where every item is \") \\\n            .append_description_of(self.element_matcher)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsStreamContainingEvery.element_matcher","title":"<code>element_matcher = element_matcher</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.IsStreamContainingEvery.__init__","title":"<code>__init__(element_matcher)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def __init__(self, element_matcher: Matcher[T]) -&gt; None:\n    self.element_matcher = element_matcher\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsStreamContainingEvery.describe_to","title":"<code>describe_to(description)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>@override\ndef describe_to(self, description: Description) -&gt; None:\n    description.append_text(\"a stream where every item is \") \\\n        .append_description_of(self.element_matcher)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsWithinDates","title":"<code>IsWithinDates</code>","text":"<p>               Bases: <code>BaseMatcher[DateOrDateTime]</code></p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>@final\nclass IsWithinDates(BaseMatcher[DateOrDateTime]):\n    def __init__(\n            self, start_date: Optional[DateOrDateTime],\n            end_date: Optional[DateOrDateTime]) -&gt; None:\n        self.start_date = start_date\n        self.end_date = end_date\n\n    def _matches(self, item: Optional[DateOrDateTime]) -&gt; bool:\n        if item is None:\n            return False\n\n        # Normalize item to datetime\n        if not isinstance(item, datetime):\n            item = datetime.combine(item, datetime.min.time())\n\n        # Normalize start_date and end_date to datetime\n        def to_datetime(value: Optional[DateOrDateTime]) -&gt; Optional[datetime]:\n            if value is None:\n                return None\n            return value if isinstance(\n                value, datetime) else datetime.combine(\n                value, datetime.min.time())\n\n        start = to_datetime(self.start_date)\n        end = to_datetime(self.end_date)\n\n        if start and end:\n            return start &lt;= item &lt;= end\n        if start:\n            return item &gt;= start\n        if end:\n            return item &lt;= end\n\n        return False\n\n    def describe_to(self, description: Description) -&gt; None:\n        if self.start_date is None:\n            description.append_text(f\"a date before {self.end_date}\")\n        elif self.end_date is None:\n            description.append_text(f\"a date after {self.start_date}\")\n        else:\n            description.append_text(\n                f\"a date within {self.start_date} and {self.end_date}\")\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsWithinDates.end_date","title":"<code>end_date = end_date</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.IsWithinDates.start_date","title":"<code>start_date = start_date</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.IsWithinDates.__init__","title":"<code>__init__(start_date, end_date)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def __init__(\n        self, start_date: Optional[DateOrDateTime],\n        end_date: Optional[DateOrDateTime]) -&gt; None:\n    self.start_date = start_date\n    self.end_date = end_date\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IsWithinDates.describe_to","title":"<code>describe_to(description)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def describe_to(self, description: Description) -&gt; None:\n    if self.start_date is None:\n        description.append_text(f\"a date before {self.end_date}\")\n    elif self.end_date is None:\n        description.append_text(f\"a date after {self.start_date}\")\n    else:\n        description.append_text(\n            f\"a date within {self.start_date} and {self.end_date}\")\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IterableReader","title":"<code>IterableReader</code>","text":"<p>               Bases: <code>RawIOBase</code>, <code>LoggerMixin</code>, <code>ImmutableMixin</code></p> <p>I/O read-only stream over iterable of bytes, enabling streaming mode.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>@final\nclass IterableReader(RawIOBase, LoggerMixin, ImmutableMixin):\n    \"\"\"\n    I/O read-only stream over iterable of bytes, enabling streaming mode.\n    \"\"\"\n\n    def __init__(self, chunks: Iterable[bytes]):\n        self._chunks = iter(chunks)\n        self._accumulated_buffer = bytearray()\n\n    @override\n    def readable(self) -&gt; bool:\n        return True\n\n    @override\n    def readinto(self, output_buffer: memoryview) -&gt; int:  # type: ignore\n        # consume chunks, accumulating their bytes up to size of output buffer\n        while len(self._accumulated_buffer) &lt; len(output_buffer) \\\n                and (chunk := next(self._chunks, None)) is not None:\n            self.log.debug(f\"buffered chunk with length={len(chunk)}\")\n            self._accumulated_buffer.extend(chunk)\n\n        # consume accumulated bytes up to size of output buffer\n        consumed_bytes = min(len(self._accumulated_buffer), len(output_buffer))\n        output_buffer[:consumed_bytes] = self._accumulated_buffer[:consumed_bytes]\n\n        # delete consumed bytes, shifting left the accumulated buffer\n        del self._accumulated_buffer[:consumed_bytes]\n\n        self.log.debug(f\"consumed {consumed_bytes} bytes\")\n        return consumed_bytes\n\n    @staticmethod\n    def from_(\n            chunks: Iterable[bytes],\n            buffer_size: int = DEFAULT_BUFFER_SIZE) -&gt; BinaryIO:\n        \"\"\"\n        Converts a stream of binary chunks into a BufferedReader.\n\n        You should ensure closing.\n\n        Args:\n            chunks (Iterable[bytes]): stream of binary chunks\n\n        Returns:\n            io.BufferedReader: buffered reader around stream of binary chunks.\n        \"\"\"\n        return BufferedReader(IterableReader(chunks), buffer_size)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IterableReader.__init__","title":"<code>__init__(chunks)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>def __init__(self, chunks: Iterable[bytes]):\n    self._chunks = iter(chunks)\n    self._accumulated_buffer = bytearray()\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IterableReader.from_","title":"<code>from_(chunks, buffer_size=DEFAULT_BUFFER_SIZE)</code>  <code>staticmethod</code>","text":"<p>Converts a stream of binary chunks into a BufferedReader.</p> <p>You should ensure closing.</p> <p>Parameters:</p> Name Type Description Default <code>chunks</code> <code>Iterable[bytes]</code> <p>stream of binary chunks</p> required <p>Returns:</p> Type Description <code>BinaryIO</code> <p>io.BufferedReader: buffered reader around stream of binary chunks.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>@staticmethod\ndef from_(\n        chunks: Iterable[bytes],\n        buffer_size: int = DEFAULT_BUFFER_SIZE) -&gt; BinaryIO:\n    \"\"\"\n    Converts a stream of binary chunks into a BufferedReader.\n\n    You should ensure closing.\n\n    Args:\n        chunks (Iterable[bytes]): stream of binary chunks\n\n    Returns:\n        io.BufferedReader: buffered reader around stream of binary chunks.\n    \"\"\"\n    return BufferedReader(IterableReader(chunks), buffer_size)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IterableReader.readable","title":"<code>readable()</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>@override\ndef readable(self) -&gt; bool:\n    return True\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.IterableReader.readinto","title":"<code>readinto(output_buffer)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>@override\ndef readinto(self, output_buffer: memoryview) -&gt; int:  # type: ignore\n    # consume chunks, accumulating their bytes up to size of output buffer\n    while len(self._accumulated_buffer) &lt; len(output_buffer) \\\n            and (chunk := next(self._chunks, None)) is not None:\n        self.log.debug(f\"buffered chunk with length={len(chunk)}\")\n        self._accumulated_buffer.extend(chunk)\n\n    # consume accumulated bytes up to size of output buffer\n    consumed_bytes = min(len(self._accumulated_buffer), len(output_buffer))\n    output_buffer[:consumed_bytes] = self._accumulated_buffer[:consumed_bytes]\n\n    # delete consumed bytes, shifting left the accumulated buffer\n    del self._accumulated_buffer[:consumed_bytes]\n\n    self.log.debug(f\"consumed {consumed_bytes} bytes\")\n    return consumed_bytes\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.LoggerMixin","title":"<code>LoggerMixin</code>","text":"<p>Mixin that provides a <code>log</code> property for convenient class-based logging.</p> <p>Inherit from this mixin to get a <code>self.log</code> logger named after the class. Useful for adding debug/info/error logging to any class without boilerplate.</p> Example <p>class MyClass(LoggerMixin):     def do_something(self):         self.log.info(\"Doing something\")</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/logger.py</code> <pre><code>class LoggerMixin:\n    \"\"\"\n    Mixin that provides a `log` property for convenient class-based logging.\n\n    Inherit from this mixin to get a `self.log` logger named after the class.\n    Useful for adding debug/info/error logging to any class without boilerplate.\n\n    Example:\n        class MyClass(LoggerMixin):\n            def do_something(self):\n                self.log.info(\"Doing something\")\n    \"\"\"\n    @final\n    @cached_property\n    def log(self) -&gt; logging.Logger:\n        \"\"\"\n        Returns a logger named after the class.\n\n        Returns:\n            logging.Logger: The logger instance for this class.\n        \"\"\"\n        return logging.getLogger(self.__class__.__name__)\n\n    @final\n    def trace[T](self, value: T) -&gt; T:\n        \"\"\"\n        Logs value at DEBUG level using this logger.\n\n        Use to log something as a value, usually in a lambda expression::\n\n            then.eventually_assert_that(\n                lambda: self.trace(...call some API...),\n                greater_that(0)) \\\n                .and_....other verifications may follow...\n\n        Args:\n            value (T): The value to log.\n\n        Returns:\n            T: The value (unchanged).\n        \"\"\"\n        self.log.debug(f\"=== {value}\")\n        return value\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.LoggerMixin.log","title":"<code>log</code>  <code>cached</code> <code>property</code>","text":"<p>Returns a logger named after the class.</p> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: The logger instance for this class.</p>"},{"location":"api/qa-testing-utils/#qa_testing_utils.LoggerMixin.trace","title":"<code>trace(value)</code>","text":"<p>Logs value at DEBUG level using this logger.</p> <p>Use to log something as a value, usually in a lambda expression::</p> <pre><code>then.eventually_assert_that(\n    lambda: self.trace(...call some API...),\n    greater_that(0))                 .and_....other verifications may follow...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to log.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The value (unchanged).</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/logger.py</code> <pre><code>@final\ndef trace[T](self, value: T) -&gt; T:\n    \"\"\"\n    Logs value at DEBUG level using this logger.\n\n    Use to log something as a value, usually in a lambda expression::\n\n        then.eventually_assert_that(\n            lambda: self.trace(...call some API...),\n            greater_that(0)) \\\n            .and_....other verifications may follow...\n\n    Args:\n        value (T): The value to log.\n\n    Returns:\n        T: The value (unchanged).\n    \"\"\"\n    self.log.debug(f\"=== {value}\")\n    return value\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.SingletonBase","title":"<code>SingletonBase</code>","text":"<p>Base class for singletons using SingletonMeta.</p> <p>Inherit from this class to make your class a singleton.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>class SingletonBase(metaclass=SingletonMeta):\n    \"\"\"\n    Base class for singletons using SingletonMeta.\n\n    Inherit from this class to make your class a singleton.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.SingletonMeta","title":"<code>SingletonMeta</code>","text":"<p>               Bases: <code>type</code></p> <p>Thread-safe singleton metaclass.</p> <p>Ensures only one instance of a class exists per process. Use by setting <code>metaclass=SingletonMeta</code> on your class.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>@final\nclass SingletonMeta(type):\n    \"\"\"\n    Thread-safe singleton metaclass.\n\n    Ensures only one instance of a class exists per process.\n    Use by setting `metaclass=SingletonMeta` on your class.\n    \"\"\"\n    _instances: ClassVar[Dict[type, object]] = {}\n    _lock: ClassVar[threading.Lock] = threading.Lock()  # Ensure thread-safety\n\n    def __call__(\n            cls: type,\n            *args: Any, **kwargs: Any) -&gt; \"SingletonBase\":\n        with SingletonMeta._lock:\n            if cls not in SingletonMeta._instances:\n                instance = super().__call__(*args, **kwargs)  # type: ignore\n                SingletonMeta._instances[cls] = instance\n        return SingletonMeta._instances[cls]  # type: ignore[return-value]\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.SingletonMeta.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>def __call__(\n        cls: type,\n        *args: Any, **kwargs: Any) -&gt; \"SingletonBase\":\n    with SingletonMeta._lock:\n        if cls not in SingletonMeta._instances:\n            instance = super().__call__(*args, **kwargs)  # type: ignore\n            SingletonMeta._instances[cls] = instance\n    return SingletonMeta._instances[cls]  # type: ignore[return-value]\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.TestException","title":"<code>TestException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Marks an exception raised by tests infrastructure. Useful to differentiate between unexpected run-time exceptions, which should be handled as programming errors, and legitimate run-time exceptions such as time-out, not found, etc. The former might be handled via a retry mechanism.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/exceptions.py</code> <pre><code>class TestException(Exception):\n    \"\"\"\n    Marks an exception raised by tests infrastructure. Useful to differentiate\n    between unexpected run-time exceptions, which should be handled as\n    programming errors, and legitimate run-time exceptions such as time-out,\n    not found, etc. The former might be handled via a retry mechanism.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ThreadLocal","title":"<code>ThreadLocal</code>","text":"<p>Thread-local storage for a value, with a default initializer.</p> <p>Provides per-thread storage for a value of type T, initialized with a default.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/thread_utils.py</code> <pre><code>class ThreadLocal[T]:\n    \"\"\"\n    Thread-local storage for a value, with a default initializer.\n\n    Provides per-thread storage for a value of type T, initialized with a default.\n    \"\"\"\n\n    def __init__(self, default: Optional[T] = None):\n        \"\"\"\n        Initializes the thread-local storage with a default value.\n\n        Args:\n            default (Optional[T]): The default value for each thread, None if not specified.\n        \"\"\"\n        self._local = local()\n        self._local.value = default\n\n    def set(self, value: T) -&gt; None:\n        \"\"\"\n        Sets the thread-local value for the current thread.\n\n        Args:\n            value (T): The value to set for the current thread.\n        \"\"\"\n        self._local.value = value\n\n    def get(self) -&gt; T:\n        \"\"\"\n        Gets the thread-local value for the current thread.\n\n        Returns:\n            T: The value for the current thread.\n        \"\"\"\n        return cast(T, self._local.value)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ThreadLocal.__init__","title":"<code>__init__(default=None)</code>","text":"<p>Initializes the thread-local storage with a default value.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Optional[T]</code> <p>The default value for each thread, None if not specified.</p> <code>None</code> Source code in <code>qa-testing-utils/src/qa_testing_utils/thread_utils.py</code> <pre><code>def __init__(self, default: Optional[T] = None):\n    \"\"\"\n    Initializes the thread-local storage with a default value.\n\n    Args:\n        default (Optional[T]): The default value for each thread, None if not specified.\n    \"\"\"\n    self._local = local()\n    self._local.value = default\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ThreadLocal.get","title":"<code>get()</code>","text":"<p>Gets the thread-local value for the current thread.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The value for the current thread.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/thread_utils.py</code> <pre><code>def get(self) -&gt; T:\n    \"\"\"\n    Gets the thread-local value for the current thread.\n\n    Returns:\n        T: The value for the current thread.\n    \"\"\"\n    return cast(T, self._local.value)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ThreadLocal.set","title":"<code>set(value)</code>","text":"<p>Sets the thread-local value for the current thread.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to set for the current thread.</p> required Source code in <code>qa-testing-utils/src/qa_testing_utils/thread_utils.py</code> <pre><code>def set(self, value: T) -&gt; None:\n    \"\"\"\n    Sets the thread-local value for the current thread.\n\n    Args:\n        value (T): The value to set for the current thread.\n    \"\"\"\n    self._local.value = value\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ToDictMixin","title":"<code>ToDictMixin</code>","text":"<p>Mixin to add serialization methods to dataclasses.</p> Provides <ul> <li>to_dict(): Recursively converts a dataclass (and nested dataclasses) to a dictionary.</li> <li>flatten(): Flattens nested structure for CSV or flat serialization.</li> </ul> Example <p>@dataclass class User(ToDictMixin):     name: str     age: int</p> <p>user = User(\"Alice\", 30) user.to_dict()  # {'name': 'Alice', 'age': 30}</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>class ToDictMixin:\n    \"\"\"\n    Mixin to add serialization methods to dataclasses.\n\n    Provides:\n        - to_dict(): Recursively converts a dataclass (and nested dataclasses) to a dictionary.\n        - flatten(): Flattens nested structure for CSV or flat serialization.\n\n    Example:\n        @dataclass\n        class User(ToDictMixin):\n            name: str\n            age: int\n\n        user = User(\"Alice\", 30)\n        user.to_dict()  # {'name': 'Alice', 'age': 30}\n    \"\"\"\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts a dataclass instance (with nested dataclasses) to a dictionary.\n        \"\"\"\n        from typing import cast\n\n        def convert(value: Any) -&gt; Any:\n            if isinstance(value, ToDictMixin):\n                return value.to_dict()\n            elif isinstance(value, list):\n                # Provide a type hint for v\n                return [convert(v) for v in cast(list[Any], value)]\n            elif isinstance(value, dict):\n                return {k: convert(v) for k, v in value.items()}  # type: ignore\n            return value\n\n        if not is_dataclass(self):\n            raise TypeError(\"not a dataclass instance\")\n\n        return {key: convert(value) for key, value in asdict(self).items()}\n\n    def flatten(self, prefix: str = \"\") -&gt; Dict[str, Any]:\n        \"\"\"\n        Flattens the nested structure into a flat dictionary for CSV serialization.\n        \"\"\"\n        flat_dict: Dict[str, Any] = {}\n\n        def flatten_value(key: str, value: Any) -&gt; None:\n            if isinstance(value, ToDictMixin):\n                # Flatten nested ToDictMixin dataclasses\n                nested_flat = value.flatten(prefix=f\"{key}_\")\n                flat_dict.update(nested_flat)\n            elif isinstance(value, list):\n                # Serialize lists as JSON strings or expand into multiple columns\n                for idx, item in enumerate(value):  # type: ignore\n                    flat_dict[f\"{key}[{idx}]\"] = item\n            elif isinstance(value, dict):\n                # Serialize dicts as JSON strings or expand into multiple columns\n                for sub_key, sub_val in value.items():  # type: ignore\n                    flat_dict[f\"{key}_{sub_key}\"] = sub_val\n            else:\n                # Directly add non-nested fields\n                flat_dict[key] = value\n\n        if not is_dataclass(self):\n            raise TypeError(\"not a dataclass instance\")\n\n        for field in fields(self):\n            value = getattr(self, field.name)\n            flatten_value(f\"{prefix}{field.name}\", value)\n\n        return flat_dict\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ToDictMixin.flatten","title":"<code>flatten(prefix='')</code>","text":"<p>Flattens the nested structure into a flat dictionary for CSV serialization.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>def flatten(self, prefix: str = \"\") -&gt; Dict[str, Any]:\n    \"\"\"\n    Flattens the nested structure into a flat dictionary for CSV serialization.\n    \"\"\"\n    flat_dict: Dict[str, Any] = {}\n\n    def flatten_value(key: str, value: Any) -&gt; None:\n        if isinstance(value, ToDictMixin):\n            # Flatten nested ToDictMixin dataclasses\n            nested_flat = value.flatten(prefix=f\"{key}_\")\n            flat_dict.update(nested_flat)\n        elif isinstance(value, list):\n            # Serialize lists as JSON strings or expand into multiple columns\n            for idx, item in enumerate(value):  # type: ignore\n                flat_dict[f\"{key}[{idx}]\"] = item\n        elif isinstance(value, dict):\n            # Serialize dicts as JSON strings or expand into multiple columns\n            for sub_key, sub_val in value.items():  # type: ignore\n                flat_dict[f\"{key}_{sub_key}\"] = sub_val\n        else:\n            # Directly add non-nested fields\n            flat_dict[key] = value\n\n    if not is_dataclass(self):\n        raise TypeError(\"not a dataclass instance\")\n\n    for field in fields(self):\n        value = getattr(self, field.name)\n        flatten_value(f\"{prefix}{field.name}\", value)\n\n    return flat_dict\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.ToDictMixin.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts a dataclass instance (with nested dataclasses) to a dictionary.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts a dataclass instance (with nested dataclasses) to a dictionary.\n    \"\"\"\n    from typing import cast\n\n    def convert(value: Any) -&gt; Any:\n        if isinstance(value, ToDictMixin):\n            return value.to_dict()\n        elif isinstance(value, list):\n            # Provide a type hint for v\n            return [convert(v) for v in cast(list[Any], value)]\n        elif isinstance(value, dict):\n            return {k: convert(v) for k, v in value.items()}  # type: ignore\n        return value\n\n    if not is_dataclass(self):\n        raise TypeError(\"not a dataclass instance\")\n\n    return {key: convert(value) for key, value in asdict(self).items()}\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.TracingMatcher","title":"<code>TracingMatcher</code>","text":"<p>               Bases: <code>BaseMatcher[T]</code>, <code>LoggerMixin</code></p> <p>A matcher wrapper that adds debug logging around another matcher.</p> <p>Logs the result of each match attempt using the class logger.</p> <p>Parameters:</p> Name Type Description Default <code>matcher</code> <code>Matcher[T]</code> <p>The matcher to wrap and trace.</p> required Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>class TracingMatcher[T](BaseMatcher[T], LoggerMixin):\n    \"\"\"\n    A matcher wrapper that adds debug logging around another matcher.\n\n    Logs the result of each match attempt using the class logger.\n\n    Args:\n        matcher (Matcher[T]): The matcher to wrap and trace.\n    \"\"\"\n\n    def __init__(self, matcher: Matcher[T]) -&gt; None:\n        self._matcher = matcher\n\n    def _matches(self, item: Any) -&gt; bool:\n        result = self._matcher.matches(item)\n        self.log.debug(f\"{item!r} -&gt; {result}\")\n        return result\n\n    def describe_to(self, description: Description) -&gt; None:\n        self._matcher.describe_to(description)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.TracingMatcher.__init__","title":"<code>__init__(matcher)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def __init__(self, matcher: Matcher[T]) -&gt; None:\n    self._matcher = matcher\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.TracingMatcher.describe_to","title":"<code>describe_to(description)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def describe_to(self, description: Description) -&gt; None:\n    self._matcher.describe_to(description)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.Valid","title":"<code>Valid</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Specifies a method for validating objects.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>@runtime_checkable\nclass Valid(Protocol):\n    \"\"\"\n    Specifies a method for validating objects.\n    \"\"\"\n\n    def is_valid(self) -&gt; bool:\n        \"\"\"\n        Should be implemented by objects that need validation.\n\n        Returns:\n            bool: true, if the object is valid\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.Valid.is_valid","title":"<code>is_valid()</code>","text":"<p>Should be implemented by objects that need validation.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true, if the object is valid</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>def is_valid(self) -&gt; bool:\n    \"\"\"\n    Should be implemented by objects that need validation.\n\n    Returns:\n        bool: true, if the object is valid\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.WithMixin","title":"<code>WithMixin</code>","text":"<p>Mixin to support copy-on-change (functional update) for objects.</p> <p>Instead of mutating an object, use <code>with_()</code> to create a copy with updated fields:     obj2 = obj.with_(field=new_value)</p> <p>Works with both plain Python classes and dataclasses.</p> Example <p>@dataclass(frozen=True) class Point(WithMixin):     x: int     y: int</p> <p>p1 = Point(1, 2) p2 = p1.with_(x=3)  # p2 is Point(3, 2)</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>class WithMixin:\n    '''\n    Mixin to support copy-on-change (functional update) for objects.\n\n    Instead of mutating an object, use `with_()` to create a copy with updated fields:\n        obj2 = obj.with_(field=new_value)\n\n    Works with both plain Python classes and dataclasses.\n\n    Example:\n        @dataclass(frozen=True)\n        class Point(WithMixin):\n            x: int\n            y: int\n\n        p1 = Point(1, 2)\n        p2 = p1.with_(x=3)  # p2 is Point(3, 2)\n    '''\n    @final\n    def with_[T:WithMixin](self: T, **changes: Any) -&gt; T:\n        if is_dataclass(self):\n            # Directly use replace for dataclasses; it will raise an error for invalid fields\n            return replace(self, **changes)\n\n        duplicated_object = self.__class__(**self.__dict__)\n        for key, value in changes.items():\n            # Get the current attribute to determine its type\n            current_attr = getattr(self, key, None)\n            if isinstance(current_attr, Enum):\n                # If the current attribute is an enum,\n                # convert the value to the corresponding enum\n                value = current_attr.__class__(value)\n            setattr(duplicated_object, key, value)\n        return duplicated_object\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.WithMixin.with_","title":"<code>with_(**changes)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>@final\ndef with_[T:WithMixin](self: T, **changes: Any) -&gt; T:\n    if is_dataclass(self):\n        # Directly use replace for dataclasses; it will raise an error for invalid fields\n        return replace(self, **changes)\n\n    duplicated_object = self.__class__(**self.__dict__)\n    for key, value in changes.items():\n        # Get the current attribute to determine its type\n        current_attr = getattr(self, key, None)\n        if isinstance(current_attr, Enum):\n            # If the current attribute is an enum,\n            # convert the value to the corresponding enum\n            value = current_attr.__class__(value)\n        setattr(duplicated_object, key, value)\n    return duplicated_object\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.classproperty","title":"<code>classproperty</code>","text":"<p>Descriptor for defining class-level properties (like @property but for classes).</p> Example <p>class MyClass:     @classproperty     def foo(cls):         return ...</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>@final\nclass classproperty[T]:\n    \"\"\"\n    Descriptor for defining class-level properties (like @property but for classes).\n\n    Example:\n        class MyClass:\n            @classproperty\n            def foo(cls):\n                return ...\n    \"\"\"\n\n    def __init__(self, fget: Callable[[Any], T]) -&gt; None:\n        self.fget = fget\n\n    def __get__(self, instance: Any, owner: Any) -&gt; T:\n        return self.fget(owner)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.classproperty.fget","title":"<code>fget = fget</code>  <code>instance-attribute</code>","text":""},{"location":"api/qa-testing-utils/#qa_testing_utils.classproperty.__get__","title":"<code>__get__(instance, owner)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>def __get__(self, instance: Any, owner: Any) -&gt; T:\n    return self.fget(owner)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.classproperty.__init__","title":"<code>__init__(fget)</code>","text":"Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>def __init__(self, fget: Callable[[Any], T]) -&gt; None:\n    self.fget = fget\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.adapted_iterator","title":"<code>adapted_iterator(converter, matcher)</code>","text":"<p>Hamcrest matcher adapting an Iterator of type T by specified converter and applying specified matcher. For example::</p> <pre><code>adapt_iterator( lambda message: message.id,\n            yields_item(is_greater_than(0)) )\n</code></pre> <p>where id being a number, and is_greater_than being a matcher that can be applied on numbers.</p> <p>See more on <code>PyHamcrest &lt;https://github.com/hamcrest/PyHamcrest&gt;</code></p> <p>Parameters:</p> Name Type Description Default <code>converter</code> <code>Callable[[T], R]</code> <p>function converting T into R</p> required <code>matcher</code> <code>Matcher[Iterator[R]</code> <p>matcher for adapted Iterator of R</p> required <p>Returns:</p> Type Description <code>Matcher[Iterator[T]]</code> <p>Matcher[Iterator[T]]: matcher for target Iterator of type T</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def adapted_iterator[T, R](\n        converter: Callable[[T], R],\n        matcher: Matcher[Iterator[R]]) -&gt; Matcher[Iterator[T]]:\n    \"\"\"\n    Hamcrest matcher adapting an Iterator of type T by specified converter and\n    applying specified matcher. For example::\n\n        adapt_iterator( lambda message: message.id,\n                    yields_item(is_greater_than(0)) )\n\n    where id being a number, and is_greater_than being a matcher that can be\n    applied on numbers.\n\n    See more on `PyHamcrest &lt;https://github.com/hamcrest/PyHamcrest&gt;`\n\n    Args:\n        converter (Callable[[T], R]): function converting T into R\n        matcher (Matcher[Iterator[R]): matcher for adapted Iterator of R\n\n    Returns:\n        Matcher[Iterator[T]]: matcher for target Iterator of type T\n    \"\"\"\n    @final\n    class AdaptedMatcher(BaseMatcher[Iterator[T]]):\n        @override\n        def _matches(self, item: Iterable[T]) -&gt; bool:\n            return matcher.matches(map(converter, item))\n\n        @override\n        def describe_to(self, description: Description) -&gt; None:\n            description.append_description_of(matcher)\n\n    return AdaptedMatcher()\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.adapted_object","title":"<code>adapted_object(converter, matcher)</code>","text":"<p>Hamcrest matcher adapting an object of type T by specified converter and applying specified matcher. For example::</p> <pre><code>adapt_object( lambda message: message.id,\n            is_greater_than(0) )\n</code></pre> <p>where id being a number, and is_greater_than being a matcher that can be applied on numbers.</p> <p>See more on <code>PyHamcrest &lt;https://github.com/hamcrest/PyHamcrest&gt;</code></p> <p>Parameters:</p> Name Type Description Default <code>converter</code> <code>Callable[[T], R]</code> <p>function converting T into R</p> required <code>matcher</code> <code>Matcher[R]</code> <p>matcher for adapted type R</p> required <p>Returns:</p> Type Description <code>Matcher[T]</code> <p>Matcher[T]: matcher for target type T</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def adapted_object[T, R](\n        converter: Callable[[T], R],\n        matcher: Matcher[R]) -&gt; Matcher[T]:\n    \"\"\"\n    Hamcrest matcher adapting an object of type T by specified converter and\n    applying specified matcher. For example::\n\n        adapt_object( lambda message: message.id,\n                    is_greater_than(0) )\n\n    where id being a number, and is_greater_than being a matcher that can be\n    applied on numbers.\n\n    See more on `PyHamcrest &lt;https://github.com/hamcrest/PyHamcrest&gt;`\n\n    Args:\n        converter (Callable[[T], R]): function converting T into R\n        matcher (Matcher[R]): matcher for adapted type R\n\n    Returns:\n        Matcher[T]: matcher for target type T\n    \"\"\"\n    @final\n    class AdaptedMatcher(BaseMatcher[T]):\n        @override\n        def _matches(self, item: T) -&gt; bool:\n            return False if item is None \\\n                else matcher.matches(converter(item))\n\n        @override\n        def describe_to(self, description: Description) -&gt; None:\n            description.append_description_of(matcher)\n\n    return AdaptedMatcher()\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.adapted_sequence","title":"<code>adapted_sequence(converter, matcher)</code>","text":"<p>Hamcrest matcher adapting a Sequence of type T by specified converter and applying specified matcher. For example::</p> <pre><code>adapt_sequence( lambda message: message.id,\n            has_item(is_greater_than(0)) )\n</code></pre> <p>where id being a number, and is_greater_than being a matcher that can be applied on numbers.</p> <p>See more on <code>PyHamcrest &lt;https://github.com/hamcrest/PyHamcrest&gt;</code></p> <p>Parameters:</p> Name Type Description Default <code>converter</code> <code>Callable[[T], R]</code> <p>function converting T into R</p> required <code>matcher</code> <code>Matcher[Sequence[R]</code> <p>matcher for adapted Sequence of R</p> required <p>Returns:</p> Type Description <code>Matcher[Sequence[T]]</code> <p>Matcher[Sequence[T]]: matcher for target Sequence of type T</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def adapted_sequence[T, R](\n        converter: Callable[[T], R],\n        matcher: Matcher[Sequence[R]]) -&gt; Matcher[Sequence[T]]:\n    \"\"\"\n    Hamcrest matcher adapting a Sequence of type T by specified converter and\n    applying specified matcher. For example::\n\n        adapt_sequence( lambda message: message.id,\n                    has_item(is_greater_than(0)) )\n\n    where id being a number, and is_greater_than being a matcher that can be\n    applied on numbers.\n\n    See more on `PyHamcrest &lt;https://github.com/hamcrest/PyHamcrest&gt;`\n\n    Args:\n        converter (Callable[[T], R]): function converting T into R\n        matcher (Matcher[Sequence[R]): matcher for adapted Sequence of R\n\n    Returns:\n        Matcher[Sequence[T]]: matcher for target Sequence of type T\n    \"\"\"\n    @final\n    class AdaptedMatcher(BaseMatcher[Sequence[T]]):\n        @override\n        def _matches(self, item: Sequence[T]) -&gt; bool:\n            return matcher.matches([converter(x) for x in item])\n\n        @override\n        def describe_to(self, description: Description) -&gt; None:\n            description.append_description_of(matcher)\n\n    return AdaptedMatcher()\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.contains_string_ignoring_case","title":"<code>contains_string_ignoring_case(substring)</code>","text":"<p>Creates a matcher that checks if a given string contains the specified substring, ignoring case.</p> <p>Parameters:</p> Name Type Description Default <code>substring</code> <code>str</code> <p>The substring to search for within the target string, case-insensitively.</p> required <p>Returns:</p> Name Type Description <code>ContainsStringIgnoringCase</code> <code>ContainsStringIgnoringCase</code> <p>A matcher object that evaluates whether the target string contains the specified substring, ignoring case.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def contains_string_ignoring_case(substring: str) -&gt; ContainsStringIgnoringCase:\n    \"\"\"\n    Creates a matcher that checks if a given string contains the specified substring, ignoring case.\n\n    Args:\n        substring (str): The substring to search for within the target string, case-insensitively.\n\n    Returns:\n        ContainsStringIgnoringCase: A matcher object that evaluates whether the target string contains the specified substring, ignoring case.\n    \"\"\"\n    return ContainsStringIgnoringCase(substring)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.crc32_of","title":"<code>crc32_of(file, chunk_size=DEFAULT_BUFFER_SIZE)</code>","text":"<p>Calculate the CRC of a binary stream from its current position to its tail, using chunked reading.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>BinaryIO</code> <p>The file object to read data from, starting from its current position.</p> required <code>chunk_size</code> <code>int</code> <p>The size of chunks to read at a time (default is 8192).</p> <code>DEFAULT_BUFFER_SIZE</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Calculated CRC value of the remaining file content.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>def crc32_of(file: BinaryIO, chunk_size: int = DEFAULT_BUFFER_SIZE) -&gt; int:\n    \"\"\"\n    Calculate the CRC of a binary stream from its current position to its tail,\n    using chunked reading.\n\n    Args:\n        file (BinaryIO): The file object to read data from, starting from its current position.\n        chunk_size (int): The size of chunks to read at a time (default is 8192).\n\n    Returns:\n        int: Calculated CRC value of the remaining file content.\n    \"\"\"\n    crc_value = 0\n\n    while chunk := file.read(chunk_size):\n        crc_value = crc32(chunk, crc_value)\n\n    return crc_value &amp; 0xFFFFFFFF  # ensure 32-bit unsigned\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.decompress_xz_stream","title":"<code>decompress_xz_stream(compressed_chunks)</code>","text":"<p>Decompresses XZ stream.</p> <p>Parameters:</p> Name Type Description Default <code>compressed_chunks</code> <code>Iterable[bytes]</code> <p>stream of binary compressed chunks</p> required <p>Yields:</p> Type Description <code>bytes</code> <p>Iterator[bytes]: the decompressed stream</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>def decompress_xz_stream(compressed_chunks: Iterable[bytes]) -&gt; Iterator[bytes]:\n    \"\"\"\n    Decompresses XZ stream.\n\n    Args:\n        compressed_chunks (Iterable[bytes]): stream of binary compressed chunks\n\n    Yields:\n        Iterator[bytes]: the decompressed stream\n    \"\"\"\n    decompressor = LZMADecompressor()\n    return map(decompressor.decompress, compressed_chunks)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.extract_files_from_tar","title":"<code>extract_files_from_tar(tar_chunks)</code>","text":"<p>Extracts files from decompressed TAR stream.</p> <p>Parameters:</p> Name Type Description Default <code>tar_chunks</code> <code>Iterable[bytes]</code> <p>stream of decompressed TAR chunks</p> required <p>Yields:</p> Type Description <code>Tuple[TarInfo, bytes]</code> <p>Iterator[Tuple[tarfile.TarInfo, bytes]]:             streams tuples of meta-data and data for each file</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>def extract_files_from_tar(tar_chunks: Iterable[bytes]) -&gt; Iterator[Tuple[TarInfo, bytes]]:\n    \"\"\"\n    Extracts files from decompressed TAR stream.\n\n    Args:\n        tar_chunks (Iterable[bytes]): stream of decompressed TAR chunks\n\n    Yields:\n        Iterator[Tuple[tarfile.TarInfo, bytes]]: \\\n            streams tuples of meta-data and data for each file\n    \"\"\"\n    with open(fileobj=IterableReader.from_(tar_chunks),\n              mode='r|*') as tar:\n        for member in tar:\n            if member.isfile():\n                extracted_file = tar.extractfile(member)\n                if extracted_file:\n                    yield member, extracted_file.read()\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.get_config_overrides","title":"<code>get_config_overrides()</code>","text":"<p>Returns parsed <code>--config</code> overrides passed to pytest. Safe to call from anywhere (e.g., BaseConfiguration).</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/pytest_plugin.py</code> <pre><code>def get_config_overrides() -&gt; dict[str, dict[str, str]]:\n    \"\"\"\n    Returns parsed `--config` overrides passed to pytest.\n    Safe to call from anywhere (e.g., BaseConfiguration).\n    \"\"\"\n    return _config_overrides\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.match_as","title":"<code>match_as(matcher)</code>","text":"<p>Utility function to cast a generic matcher to the specific type Matcher[T].</p> <p>Parameters:</p> Name Type Description Default <code>matcher</code> <code>Matcher[object]</code> <p>The original matcher that needs to be cast.</p> required <p>Returns:</p> Type Description <code>Matcher[T]</code> <p>A matcher cast to Matcher[T].</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def match_as[T](matcher: Matcher[object]) -&gt; Matcher[T]:  # type: ignore\n    \"\"\"\n    Utility function to cast a generic matcher to the specific type Matcher[T].\n\n    Args:\n        matcher: The original matcher that needs to be cast.\n\n    Returns:\n        A matcher cast to Matcher[T].\n    \"\"\"\n    return cast(Matcher[T], matcher)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.process_next","title":"<code>process_next(i, p)</code>","text":"<p>Processes next items per specified predicate. Useful for cases in which the first item in a stream decides the meaning of the rest of the items.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>Iterator[T]</code> <p>the iterator to process</p> required <code>p</code> <code>Predicate[T]</code> <p>the predicate to be applied on <code>next(i)</code></p> required <p>Returns:</p> Type Description <code>Iterator[T]</code> <p>Iterator[T]: the original iterator if the predicate evaluated true,             otherwise empty iterator</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/stream_utils.py</code> <pre><code>def process_next[T](i: Iterator[T], p: Predicate[T]) -&gt; Iterator[T]:\n    \"\"\"\n    Processes next items per specified predicate. Useful for cases in which\n    the first item in a stream decides the meaning of the rest of the items.\n\n    Args:\n        i (Iterator[T]): the iterator to process\n        p (Predicate[T]): the predicate to be applied on `next(i)`\n\n    Returns:\n        Iterator[T]: the original iterator if the predicate evaluated true, \\\n            otherwise empty iterator\n    \"\"\"\n    return i if p(next(i)) else iter([])\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.pytest_addoption","title":"<code>pytest_addoption(parser)</code>","text":"<p>Adds the <code>--config</code> command-line option for runtime config overrides.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/pytest_plugin.py</code> <pre><code>def pytest_addoption(parser: pytest.Parser) -&gt; None:\n    \"\"\"Adds the `--config` command-line option for runtime config overrides.\"\"\"\n    parser.addoption(\n        \"--config\",\n        action=\"append\",\n        default=[],\n        help=\"Override config values using section:key=value format, comma-separated\"\n    )\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.pytest_configure","title":"<code>pytest_configure(config)</code>","text":"<p>Configures the pytest session, loading logging.ini and parsing config overrides.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/pytest_plugin.py</code> <pre><code>@pytest.hookimpl(tryfirst=True)\ndef pytest_configure(config: pytest.Config) -&gt; None:\n    \"\"\"Configures the pytest session, loading logging.ini and parsing config overrides.\"\"\"\n    from qa_testing_utils import __file__ as utils_ini\n\n    test_args = [Path(arg.split(\"::\")[0])\n                 for arg in config.args if Path(arg.split(\"::\")[0]).is_file()]\n    root = test_args[0].parent.parent if test_args else Path.cwd()\n\n    # Collect all logging.ini files under tests/ and src/\n    logging_inis = (\n        list(root.glob(\"tests/**/logging.ini\"))\n        + list(root.glob(\"src/**/logging.ini\")))\n\n    if logging_inis:\n        # Prefer the one under tests/ if it exists\n        selected_ini = logging_inis[0]\n        logging.config.fileConfig(selected_ini)\n        print(f\"loaded logging.ini from {selected_ini}\")\n    else:\n        fallback_ini = Path(utils_ini).parent / \"logging.ini\"\n        logging.config.fileConfig(fallback_ini)\n        print(f\"loaded fallback logging.ini from {fallback_ini}\")\n\n    config_arg = config.getoption(\"--config\")\n    if config_arg:\n        _parse_config_overrides(config_arg)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.pytest_runtest_makereport","title":"<code>pytest_runtest_makereport(item, call)</code>","text":"<p>Generates a test report with the source code of the test function.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/pytest_plugin.py</code> <pre><code>@pytest.hookimpl(tryfirst=True)\ndef pytest_runtest_makereport(\n    item: pytest.Item, call: pytest.CallInfo[None]\n) -&gt; pytest.TestReport:\n    \"\"\"Generates a test report with the source code of the test function.\"\"\"\n    report = pytest.TestReport.from_item_and_call(item, call)\n\n    if call.when == \"call\":\n        report.sections.append(('body', _get_test_body(item)))\n\n    return report\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.read_lines","title":"<code>read_lines(byte_stream, encoding=UTF_8, eol=LF)</code>","text":"<p>Converts a stream of binary chunks into stream of text lines. Handles cases where lines are split across chunks.</p> <p>Parameters:</p> Name Type Description Default <code>byte_stream</code> <code>Iterable[bytes]</code> <p>the binary (chunks) stream</p> required <code>encoding</code> <code>str</code> <p>expected text encoding. Defaults to 'utf-8'.</p> <code>UTF_8</code> <code>eol</code> <code>str</code> <p>expected line-ending. Default to LF.</p> <code>LF</code> <p>Yields:</p> Type Description <code>str</code> <p>Iterator[str]: stream of text lines, not terminated by EOL marker</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>def read_lines(\n        byte_stream: Iterable[bytes],\n        encoding: str = UTF_8,\n        eol: str = LF) -&gt; Iterator[str]:\n    \"\"\"\n    Converts a stream of binary chunks into stream of text lines.\n    Handles cases where lines are split across chunks.\n\n    Args:\n        byte_stream (Iterable[bytes]): the binary (chunks) stream\n        encoding (str, optional): expected text encoding. Defaults to 'utf-8'.\n        eol (str, optional): expected line-ending. Default to LF.\n\n    Yields:\n        Iterator[str]: stream of text lines, not terminated by EOL marker\n    \"\"\"\n    has_content = False\n    buffer = bytearray()\n    eol_bytes = eol.encode(encoding)\n\n    for chunk in byte_stream:\n        print(DOT, end=SPACE)\n        has_content = True\n        buffer.extend(chunk)\n        *lines, buffer = buffer.split(eol_bytes)  # keep partial line in buffer\n        trace(f\"streaming {len(lines)} lines; leftover {len(buffer)} chars\")\n        yield from (line.decode(encoding) for line in lines)\n\n    if buffer:  # yield the leftover\n        yield buffer.decode(encoding)\n\n    if not has_content:\n        trace(\"no lines\")\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.require_not_none","title":"<code>require_not_none(value, message='Value must not be None')</code>","text":"<p>Ensures that the provided value is not None.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Optional[T]</code> <p>The value to check for None.</p> required <code>message</code> <code>str</code> <p>The error message to use if value is None. Defaults to \"Value must not be None\".</p> <code>'Value must not be None'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If value is None.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The value, guaranteed to be not None.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>def require_not_none[T](\n        value: Optional[T],\n        message: str = \"Value must not be None\") -&gt; T:\n    \"\"\"\n    Ensures that the provided value is not None.\n\n    Args:\n        value (Optional[T]): The value to check for None.\n        message (str, optional): The error message to use if value is None. Defaults to \"Value must not be None\".\n\n    Raises:\n        ValueError: If value is None.\n\n    Returns:\n        T: The value, guaranteed to be not None.\n    \"\"\"\n    if value is None:\n        raise ValueError(message)\n    return value\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.safely","title":"<code>safely(supplier)</code>","text":"<p>Calls a function safely, wrapping its result in Maybe, and swallowing any exceptions. The function should be a no-argument callable::</p> <pre><code>safely(lambda: call_something_that_may_fail(params))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>supplier</code> <code>Supplier[T]</code> <p>The supplier to be called.</p> required <p>Returns:</p> Type Description <code>Maybe[T]</code> <p>Maybe[T]: The result wrapped in Maybe, or Nothing if an exception occurs.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/exception_utils.py</code> <pre><code>def safely[T](supplier: Supplier[T]) -&gt; Maybe[T]:\n    \"\"\"\n    Calls a function safely, wrapping its result in Maybe, and swallowing any exceptions.\n    The function should be a no-argument callable::\n\n        safely(lambda: call_something_that_may_fail(params))\n\n    Args:\n        supplier (Supplier[T]): The supplier to be called.\n\n    Returns:\n        Maybe[T]: The result wrapped in Maybe, or Nothing if an exception occurs.\n    \"\"\"\n    try:\n        return Some(supplier())\n    except Exception as e:\n        logging.exception(f\"Exception occurred: {e}\")\n        return Nothing\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.sleep_for","title":"<code>sleep_for(duration)</code>","text":"<p>Sleep for the specified duration.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>timedelta</code> <p>The amount of time to sleep.</p> required Source code in <code>qa-testing-utils/src/qa_testing_utils/thread_utils.py</code> <pre><code>def sleep_for(duration: timedelta):\n    \"\"\"\n    Sleep for the specified duration.\n\n    Args:\n        duration (timedelta): The amount of time to sleep.\n    \"\"\"\n    time.sleep(duration.total_seconds())\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.stream_file","title":"<code>stream_file(file_path, chunk_size=DEFAULT_BUFFER_SIZE)</code>","text":"<p>Streams a binary file from disk into an iterator.</p> <p>If the iterator is not consumed, the file will be closed when the iterator will be garbage collected.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>path to file</p> required <code>chunk_size</code> <code>int</code> <p>the chunk size. Defaults to 8192.</p> <code>DEFAULT_BUFFER_SIZE</code> <p>Yields:</p> Type Description <code>bytes</code> <p>Iterator[bytes]: the binary chunks stream</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>def stream_file(\n        file_path: Path,\n        chunk_size: int = DEFAULT_BUFFER_SIZE) -&gt; Iterator[bytes]:\n    \"\"\"\n    Streams a binary file from disk into an iterator.\n\n    If the iterator is not consumed, the file will be closed when the iterator\n    will be garbage collected.\n\n    Args:\n        file_path (Path): path to file\n        chunk_size (int, optional): the chunk size. Defaults to 8192.\n\n    Yields:\n        Iterator[bytes]: the binary chunks stream\n    \"\"\"\n    with file_path.open('rb') as f:\n        yield from iter(lambda: f.read(chunk_size), EMPTY_BYTES)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.swallow","title":"<code>swallow(func)</code>","text":"<p>Decorates a function to swallow any exceptions.</p> <p>If an exception will occur, None will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>the function, supplied by the run-time</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable[..., Any]</code> <p>the decorated function</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/exception_utils.py</code> <pre><code>def swallow(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n    \"\"\"\n    Decorates a function to swallow any exceptions.\n\n    If an exception will occur, None will be returned.\n\n    Args:\n        func (Callable): the function, supplied by the run-time\n\n    Returns:\n        Callable: the decorated function\n    \"\"\"\n    @functools.wraps(func)\n    def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n        return safely(lambda: func(*args, **kwargs)).value_or(None)\n\n    return wrapper\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.to_string","title":"<code>to_string(indent='    ', depth=1, width=72, seq_length=15, show_protected=False, show_private=False, show_static=False, show_properties=True, show_address=False, str_length=50)</code>","text":"<p>Class decorator providing a readable str implementation.</p> <p>The default Python str implementation, returns the type and the memory address of instance.</p> <p>Important for diagnostics, actually every object that is logged, must provide such readable str.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>str</code> <p>indentation; Defaults to '    '.</p> <code>'    '</code> <code>depth</code> <code>int</code> <p>depth in object hierarchy; defaults to 1.</p> <code>1</code> <code>width</code> <code>int</code> <p>width of line before line-feed; defaults to 72.</p> <code>72</code> <code>seq_length</code> <code>int</code> <p>how many items to include; defaults to 15.</p> <code>15</code> <code>show_protected</code> <code>bool</code> <p>include protected; Defaults to False.</p> <code>False</code> <code>show_private</code> <code>bool</code> <p>include private; defaults to False.</p> <code>False</code> <code>show_static</code> <code>bool</code> <p>include static; defaults to False.</p> <code>False</code> <code>show_properties</code> <code>bool</code> <p>include properties; defaults to True.</p> <code>True</code> <code>show_address</code> <code>bool</code> <p>include object's memory address; defaults to False.</p> <code>False</code> <code>str_length</code> <code>int</code> <p>maximum string length per item; defaults to 50.</p> <code>50</code> <p>Returns:</p> Type Description <code>Callable[[Type[T]], Type[T]]</code> <p>Callable[[Type[T]], Type[T]]: description</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/string_utils.py</code> <pre><code>def to_string[T](indent: str = '    ',\n                 depth: int = 1,\n                 width: int = 72,\n                 seq_length: int = 15,\n                 show_protected: bool = False,\n                 show_private: bool = False,\n                 show_static: bool = False,\n                 show_properties: bool = True,\n                 show_address: bool = False,\n                 str_length: int = 50) -&gt; Callable[[Type[T]], Type[T]]:\n    \"\"\"\n    Class decorator providing a readable __str__ implementation.\n\n    The default Python __str__ implementation, returns the type and the memory\n    address of instance.\n\n    Important for diagnostics, actually every object that is logged, must\n    provide such readable __str__.\n\n    Args:\n        indent (str, optional): indentation; Defaults to '    '.\n        depth (int, optional): depth in object hierarchy; defaults to 1.\n        width (int, optional): width of line before line-feed; defaults to 72.\n        seq_length (int, optional): how many items to include; defaults to 15.\n        show_protected (bool, optional): include protected; Defaults to False.\n        show_private (bool, optional): include private; defaults to False.\n        show_static (bool, optional): include static; defaults to False.\n        show_properties (bool, optional): include properties; defaults to True.\n        show_address (bool, optional): include object's memory address; defaults to False.\n        str_length (int, optional): maximum string length per item; defaults to 50.\n\n    Returns:\n        Callable[[Type[T]], Type[T]]: _description_\n    \"\"\"\n    def decorator(cls: Type[T]) -&gt; Type[T]:\n        def __str__(self: T) -&gt; str:\n            # IMPORTANT: must not use something that calls __str__\n            return ppretty(self,\n                           indent=indent,\n                           depth=depth,\n                           width=width,\n                           seq_length=seq_length,\n                           show_protected=show_protected,\n                           show_private=show_private,\n                           show_static=show_static,\n                           show_properties=show_properties,\n                           show_address=show_address,\n                           str_length=str_length)  # type: ignore\n\n        cls.__str__ = __str__\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.trace","title":"<code>trace(value)</code>","text":"<p>Logs at debug level using the invoking module name as the logger.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/logger.py</code> <pre><code>def trace[T](value: T) -&gt; T:\n    \"\"\"Logs at debug level using the invoking module name as the logger.\"\"\"\n    frame = inspect.currentframe()\n    try:\n        if frame is not None:\n            caller_frame = frame.f_back\n            if caller_frame is not None:\n                caller_module = inspect.getmodule(caller_frame)\n                logger_name = caller_module.__name__ if caller_module else '__main__'\n                logger = logging.getLogger(logger_name)\n                logger.debug(f\"=== {value}\")\n            else:\n                logging.getLogger(__name__).debug(f\"=== {value}\")\n        else:\n            logging.getLogger(__name__).debug(f\"=== {value}\")\n    finally:\n        del frame\n\n    return value\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.tracing","title":"<code>tracing(matcher)</code>","text":"<p>Wraps a matcher with TracingMatcher to enable debug logging.</p> Usage <p>assert_that(actual, traced(contains_string(\"hello\")))</p> <p>Parameters:</p> Name Type Description Default <code>matcher</code> <code>Matcher[T]</code> <p>The matcher to wrap.</p> required <p>Returns:     TracingMatcher[T]: The wrapped matcher with tracing enabled.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def tracing[T](matcher: Matcher[T]) -&gt; TracingMatcher[T]:\n    \"\"\"\n    Wraps a matcher with TracingMatcher to enable debug logging.\n\n    Usage:\n        assert_that(actual, traced(contains_string(\"hello\")))\n\n    Args:\n        matcher (Matcher[T]): The matcher to wrap.\n    Returns:\n        TracingMatcher[T]: The wrapped matcher with tracing enabled.\n    \"\"\"\n    return TracingMatcher(matcher)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.valid","title":"<code>valid(value)</code>","text":"<p>Validates the specified object, assuming it supports the Valid protocol.</p> <p>Parameters:</p> Name Type Description Default <code>value (T</code> <p>Valid): The object to validate.</p> required <p>Raises:</p> Type Description <code>InvalidValueException</code> <p>If the object is invalid (is_valid() returns False).</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>Valid: The validated object if valid.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/object_utils.py</code> <pre><code>def valid[T:Valid](value: T) -&gt; T:\n    \"\"\"\n    Validates the specified object, assuming it supports the Valid protocol.\n\n    Args:\n        value (T:Valid): The object to validate.\n\n    Raises:\n        InvalidValueException: If the object is invalid (is_valid() returns False).\n\n    Returns:\n        T:Valid: The validated object if valid.\n    \"\"\"\n    if value.is_valid():\n        return value\n\n    raise InvalidValueException(value)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.within_dates","title":"<code>within_dates(start_date, end_date)</code>","text":"<p>Creates an instance of IsWithinDates to check if a date or datetime value falls within the specified start and end dates.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>Optional[DateOrDateTime]</code> <p>The start of the date range. Can be None to indicate no lower bound.</p> required <code>end_date</code> <code>Optional[DateOrDateTime]</code> <p>The end of the date range. Can be None to indicate no upper bound.</p> required <p>Returns:</p> Name Type Description <code>IsWithinDates</code> <code>IsWithinDates</code> <p>An instance configured with the provided start and end dates.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def within_dates(\n        start_date: Optional[DateOrDateTime],\n        end_date: Optional[DateOrDateTime]) -&gt; IsWithinDates:\n    \"\"\"\n    Creates an instance of IsWithinDates to check if a date or datetime value falls within the specified start and end dates.\n\n    Args:\n        start_date (Optional[DateOrDateTime]): The start of the date range. Can be None to indicate no lower bound.\n        end_date (Optional[DateOrDateTime]): The end of the date range. Can be None to indicate no upper bound.\n\n    Returns:\n        IsWithinDates: An instance configured with the provided start and end dates.\n    \"\"\"\n    return IsWithinDates(start_date, end_date)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.write_csv","title":"<code>write_csv(file_path, data_stream)</code>","text":"<p>Writes a stream of flattened telemetry packets to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>Path to the CSV file to be written.</p> required <code>data_stream</code> <code>Iterable[dict[str, object]]</code> <p>Iterable of dictionaries representing the rows to be written.</p> required Source code in <code>qa-testing-utils/src/qa_testing_utils/file_utils.py</code> <pre><code>def write_csv(file_path: Path, data_stream: Iterable[dict[str, object]]):\n    \"\"\"\n    Writes a stream of flattened telemetry packets to a CSV file.\n\n    Args:\n        file_path: Path to the CSV file to be written.\n        data_stream: Iterable of dictionaries representing the rows to be written.\n    \"\"\"\n    stream = peekable(data_stream)  # Allow peeking to extract headers\n    try:\n        first_row: dict[str, object] = stream.peek()\n    except StopIteration:\n        # No data to write\n        return\n    with file_path.open(mode=\"w\", newline=\"\") as csv_file:\n        writer = csv.DictWriter(\n            csv_file, fieldnames=list(first_row.keys()))\n        writer.writeheader()\n        writer.writerows(stream)\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.yields_every","title":"<code>yields_every(match)</code>","text":"<p>Matches if every element yielded by the iterator matches a given matcher.</p> <p>:param match: The matcher to satisfy, or an expected value for equality matching.</p> <p>This matcher iterates through the evaluated iterator, checking that every element satisfies the given matcher. If any element does not match, the matcher fails.</p> <p>If the <code>match</code> argument is not a matcher, it is implicitly wrapped in an equality matcher.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def yields_every[T](match: Union[Matcher[T], T]) -&gt; Matcher[Iterator[T]]:\n    \"\"\"\n    Matches if every element yielded by the iterator matches a given matcher.\n\n    :param match: The matcher to satisfy, or an expected value for equality matching.\n\n    This matcher iterates through the evaluated iterator, checking that every\n    element satisfies the given matcher. If any element does not match, the matcher fails.\n\n    If the `match` argument is not a matcher, it is implicitly wrapped in an\n    equality matcher.\n    \"\"\"\n    return IsStreamContainingEvery(wrap_matcher(match))\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.yields_item","title":"<code>yields_item(match)</code>","text":"<p>Matches if any element of yielded by iterator matches a given matcher.</p> <p>:param match: The matcher to satisfy, or an expected value for     :py:func:<code>~hamcrest.core.core.isequal.equal_to</code> matching.</p> <p>This matcher iterates the evaluated iterator, searching for any element that satisfies a given matcher. If a matching element is found, <code>has_item</code> is satisfied.</p> <p>If the <code>match</code> argument is not a matcher, it is implicitly wrapped in an :py:func:<code>~hamcrest.core.core.isequal.equal_to</code> matcher to check for equality.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def yields_item[T](match: Union[Matcher[T], T]) -&gt; Matcher[Iterator[T]]:\n    \"\"\"\n    Matches if any element of yielded by iterator matches a given matcher.\n\n    :param match: The matcher to satisfy, or an expected value for\n        :py:func:`~hamcrest.core.core.isequal.equal_to` matching.\n\n    This matcher iterates the evaluated iterator, searching for any element\n    that satisfies a given matcher. If a matching element is found,\n    ``has_item`` is satisfied.\n\n    If the ``match`` argument is not a matcher, it is implicitly wrapped in an\n    :py:func:`~hamcrest.core.core.isequal.equal_to` matcher to check for\n    equality.\n    \"\"\"\n    return IsIteratorYielding(wrap_matcher(match))\n</code></pre>"},{"location":"api/qa-testing-utils/#qa_testing_utils.yields_items","title":"<code>yields_items(matches)</code>","text":"<p>Matches if each specified item is yielded at least once by the iterator.</p> <p>:param matches: An iterable of matchers or values, each of which should be yielded                 at least once in the iterator for this matcher to succeed.</p> <p>This matcher will iterate through the evaluated iterator and check if it yields at least one instance of each specified matcher or value.</p> Source code in <code>qa-testing-utils/src/qa_testing_utils/matchers.py</code> <pre><code>def yields_items[T](matches: Iterable[Union[Matcher[T],\n                                            T]]) -&gt; Matcher[Iterator[T]]:\n    \"\"\"\n    Matches if each specified item is yielded at least once by the iterator.\n\n    :param matches: An iterable of matchers or values, each of which should be yielded\n                    at least once in the iterator for this matcher to succeed.\n\n    This matcher will iterate through the evaluated iterator and check if it yields\n    at least one instance of each specified matcher or value.\n    \"\"\"\n    return IsIteratorYieldingAll([wrap_matcher(match) for match in matches])\n</code></pre>"}]}